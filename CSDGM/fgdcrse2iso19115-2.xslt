<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	FGDC RSE to ISO 19115-2 Transform using XPath 2.0 June 2011

	This is the XML Style sheet that transforms metadata conforming to the Content Standards
	for Digital Geospatial Metadata: Extensions for Remote Sensing Metadata of the Federal 
	Geographic Data Committee FGDC-STD-012-2002 version to the ISO 19115-2:2009(E).  
	This stylesheet can be applied to FGDC RSE XML to generate ISO 19115-2 XML.

	This file was generated by Altova MapForce 2009sp1

	Authors:
	This is the result of a collaboration of the Metadata Transform Working Group. 
	For further information, please contact NOAA's National Coastal Data 
	Development Center (NCDDC).
				National Coastal Data Development Center
				Toll Free: 866.732.2382
				E-mail: ncddcmetadata@noaa.gov
				
	Editors: 
	Anna.Milan@noaa.gov, 
	Ted.Habermann@noaa.gov

	Distribution Liability:
		NOAA makes no warranty regarding these data, expressed or implied, 
		nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		NODC and NCDDC cannot assume liability for any damages caused by any 
		errors or omissions in these data, nor as a result of the failure of these data 
		to function on a particular system. These files were developed for opensource uses.

	Use Constraints:
		The user is responsible for the results of any application of these transforms for other than its
		intended purpose. These transforms cannot guarantee valid output. Additional editing
		may need to be done in order to have valid records. The intent of these transforms is
		to get as much of the FGDC valid content mapped to ISO content as possible but cannot 
		guarantee against loss of information. Please feel free to edit transforms as needed for 
		your organizations needs.
		
		
		See fgdcrse2iso19115-2-revisionHistory.txt for listing of all changes to this document.
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmi="http://www.isotc211.org/2005/gmi" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml/3.2"
  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" exclude-result-prefixes="fn grp vmf xs xsi xsl">
  <xsl:variable name="thisXSLT">FGDC RSE to ISO 19115-2 transform</xsl:variable>
  <xsl:variable name="LastUpdateXSLT">2016-01-11</xsl:variable>
  <!-- MD_CellGeometryCode -->
  <xsl:template name="vmf:vmf1_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='POINT'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='PIXEL'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='GRID CELL'">
        <xsl:value-of select="'area'"/>
      </xsl:when>
      <xsl:when test="$input='VOXEL'">
        <xsl:value-of select="'area'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- MD_GeometricObjectTypeCode -->
  <xsl:template name="vmf:vmf3_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='POINT'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='ENTITY POINT'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='LABEL POINT'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='AREA POINT'">
        <xsl:value-of select="'point'"/>
      </xsl:when>
      <xsl:when test="$input='NODE, PLANAR GRAPH'">
        <xsl:value-of select="'surface'"/>
      </xsl:when>
      <xsl:when test="$input='NODE, NETWORK'">
        <xsl:value-of select="'surface'"/>
      </xsl:when>
      <xsl:when test="$input='STRING'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='LINK'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='COMPLETE CHAIN'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='AREA CHAIN'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
        <xsl:value-of select="'surface'"/>
      </xsl:when>
      <xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='ELLIPTICAL ARC'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='UNIFORM B-SPLINE'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='PIECEWISE BEZIER'">
        <xsl:value-of select="'curve'"/>
      </xsl:when>
      <xsl:when test="$input='RING WITH MIXED COMPOSITION'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='RING COMPOSED OF STRINGS'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='RING COMPOSED OF CHAINS'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='RING COMPOSED OF ARCS'">
        <xsl:value-of select="'composite'"/>
      </xsl:when>
      <xsl:when test="$input='G-POLYGON'">
        <xsl:value-of select="'complex'"/>
      </xsl:when>
      <xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
        <xsl:value-of select="'complex'"/>
      </xsl:when>
      <xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
        <xsl:value-of select="'complex'"/>
      </xsl:when>
      <xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
        <xsl:value-of select="'complex'"/>
      </xsl:when>
      <xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
        <xsl:value-of select="'complex'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- uom units -->
  <xsl:template name="vmf:vmf5_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='DECIMAL DEGREES'">
        <xsl:value-of select="'decimalDegrees'"/>
      </xsl:when>
      <xsl:when test="$input='DECIMAL MINUTES'">
        <xsl:value-of select="'decimalMinutes'"/>
      </xsl:when>
      <xsl:when test="$input='DECIMAL SECONDS'">
        <xsl:value-of select="'decimalSeconds'"/>
      </xsl:when>
      <xsl:when test="$input='DEGREES and DECIMAL MINUTES'">
        <xsl:value-of select="'degreesAndDecimalMinutes'"/>
      </xsl:when>
      <xsl:when test="$input='DEGREES, MINUTES, and DECIMAL SECONDS'">
        <xsl:value-of select="'degreesMinutesAndDecimalSeconds'"/>
      </xsl:when>
      <xsl:when test="$input='RADIANS'">
        <xsl:value-of select="'radians'"/>
      </xsl:when>
      <xsl:when test="$input='GRADS'">
        <xsl:value-of select="'grads'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <!-- geoform -->
  <xsl:template name="vmf:vmf7_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='ATLAS'">
        <xsl:value-of select="'mapHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='AUDIO'">
        <xsl:value-of select="'documentDigital'"/>
      </xsl:when>
      <xsl:when test="$input='DIAGRAM'">
        <xsl:value-of select="'documentDigital'"/>
      </xsl:when>
      <xsl:when test="$input='DOCUMENT'">
        <xsl:value-of select="'documentDigital'"/>
      </xsl:when>
      <xsl:when test="$input='GLOBE'">
        <xsl:value-of select="'documentHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='MAP'">
        <xsl:value-of select="'mapDigital'"/>
      </xsl:when>
      <xsl:when test="$input='PRINTED MAP'">
        <xsl:value-of select="'mapHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='MODEL'">
        <xsl:value-of select="'modelDigital'"/>
      </xsl:when>
      <xsl:when test="$input='PHYSICAL MODEL'">
        <xsl:value-of select="'modelHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='MULTIMEDIA PRESENTATION'">
        <xsl:value-of select="'imageDigital'"/>
      </xsl:when>
      <xsl:when test="$input='PROFILE'">
        <xsl:value-of select="'profileDigital'"/>
      </xsl:when>
      <xsl:when test="$input='CROSS-SECTION'">
        <xsl:value-of select="'profileHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='RASTER DIGITAL DATA'">
        <xsl:value-of select="'mapDigital'"/>
      </xsl:when>
      <xsl:when test="$input='REMOTE-SENSING IMAGE'">
        <xsl:value-of select="'imageDigital'"/>
      </xsl:when>
      <xsl:when test="$input='SECTION'">
        <xsl:value-of select="'profileHardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='SPREADSHEET'">
        <xsl:value-of select="'tableDigital'"/>
      </xsl:when>
      <xsl:when test="$input='TABULAR DIGITAL DATA'">
        <xsl:value-of select="'tableDigital'"/>
      </xsl:when>
      <xsl:when test="$input='VECTOR DIGITAL DATA'">
        <xsl:value-of select="'mapDigital'"/>
      </xsl:when>
      <xsl:when test="$input='VIDEO'">
        <xsl:value-of select="'videoDigital'"/>
      </xsl:when>
      <xsl:when test="$input='VIEW'">
        <xsl:value-of select="'imageDigital'"/>
      </xsl:when>
      <xsl:when test="$input='DATABASE'">
        <xsl:value-of select="'documentDigital'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf9_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='COMPLETED'">
        <xsl:value-of select="'completed'"/>
      </xsl:when>
      <xsl:when test="$input='COMPLETE'">
        <xsl:value-of select="'completed'"/>
      </xsl:when>
      <xsl:when test="$input='ARCHIVED'">
        <xsl:value-of select="'historicalArchive'"/>
      </xsl:when>
      <xsl:when test="$input='OBSOLETE'">
        <xsl:value-of select="'obsolete'"/>
      </xsl:when>
      <xsl:when test="$input='ON GOING'">
        <xsl:value-of select="'onGoing'"/>
      </xsl:when>
      <xsl:when test="$input='CONTINUALLY'">
        <xsl:value-of select="'onGoing'"/>
      </xsl:when>
      <xsl:when test="$input='PLANNED'">
        <xsl:value-of select="'planned'"/>
      </xsl:when>
      <xsl:when test="$input='REQUIRED'">
        <xsl:value-of select="'required'"/>
      </xsl:when>
      <xsl:when test="$input='IN PROGRESS'">
        <xsl:value-of select="'underDevelopment'"/>
      </xsl:when>
      <xsl:when test="$input='IN WORK'">
        <xsl:value-of select="'underDevelopment'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf11_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='CONTINUALLY'">
        <xsl:value-of select="'continual'"/>
      </xsl:when>
      <xsl:when test="$input='DAILY'">
        <xsl:value-of select="'daily'"/>
      </xsl:when>
      <xsl:when test="$input='WEEKLY'">
        <xsl:value-of select="'weekly'"/>
      </xsl:when>
      <xsl:when test="$input='TWO WEEKS'">
        <xsl:value-of select="'fortnightly'"/>
      </xsl:when>
      <xsl:when test="$input='MONTHLY'">
        <xsl:value-of select="'monthly'"/>
      </xsl:when>
      <xsl:when test="$input='QUARTERLY'">
        <xsl:value-of select="'quarterly'"/>
      </xsl:when>
      <xsl:when test="$input='BIANNUALLY'">
        <xsl:value-of select="'biannually'"/>
      </xsl:when>
      <xsl:when test="$input='ANNUALLY'">
        <xsl:value-of select="'annually'"/>
      </xsl:when>
      <xsl:when test="$input='YEARLY'">
        <xsl:value-of select="'annually'"/>
      </xsl:when>
      <xsl:when test="$input='AS NEEDED'">
        <xsl:value-of select="'asNeeded'"/>
      </xsl:when>
      <xsl:when test="$input='IRREGULAR'">
        <xsl:value-of select="'irregular'"/>
      </xsl:when>
      <xsl:when test="$input='NOT PLANNED'">
        <xsl:value-of select="'notPlanned'"/>
      </xsl:when>
      <xsl:when test="$input='NONE PLANNED'">
        <xsl:value-of select="'notPlanned'"/>
      </xsl:when>
      <xsl:when test="$input='UNKNOWN'">
        <xsl:value-of select="'unknown'"/>
      </xsl:when>
      <xsl:when test="$input='NONE'">
        <xsl:value-of select="'notPlanned'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf13_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='CONFIDENTIAL'">
        <xsl:value-of select="'confidential'"/>
      </xsl:when>
      <xsl:when test="$input='SECRET'">
        <xsl:value-of select="'secret'"/>
      </xsl:when>
      <xsl:when test="$input='TOP SECRET'">
        <xsl:value-of select="'topSecret'"/>
      </xsl:when>
      <xsl:when test="$input='UNCLASSIFIED'">
        <xsl:value-of select="'unclassified'"/>
      </xsl:when>
      <xsl:when test="$input='RESTRICTED'">
        <xsl:value-of select="'restricted'"/>
      </xsl:when>
      <xsl:when test="$input='SENSITIVE'">
        <xsl:value-of select="'restricted'"/>
      </xsl:when>
      <xsl:when test="$input='SECERT'">
        <xsl:value-of select="'secret'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf15_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='POINT'">
        <xsl:value-of select="'vector'"/>
      </xsl:when>
      <xsl:when test="$input='VECTOR'">
        <xsl:value-of select="'vector'"/>
      </xsl:when>
      <xsl:when test="$input='RASTER'">
        <xsl:value-of select="'grid'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf17_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='CD-ROM'">
        <xsl:value-of select="'cdRom'"/>
      </xsl:when>
      <xsl:when test="$input='DVD'">
        <xsl:value-of select="'dvd'"/>
      </xsl:when>
      <xsl:when test="$input='DVD-ROM'">
        <xsl:value-of select="'dvdRom'"/>
      </xsl:when>
      <xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
        <xsl:value-of select="'3halfInchFloppy'"/>
      </xsl:when>
      <xsl:when test="$input='5-1/4 INCH FLOPPY'">
        <xsl:value-of select="'5quarterInchFloppy'"/>
      </xsl:when>
      <xsl:when test="$input='7-TRACK TAPE'">
        <xsl:value-of select="'7trackTape'"/>
      </xsl:when>
      <xsl:when test="$input='9-TRACK TAPE'">
        <xsl:value-of select="'9trackType'"/>
      </xsl:when>
      <xsl:when test="$input='9-TRACK'">
        <xsl:value-of select="'9trackTape'"/>
      </xsl:when>
      <xsl:when test="$input='3480 CARTRIDGE'">
        <xsl:value-of select="'3480Cartridge'"/>
      </xsl:when>
      <xsl:when test="$input='3490 CARTRIDGE'">
        <xsl:value-of select="'3490Cartridge'"/>
      </xsl:when>
      <xsl:when test="$input='3580 CARTRIDGE'">
        <xsl:value-of select="'3580Cartridge'"/>
      </xsl:when>
      <xsl:when test="$input='4 MM CARTRIDGE'">
        <xsl:value-of select="'4mmCartridgeTape'"/>
      </xsl:when>
      <xsl:when test="$input='8 MM CARTRIDGE'">
        <xsl:value-of select="'8mmCartridgeTape'"/>
      </xsl:when>
      <xsl:when test="$input='1/4 INCH CARTRIDGE'">
        <xsl:value-of select="'1quarterInchCartridgeTape'"/>
      </xsl:when>
      <xsl:when test="$input='DIGITAL LINEAR TAPE'">
        <xsl:value-of select="'digitalLinearTape'"/>
      </xsl:when>
      <xsl:when test="$input='ONLINE'">
        <xsl:value-of select="'onLine'"/>
      </xsl:when>
      <xsl:when test="$input='SATELLITE'">
        <xsl:value-of select="'satellite'"/>
      </xsl:when>
      <xsl:when test="$input='TELEPHONE LINK'">
        <xsl:value-of select="'telephoneLink'"/>
      </xsl:when>
      <xsl:when test="$input='HARDCOPY'">
        <xsl:value-of select="'hardcopy'"/>
      </xsl:when>
      <xsl:when test="$input='CD ROM'">
        <xsl:value-of select="'cdRom'"/>
      </xsl:when>
      <xsl:when test="$input='CDROM'">
        <xsl:value-of select="'cdRom'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="vmf:vmf19_inputtoresult">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='CPIO'">
        <xsl:value-of select="'cpio'"/>
      </xsl:when>
      <xsl:when test="$input='TAR'">
        <xsl:value-of select="'tar'"/>
      </xsl:when>
      <xsl:when test="$input='HIGH SEIRRA'">
        <xsl:value-of select="'highSierra'"/>
      </xsl:when>
      <xsl:when test="$input='ISO 9660'">
        <xsl:value-of select="'iso9660'"/>
      </xsl:when>
      <xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
        <xsl:value-of select="'iso9660RockRidge'"/>
      </xsl:when>
      <xsl:when test="$input='ISO 9660 UNIX'">
        <xsl:value-of select="'iso9660RockRidge'"/>
      </xsl:when>
      <xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
        <xsl:value-of select="'iso9660AppleHFS'"/>
      </xsl:when>
      <xsl:when test="$input='ISO 9660 MAC'">
        <xsl:value-of select="'iso9660AppleHFS'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:template name="functionCode">
    <xsl:param name="input" select="()"/>
    <xsl:choose>
      <xsl:when test="$input='DOWNLOAD'">
        <xsl:value-of select="'download'"/>
      </xsl:when>
      <xsl:when test="$input='INFORMATION'">
        <xsl:value-of select="'information'"/>
      </xsl:when>
      <xsl:when test="$input='ORDER'">
        <xsl:value-of select="'order'"/>
      </xsl:when>
      <xsl:when test="$input='SEARCH'">
        <xsl:value-of select="'search'"/>
      </xsl:when>
      <xsl:when test="$input='OFFLINEACCESS'">
        <xsl:value-of select="'offlineAccess'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$input"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  <xsl:output method="xml" encoding="UTF-8" indent="yes"/>
  <xsl:function name="grp:key1b9404f8">
    <xsl:param name="cur"/>
    <xsl:for-each select="$cur/origin">
      <xsl:sequence select="xs:string(xs:string(.))"/>
    </xsl:for-each>
  </xsl:function>
  <xsl:template match="/">
    <gmi:MI_Metadata>
      <xsl:attribute name="xsi:schemaLocation" separator=" ">
        <xsl:sequence select="'http://www.isotc211.org/2005/gmi http://www.ngdc.noaa.gov/metadata/published/xsd/schema.xsd'"/>
      </xsl:attribute>
      <xsl:variable name="var1_instance" as="node()" select="."/>
      <gmd:fileIdentifier>
        <xsl:for-each select="$var1_instance/metadata">
          <gco:CharacterString>
            <xsl:choose>
              <xsl:when test="idinfo/datsetid">
                <xsl:sequence select="fn:normalize-space(fn:concat(' ', xs:string(idinfo/datsetid)))"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="replace(replace(tokenize(fn:base-uri(.),'/')[last()],'%20',' '),'.xml','')"/>
              </xsl:otherwise>
            </xsl:choose>
          </gco:CharacterString>
        </xsl:for-each>
      </gmd:fileIdentifier>
      <gmd:language>
        <gco:CharacterString>
          <xsl:sequence select="'eng; USA'"/>
        </gco:CharacterString>
      </gmd:language>
      <gmd:characterSet>
        <gmd:MD_CharacterSetCode>
          <xsl:attribute name="codeList">
            <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode'))"/>
          </xsl:attribute>
          <xsl:attribute name="codeListValue">
            <xsl:sequence select="xs:string(('utf8'))"/>
          </xsl:attribute>
          <xsl:sequence select="'utf8'"/>
        </gmd:MD_CharacterSetCode>
      </gmd:characterSet>
      <gmd:hierarchyLevel>
        <gmd:MD_ScopeCode>
          <xsl:attribute name="codeList">
            <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
          </xsl:attribute>
          <xsl:attribute name="codeListValue">
            <xsl:sequence select="xs:string(('dataset'))"/>
          </xsl:attribute>
          <xsl:sequence select="'dataset'"/>
        </gmd:MD_ScopeCode>
      </gmd:hierarchyLevel>
      <xsl:for-each select="//metainfo/metc/cntinfo">
        <gmd:contact>
          <xsl:call-template name="CI_ResponsibleParty">
            <xsl:with-param name="role">pointOfContact</xsl:with-param>
          </xsl:call-template>
        </gmd:contact>
      </xsl:for-each>
      <gmd:dateStamp>
        <xsl:comment><xsl:value-of select="normalize-space(//metd)"/></xsl:comment>
        <xsl:choose>
          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(//metd))), 'unknown'))">
            <xsl:attribute name="gco:nilReason">
              <xsl:sequence select="xs:string('unknown')"/>
            </xsl:attribute>
          </xsl:when>
          <xsl:otherwise>
            <gco:Date>
              <xsl:call-template name="fgdc2isoDate">
                <xsl:with-param name="dateField" select="normalize-space(//metd)"/>
              </xsl:call-template>
            </gco:Date>
          </xsl:otherwise>
        </xsl:choose>
      </gmd:dateStamp>
      <gmd:metadataStandardName>
        <gco:CharacterString>
          <xsl:sequence select="'ISO 19115-2 Geographic Information - Metadata - Part 2: Extensions for Imagery and Gridded Data'"/>
        </gco:CharacterString>
      </gmd:metadataStandardName>
      <gmd:metadataStandardVersion>
        <gco:CharacterString>
          <xsl:sequence select="'ISO 19115-2:2009(E)'"/>
        </gco:CharacterString>
      </gmd:metadataStandardVersion>
      <xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var76_metadata" as="node()" select="."/>
        <xsl:for-each select="spdoinfo/rastinfo">
          <gmd:spatialRepresentationInfo>
            <xsl:variable name="var80_rastinfo" as="node()" select="."/>
            <gmd:MD_GridSpatialRepresentation>
              <gmd:numberOfDimensions>
                <xsl:variable name="row" as="xs:integer?" select="(if (fn:exists(rowcount)) then xs:integer(1) else xs:integer(0))"/>
                <xsl:variable name="col" as="xs:integer?" select="(if (fn:exists(colcount)) then xs:integer(1) else xs:integer(0))"/>
                <xsl:variable name="vert" as="xs:integer?" select="(if (fn:exists(vrtcount)) then xs:integer(1) else xs:integer(0))"/>
                <gco:Integer>
                  <xsl:value-of select="xs:string(xs:integer($row + $col + $vert))"/>
                </gco:Integer>
              </gmd:numberOfDimensions>
              <xsl:if test="./rowcount">
                <gmd:axisDimensionProperties>
                  <gmd:MD_Dimension>
                    <gmd:dimensionName>
                      <xsl:variable name="var87_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/rowcount)) then 'row' else ())"/>
                      <xsl:if test="fn:exists($var87_cond_result_exists)">
                        <gmd:MD_DimensionNameTypeCode>
                          <xsl:variable name="var88_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/rowcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
                          <xsl:if test="fn:exists($var88_cond_result_exists)">
                            <xsl:attribute name="codeList">
                              <xsl:sequence select="xs:string(($var88_cond_result_exists))"/>
                            </xsl:attribute>
                          </xsl:if>
                          <xsl:attribute name="codeListValue">
                            <xsl:sequence select="xs:string(($var87_cond_result_exists))"/>
                          </xsl:attribute>
                          <xsl:sequence select="$var87_cond_result_exists"/>
                        </gmd:MD_DimensionNameTypeCode>
                      </xsl:if>
                    </gmd:dimensionName>
                    <gmd:dimensionSize>
                      <xsl:for-each select="$var80_rastinfo/rowcount">
                        <gco:Integer>
                          <xsl:sequence select="xs:string((.))"/>
                        </gco:Integer>
                      </xsl:for-each>
                    </gmd:dimensionSize>
                    <xsl:for-each select="/metadata/spref/horizsys/geograph/longres">
                      <gmd:resolution>
                        <gco:Measure uom="decimalDegrees">
                          <xsl:value-of select="normalize-space(.)"/>
                        </gco:Measure>
                      </gmd:resolution>
                    </xsl:for-each>
                  </gmd:MD_Dimension>
                </gmd:axisDimensionProperties>
              </xsl:if>
              <xsl:if test="./colcount">
                <gmd:axisDimensionProperties>
                  <gmd:MD_Dimension>
                    <gmd:dimensionName>
                      <xsl:variable name="var94_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/colcount)) then 'column' else ())"/>
                      <xsl:if test="fn:exists($var94_cond_result_exists)">
                        <gmd:MD_DimensionNameTypeCode>
                          <xsl:variable name="var95_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/colcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
                          <xsl:if test="fn:exists($var95_cond_result_exists)">
                            <xsl:attribute name="codeList">
                              <xsl:sequence select="xs:string(($var95_cond_result_exists))"/>
                            </xsl:attribute>
                          </xsl:if>
                          <xsl:attribute name="codeListValue">
                            <xsl:sequence select="xs:string(($var94_cond_result_exists))"/>
                          </xsl:attribute>
                          <xsl:sequence select="$var94_cond_result_exists"/>
                        </gmd:MD_DimensionNameTypeCode>
                      </xsl:if>
                    </gmd:dimensionName>
                    <gmd:dimensionSize>
                      <xsl:for-each select="$var80_rastinfo/colcount">
                        <gco:Integer>
                          <xsl:sequence select="xs:string(.)"/>
                        </gco:Integer>
                      </xsl:for-each>
                    </gmd:dimensionSize>
                    <xsl:for-each select="/metadata/spref/horizsys/geograph/latres">
                      <gmd:resolution>
                        <gco:Measure uom="decimalDegrees">
                          <xsl:value-of select="normalize-space(.)"/>
                        </gco:Measure>
                      </gmd:resolution>
                    </xsl:for-each>
                  </gmd:MD_Dimension>
                </gmd:axisDimensionProperties>
              </xsl:if>
              <xsl:if test="./vrtcount">
                <gmd:axisDimensionProperties>
                  <gmd:MD_Dimension>
                    <gmd:dimensionName>
                      <xsl:variable name="var101_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/vrtcount)) then 'vertical' else ())"/>
                      <xsl:if test="fn:exists($var101_cond_result_exists)">
                        <gmd:MD_DimensionNameTypeCode>
                          <xsl:variable name="var102_cond_result_exists" as="xs:string?" select="(if (fn:exists($var80_rastinfo/vrtcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
                          <xsl:if test="fn:exists($var102_cond_result_exists)">
                            <xsl:attribute name="codeList">
                              <xsl:sequence select="xs:string(($var102_cond_result_exists))"/>
                            </xsl:attribute>
                          </xsl:if>
                          <xsl:attribute name="codeListValue">
                            <xsl:sequence select="xs:string(($var101_cond_result_exists))"/>
                          </xsl:attribute>
                          <xsl:sequence select="$var101_cond_result_exists"/>
                        </gmd:MD_DimensionNameTypeCode>
                      </xsl:if>
                    </gmd:dimensionName>
                    <gmd:dimensionSize>
                      <xsl:for-each select="$var80_rastinfo/vrtcount">
                        <gco:Integer>
                          <xsl:sequence select="xs:string(xs:integer(.))"/>
                        </gco:Integer>
                      </xsl:for-each>
                    </gmd:dimensionSize>
                  </gmd:MD_Dimension>
                </gmd:axisDimensionProperties>
              </xsl:if>
              <gmd:cellGeometry>
                <xsl:variable name="var119_map_select_rasttype" as="xs:string?">
                  <xsl:for-each select="rasttype">
                    <xsl:sequence select="fn:string(.)"/>
                  </xsl:for-each>
                </xsl:variable>
                <xsl:variable name="var106_cond_result_exists" as="xs:string?">
                  <xsl:choose>
                    <xsl:when test="fn:exists($var119_map_select_rasttype)">
                      <xsl:for-each select="rasttype">
                        <xsl:variable name="var123_result_vmf1_inputtoresult" as="xs:string?">
                          <xsl:call-template name="vmf:vmf1_inputtoresult">
                            <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
                          </xsl:call-template>
                        </xsl:variable>
                        <xsl:if test="fn:exists($var123_result_vmf1_inputtoresult)">
                          <xsl:sequence select="$var123_result_vmf1_inputtoresult"/>
                        </xsl:if>
                      </xsl:for-each>
                    </xsl:when>
                  </xsl:choose>
                </xsl:variable>
                <xsl:choose>
                  <xsl:when test="fn:exists($var106_cond_result_exists)">
                    <gmd:MD_CellGeometryCode>
                      <xsl:attribute name="codeList">
                        <xsl:variable name="var108_map_select_rasttype" as="xs:string?">
                          <xsl:for-each select="rasttype">
                            <xsl:sequence select="fn:string(.)"/>
                          </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="var107_cond_result_exists" as="xs:string" select="(if (fn:exists($var108_map_select_rasttype)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode' else '')"/>
                        <xsl:sequence select="xs:string(($var107_cond_result_exists))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(($var106_cond_result_exists))"/>
                      </xsl:attribute>
                      <xsl:variable name="var112_map_select_rasttype" as="xs:string?">
                        <xsl:for-each select="rasttype">
                          <xsl:sequence select="fn:string(.)"/>
                        </xsl:for-each>
                      </xsl:variable>
                      <xsl:sequence select="$var106_cond_result_exists"/>
                    </gmd:MD_CellGeometryCode>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:value-of select="'template'"/>
                    </xsl:attribute>
                    <xsl:comment>FGDC content not mapped to ISO. From Xpath: //spdoinfo/rastinfo/rasttype</xsl:comment>
                    <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                    <xsl:copy-of select="//spdoinfo/rastinfo/rasttype"/>
                    <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                  </xsl:otherwise>
                </xsl:choose>
              </gmd:cellGeometry>
              <gmd:transformationParameterAvailability>
                <xsl:variable name="var126_cond_result_exists" as="xs:string?" select="(if (fn:exists(rowcount)) then 'unknown' else ())"/>
                <xsl:if test="fn:exists($var126_cond_result_exists)">
                  <xsl:attribute name="gco:nilReason">
                    <xsl:sequence select="xs:string(xs:string($var126_cond_result_exists))"/>
                  </xsl:attribute>
                </xsl:if>
              </gmd:transformationParameterAvailability>
            </gmd:MD_GridSpatialRepresentation>
          </gmd:spatialRepresentationInfo>
        </xsl:for-each>
        <xsl:for-each select="spdoinfo/ptvctinf">
          <gmd:spatialRepresentationInfo>
            <xsl:variable name="var127_ptvctinf" as="node()" select="."/>
            <gmd:MD_VectorSpatialRepresentation>
              <xsl:for-each select="vpfterm">
                <gmd:topologyLevel gco:nilReason="template">
                  <xsl:comment>
                    <xsl:text>FGDC content did not map to ISO. Hand edit MD_TopologyLevelCode. </xsl:text>
                  </xsl:comment>
                  <xsl:comment>
                    <xsl:text>vpflevel: </xsl:text>
                    <xsl:sequence select="xs:string((fn:normalize-space(fn:string(vpflevel))))"/>
                  </xsl:comment>
                </gmd:topologyLevel>
              </xsl:for-each>
              <xsl:for-each select="sdtsterm">
                <gmd:geometricObjects>
                  <gmd:MD_GeometricObjects>
                    <gmd:geometricObjectType>
                      <gmd:MD_GeometricObjectTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode" codeListValue="{sdtstype}">
                        <xsl:value-of select="sdtstype"/>
                      </gmd:MD_GeometricObjectTypeCode>
                    </gmd:geometricObjectType>
                    <xsl:if test="ptvctcnt">
                      <gmd:geometricObjectCount>
                        <gco:Integer>
                          <xsl:value-of select="ptvctcnt"/>
                        </gco:Integer>
                      </gmd:geometricObjectCount>
                    </xsl:if>
                  </gmd:MD_GeometricObjects>
                </gmd:geometricObjects>
              </xsl:for-each>
            </gmd:MD_VectorSpatialRepresentation>
          </gmd:spatialRepresentationInfo>
        </xsl:for-each>
      </xsl:for-each>
      <!--<xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var180_metadata" as="node()" select="."/>
        <xsl:for-each select="spref/horizsys/geograph">
          <gmd:spatialRepresentationInfo>
            <gmd:MD_GridSpatialRepresentation>
              <gmd:numberOfDimensions>
                <gco:Integer>
                  <xsl:sequence select="xs:string(xs:integer(xs:decimal(2)))"/>
                </gco:Integer>
              </gmd:numberOfDimensions>
              <gmd:axisDimensionProperties>
                <gmd:MD_Dimension>
                  <gmd:dimensionName>
                    <gmd:MD_DimensionNameTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('column'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'column'"/>
                    </gmd:MD_DimensionNameTypeCode>
                  </gmd:dimensionName>
                  <gmd:dimensionSize>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                    </xsl:attribute>
                  </gmd:dimensionSize>
                  <gmd:resolution>
                    <gco:Scale>
                      <xsl:variable name="var184_result_vmf5_inputtoresult" as="xs:string?">
                        <xsl:call-template name="vmf:vmf5_inputtoresult">
                          <xsl:with-param name="input" select="fn:upper-case(xs:string(xs:token(geogunit)))"/>
                        </xsl:call-template>
                      </xsl:variable>
                      <xsl:if test="fn:exists($var184_result_vmf5_inputtoresult)">
                        <xsl:attribute name="uom">
                          <xsl:sequence select="xs:string(xs:string($var184_result_vmf5_inputtoresult))"/>
                        </xsl:attribute>
                      </xsl:if>
                      <xsl:sequence select="normalize-space(latres)"/>
                      <!-\-<xsl:sequence select="xs:string(xs:double(latres))"/>-\->
                    </gco:Scale>
                  </gmd:resolution>
                </gmd:MD_Dimension>
              </gmd:axisDimensionProperties>
              <gmd:axisDimensionProperties>
                <gmd:MD_Dimension>
                  <gmd:dimensionName>
                    <gmd:MD_DimensionNameTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('row'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'row'"/>
                    </gmd:MD_DimensionNameTypeCode>
                  </gmd:dimensionName>
                  <gmd:dimensionSize>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                    </xsl:attribute>
                  </gmd:dimensionSize>
                  <gmd:resolution>
                    <gco:Scale>
                      <xsl:variable name="var185_result_vmf5_inputtoresult" as="xs:string?">
                        <xsl:call-template name="vmf:vmf5_inputtoresult">
                          <xsl:with-param name="input" select="fn:upper-case(xs:string(xs:token(geogunit)))"/>
                        </xsl:call-template>
                      </xsl:variable>
                      <xsl:if test="fn:exists($var185_result_vmf5_inputtoresult)">
                        <xsl:attribute name="uom">
                          <xsl:sequence select="xs:string(xs:string($var185_result_vmf5_inputtoresult))"/>
                        </xsl:attribute>
                      </xsl:if>
                      <xsl:sequence select="xs:string((longres))"/>
                    </gco:Scale>
                  </gmd:resolution>
                </gmd:MD_Dimension>
              </gmd:axisDimensionProperties>
              <gmd:cellGeometry>
                <xsl:variable name="var186_cond_result_exists" as="xs:string?">
                  <xsl:choose>
                    <xsl:when test="fn:exists($var180_metadata/spdoinfo/rastinfo/rasttype)">
                      <xsl:for-each select="$var180_metadata/spdoinfo/rastinfo/rasttype">
                        <xsl:variable name="var196_result_vmf1_inputtoresult" as="xs:string?">
                          <xsl:call-template name="vmf:vmf1_inputtoresult">
                            <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:token(.))))"/>
                          </xsl:call-template>
                        </xsl:variable>
                        <xsl:if test="fn:exists($var196_result_vmf1_inputtoresult)">
                          <xsl:sequence select="$var196_result_vmf1_inputtoresult"/>
                        </xsl:if>
                      </xsl:for-each>
                    </xsl:when>
                  </xsl:choose>
                </xsl:variable>
                <xsl:choose>
                  <xsl:when test="fn:exists($var186_cond_result_exists)">
                    <gmd:MD_CellGeometryCode>
                      <xsl:attribute name="codeList">
                        <xsl:variable name="var187_cond_result_exists" as="xs:string" select="(if (fn:exists($var180_metadata/spdoinfo/rastinfo/rasttype)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode' else '')"/>
                        <xsl:sequence select="xs:string(($var187_cond_result_exists))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(($var186_cond_result_exists))"/>
                      </xsl:attribute>
                      <xsl:sequence select="$var186_cond_result_exists"/>
                    </gmd:MD_CellGeometryCode>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:value-of select="'template'"/>
                    </xsl:attribute>
                    <xsl:comment>FGDC content not mapped to ISO. From Xpath: //spdoinfo/rastinfo/rasttype</xsl:comment>
                    <xsl:text disable-output-escaping="yes">&lt;!-/-</xsl:text>
                    <xsl:copy-of select="//spdoinfo/rastinfo/rasttype"/>
                    <xsl:text disable-output-escaping="yes">-/-&gt;</xsl:text>
                  </xsl:otherwise>
                </xsl:choose>
              </gmd:cellGeometry>
              <gmd:transformationParameterAvailability>
                <gco:Boolean>
                  <xsl:sequence select="xs:string(((('0' != 'false') and ('false' != 'false')) and fn:boolean('false')))"/>
                </gco:Boolean>
              </gmd:transformationParameterAvailability>
            </gmd:MD_GridSpatialRepresentation>
          </gmd:spatialRepresentationInfo>
        </xsl:for-each>
      </xsl:for-each>-->
      <xsl:for-each select="$var1_instance/metadata/spdoinfo/indspref">
        <gmd:referenceSystemInfo gco:nilReason="template"/>
        <xsl:comment>
          <xsl:text>FGDC Content not mapped to ISO from Xpath: //spdoinfo/indspref</xsl:text>
        </xsl:comment>
        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
        <xsl:copy-of select="//spdoinfo/indspref"/>
        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
      </xsl:for-each>
      <xsl:for-each select="//spref/horizsys/geodetic/horizdn">
        <xsl:comment>
              <xsl:value-of select="normalize-space(.)"/>
            </xsl:comment>
        <xsl:choose>
          <xsl:when test="contains(normalize-space(.), '84') and contains(normalize-space(.), 'WGS')">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/2504d000-8345-11e1-b0c4-0800200c9a66" xlink:title="WGS84"/>
          </xsl:when>
          <xsl:when test="(contains(normalize-space(.), '83') and contains(normalize-space(.), 'North American')) or (contains(normalize-space(.), '83') and contains(normalize-space(.), 'NAD'))">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/65f8b220-95ed-11e0-aa80-0800200c9a66" xlink:title="NAD83"/>
          </xsl:when>
          <xsl:otherwise>
            <gmd:referenceSystemInfo gco:nilReason="template"/>
            <xsl:comment>Geodetic Horizontal Datum not mapped to ISO</xsl:comment>
            <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
            <xsl:copy-of select="../../geodetic"/>
            <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
      <!-- note: altdatum is same as depthdatum in DEMs, not including both (am) -->
      <xsl:for-each select="//spref/vertdef/altsys/altdatum">
        <xsl:comment>
             <xsl:value-of select="normalize-space(.)"/>, vertical units: <xsl:value-of select="normalize-space(../altunits)"/>
         </xsl:comment>
        <xsl:choose>
          <xsl:when test="contains(normalize-space(.), 'MLW') or contains(normalize-space(.), 'Mean Low Water')">
            <gmd:referenceSystemInfo xlink:href="https://ngdc.noaa.gov/docucomp/3c7f7694-46d6-41cb-9bca-0fee2928aeef" xlink:title="MLW"/>
          </xsl:when>
          <xsl:when test="contains(normalize-space(.), 'MLLW') or contains(normalize-space(.), 'Mean Lower Low Water')">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/defe1bdc-40fd-426b-a262-a57b9909d08c" xlink:title="MLLW"/>
          </xsl:when>
          <xsl:when test="contains(normalize-space(.), 'MHW') or contains(normalize-space(.), 'Mean High Water')">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/0916ce75-a087-46f8-933f-200353c9ffb8" xlink:title="MHW"/>
          </xsl:when>
          <xsl:when test="contains(normalize-space(.), 'MHHW') or contains(normalize-space(.), 'Mean Higher High Water')">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/9e461b22-6ab2-4393-9567-ad18991cc232" xlink:title="MHHW"/>
          </xsl:when>
          <xsl:when test="contains(normalize-space(.), 'MSL') or contains(normalize-space(.), 'Mean Sea Level')">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/5c1683f2-0c91-46ac-9ecf-07fc5de88e00" xlink:title="MSL"/>
          </xsl:when>
          <xsl:when test="(contains(normalize-space(.), '88') and contains(normalize-space(.), 'North American')) or (contains(normalize-space(.), '88') and contains(normalize-space(.), 'NAVD'))">
            <gmd:referenceSystemInfo xlink:href="http://www.ngdc.noaa.gov/docucomp/7bfef30a-970e-48de-a173-675dc4b61695" xlink:title="NAVD88"/>
          </xsl:when>
          <xsl:otherwise>
            <gmd:referenceSystemInfo gco:nilReason="template"/>
            <xsl:comment>Vertical Datum not mapped to ISO</xsl:comment>
            <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
            <xsl:copy-of select="."/>
            <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
      <xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var201_metadata" as="node()" select="."/>
        <gmd:identificationInfo>
          <gmd:MD_DataIdentification>
            <gmd:citation>
              <xsl:for-each select="idinfo/citation/citeinfo">
                <xsl:call-template name="CI_Citation"/>
              </xsl:for-each>
            </gmd:citation>
            <gmd:abstract>
              <gco:CharacterString>
                <xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/abstract))"/>
              </gco:CharacterString>
            </gmd:abstract>
            <gmd:purpose>
              <gco:CharacterString>
                <xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/purpose))"/>
              </gco:CharacterString>
            </gmd:purpose>
            <xsl:for-each-group select="idinfo/datacred" group-by="fn:normalize-space(xs:string(.))">
              <xsl:variable name="var297_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
              <gmd:credit>
                <gco:CharacterString>
                  <xsl:sequence select="$var297_cur_result_groupby"/>
                </gco:CharacterString>
              </gmd:credit>
            </xsl:for-each-group>
            <xsl:if test="idinfo/status/progress">
              <gmd:status>
                <xsl:variable name="var302_result_vmf9_inputtoresult" as="xs:string?">
                  <xsl:call-template name="vmf:vmf9_inputtoresult">
                    <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/progress)))"/>
                  </xsl:call-template>
                </xsl:variable>
                <xsl:variable name="var299_cond_result_exists" as="xs:string?" select="(if (fn:exists($var302_result_vmf9_inputtoresult)) then $var302_result_vmf9_inputtoresult else ())"/>
                <xsl:if test="fn:exists($var299_cond_result_exists)">
                  <gmd:MD_ProgressCode>
                    <xsl:attribute name="codeList">
                      <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode'))"/>
                    </xsl:attribute>
                    <xsl:attribute name="codeListValue">
                      <xsl:sequence select="xs:string($var299_cond_result_exists)"/>
                    </xsl:attribute>
                    <xsl:sequence select="$var299_cond_result_exists"/>
                  </gmd:MD_ProgressCode>
                </xsl:if>
              </gmd:status>
            </xsl:if>
            <xsl:for-each select="idinfo/ptcontac">
              <gmd:pointOfContact>
                <xsl:call-template name="CI_ResponsibleParty">
                  <xsl:with-param name="role">pointOfContact</xsl:with-param>
                </xsl:call-template>
              </gmd:pointOfContact>
            </xsl:for-each>
            <gmd:resourceMaintenance>
              <gmd:MD_MaintenanceInformation>
                <gmd:maintenanceAndUpdateFrequency>
                  <xsl:variable name="var358_result_vmf11_inputtoresult" as="xs:string?">
                    <xsl:call-template name="vmf:vmf11_inputtoresult">
                      <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
                    </xsl:call-template>
                  </xsl:variable>
                  <xsl:variable name="var355_cond_result_exists" as="xs:string?" select="(if (fn:exists($var358_result_vmf11_inputtoresult)) then $var358_result_vmf11_inputtoresult else ())"/>
                  <xsl:if test="fn:exists($var355_cond_result_exists)">
                    <gmd:MD_MaintenanceFrequencyCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string($var355_cond_result_exists)"/>
                      </xsl:attribute>
                      <!--<xsl:variable name="var357_result_vmf12_inputtoresult" as="xs:string?">
                        <xsl:call-template name="vmf:vmf12_inputtoresult">
                          <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/status/update))))"/>
                        </xsl:call-template>
                      </xsl:variable>-->
                      <xsl:sequence select="$var355_cond_result_exists"/>
                    </gmd:MD_MaintenanceFrequencyCode>
                  </xsl:if>
                </gmd:maintenanceAndUpdateFrequency>
              </gmd:MD_MaintenanceInformation>
            </gmd:resourceMaintenance>
            <xsl:for-each select="eainfo/detailed/attr/attrmfrq">
              <gmd:resourceMaintenance>
                <gmd:MD_MaintenanceInformation>
                  <gmd:maintenanceAndUpdateFrequency>
                    <xsl:variable name="var364_result_vmf11_inputtoresult" as="xs:string?">
                      <xsl:call-template name="vmf:vmf11_inputtoresult">
                        <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
                      </xsl:call-template>
                    </xsl:variable>
                    <xsl:variable name="var361_cond_result_exists" as="xs:string?" select="(if (fn:exists($var364_result_vmf11_inputtoresult)) then $var364_result_vmf11_inputtoresult else ())"/>
                    <xsl:if test="fn:exists($var361_cond_result_exists)">
                      <gmd:MD_MaintenanceFrequencyCode>
                        <xsl:attribute name="codeList">
                          <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
                        </xsl:attribute>
                        <xsl:attribute name="codeListValue">
                          <xsl:sequence select="xs:string(($var361_cond_result_exists))"/>
                        </xsl:attribute>
                        <!--<xsl:variable name="var363_result_vmf12_inputtoresult" as="xs:string?">
                          <xsl:call-template name="vmf:vmf12_inputtoresult">
                            <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
                          </xsl:call-template>
                        </xsl:variable>-->
                        <xsl:sequence select="$var361_cond_result_exists"/>
                      </gmd:MD_MaintenanceFrequencyCode>
                    </xsl:if>
                  </gmd:maintenanceAndUpdateFrequency>
                  <gmd:updateScope>
                    <gmd:MD_ScopeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('attribute'))"/>
                      </xsl:attribute>
                    </gmd:MD_ScopeCode>
                  </gmd:updateScope>
                </gmd:MD_MaintenanceInformation>
              </gmd:resourceMaintenance>
            </xsl:for-each>
            <xsl:for-each select="idinfo/browse">
              <gmd:graphicOverview>
                <gmd:MD_BrowseGraphic>
                  <gmd:fileName>
                    <xsl:for-each-group select="." group-by="xs:string(browsen)">
                      <xsl:variable name="var369_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space($var369_cur_result_groupby)"/>
                      </gco:CharacterString>
                    </xsl:for-each-group>
                  </gmd:fileName>
                  <gmd:fileDescription>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(browsed))"/>
                    </gco:CharacterString>
                  </gmd:fileDescription>
                  <gmd:fileType>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(xs:string(browset)))"/>
                    </gco:CharacterString>
                  </gmd:fileType>
                </gmd:MD_BrowseGraphic>
              </gmd:graphicOverview>
            </xsl:for-each>
            <xsl:for-each-group select="idinfo/keywords/theme" group-by="(if (fn:contains(xs:string(xs:string(themekt)), 'ISO 19115')) then () else xs:string(xs:string(themekt)))">
              <xsl:variable name="var372_cur_result_groupby" as="item()+" select="current-group()"/>
              <xsl:variable name="var373_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
              <gmd:descriptiveKeywords>
                <gmd:MD_Keywords>
                  <xsl:for-each select="$var372_cur_result_groupby/themekey">
                    <gmd:keyword>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:keyword>
                  </xsl:for-each>
                  <gmd:type>
                    <gmd:MD_KeywordTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('theme'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'theme'"/>
                    </gmd:MD_KeywordTypeCode>
                  </gmd:type>
                  <gmd:thesaurusName>
                    <!--<xsl:call-template name="CI_Citation"/>-->
                    <gmd:CI_Citation>
                      <gmd:title>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space($var373_cur_result_groupby)"/>
                        </gco:CharacterString>
                      </gmd:title>
                      <gmd:date>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gmd:date>
                    </gmd:CI_Citation>
                  </gmd:thesaurusName>
                </gmd:MD_Keywords>
              </gmd:descriptiveKeywords>
            </xsl:for-each-group>
            <xsl:for-each-group select="idinfo/keywords/place" group-by="xs:string(xs:string(placekt))">
              <xsl:variable name="var378_cur_result_groupby" as="item()+" select="current-group()"/>
              <xsl:variable name="var379_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
              <gmd:descriptiveKeywords>
                <gmd:MD_Keywords>
                  <xsl:for-each select="$var378_cur_result_groupby/placekey">
                    <gmd:keyword>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:keyword>
                  </xsl:for-each>
                  <gmd:type>
                    <gmd:MD_KeywordTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('place'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'place'"/>
                    </gmd:MD_KeywordTypeCode>
                  </gmd:type>
                  <gmd:thesaurusName>
                    <!--<xsl:call-template name="CI_Citation"/>-->
                    <gmd:CI_Citation>
                      <gmd:title>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space($var379_cur_result_groupby)"/>
                        </gco:CharacterString>
                      </gmd:title>
                      <gmd:date>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gmd:date>
                    </gmd:CI_Citation>
                  </gmd:thesaurusName>
                </gmd:MD_Keywords>
              </gmd:descriptiveKeywords>
            </xsl:for-each-group>
            <xsl:for-each-group select="idinfo/keywords/stratum" group-by="xs:string(xs:string(stratkt))">
              <xsl:variable name="var384_cur_result_groupby" as="item()+" select="current-group()"/>
              <xsl:variable name="var385_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
              <gmd:descriptiveKeywords>
                <gmd:MD_Keywords>
                  <xsl:for-each select="$var384_cur_result_groupby/stratkey">
                    <gmd:keyword>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:keyword>
                  </xsl:for-each>
                  <gmd:type>
                    <gmd:MD_KeywordTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('stratum'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'stratum'"/>
                    </gmd:MD_KeywordTypeCode>
                  </gmd:type>
                  <gmd:thesaurusName>
                    <gmd:CI_Citation>
                      <gmd:title>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space($var385_cur_result_groupby)"/>
                        </gco:CharacterString>
                      </gmd:title>
                      <gmd:date>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gmd:date>
                    </gmd:CI_Citation>
                  </gmd:thesaurusName>
                </gmd:MD_Keywords>
              </gmd:descriptiveKeywords>
            </xsl:for-each-group>
            <xsl:for-each-group select="idinfo/keywords/temporal" group-by="xs:string(xs:string(tempkt))">
              <xsl:variable name="var390_cur_result_groupby" as="item()+" select="current-group()"/>
              <xsl:variable name="var391_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
              <gmd:descriptiveKeywords>
                <gmd:MD_Keywords>
                  <xsl:for-each select="$var390_cur_result_groupby/tempkey">
                    <gmd:keyword>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:keyword>
                  </xsl:for-each>
                  <gmd:type>
                    <gmd:MD_KeywordTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('temporal'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'temporal'"/>
                    </gmd:MD_KeywordTypeCode>
                  </gmd:type>
                  <gmd:thesaurusName>
                    <gmd:CI_Citation>
                      <gmd:title>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space($var391_cur_result_groupby)"/>
                        </gco:CharacterString>
                      </gmd:title>
                      <gmd:date>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gmd:date>
                    </gmd:CI_Citation>
                  </gmd:thesaurusName>
                </gmd:MD_Keywords>
              </gmd:descriptiveKeywords>
            </xsl:for-each-group>
            <xsl:for-each select="idinfo/thelayid/layrname">
              <gmd:descriptiveKeywords>
                <gmd:MD_Keywords>
                  <xsl:for-each select="theme/themekey">
                    <gmd:keyword>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:keyword>
                  </xsl:for-each>
                  <gmd:type>
                    <gmd:MD_KeywordTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('theme'))"/>
                      </xsl:attribute>
                    </gmd:MD_KeywordTypeCode>
                  </gmd:type>
                  <gmd:thesaurusName>
                    <gmd:CI_Citation>
                      <gmd:title>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(xs:string(theme/themekt)))"/>
                        </gco:CharacterString>
                      </gmd:title>
                      <gmd:date>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gmd:date>
                    </gmd:CI_Citation>
                  </gmd:thesaurusName>
                </gmd:MD_Keywords>
              </gmd:descriptiveKeywords>
            </xsl:for-each>
            <xsl:variable name="var399_cond_result_exists" as="xs:string?">
              <xsl:choose>
                <xsl:when test="fn:exists(distinfo/distliab)">
                  <xsl:variable name="var404_map_select_distinfo" as="xs:string*">
                    <xsl:for-each select="distinfo">
                      <xsl:sequence select="xs:string(distliab)"/>
                    </xsl:for-each>
                  </xsl:variable>
                  <xsl:if test="fn:exists($var404_map_select_distinfo)">
                    <xsl:sequence select="fn:string-join($var404_map_select_distinfo, ' ')"/>
                  </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:sequence select="' '"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:for-each select="$var399_cond_result_exists">
              <gmd:resourceConstraints>
                <gmd:MD_Constraints>
                  <gmd:useLimitation>
                    <gco:CharacterString>
                      <xsl:value-of select="$var399_cond_result_exists"/>
                    </gco:CharacterString>
                  </gmd:useLimitation>
                </gmd:MD_Constraints>
              </gmd:resourceConstraints>
            </xsl:for-each>
            <xsl:for-each select="idinfo/useconst">
              <gmd:resourceConstraints>
                <gmd:MD_LegalConstraints>
                  <gmd:useConstraints>
                    <gmd:MD_RestrictionCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('otherRestrictions'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'otherRestrictions'"/>
                    </gmd:MD_RestrictionCode>
                  </gmd:useConstraints>
                  <gmd:otherConstraints>
                    <gco:CharacterString>
                      <xsl:sequence select="normalize-space(concat ('Use Constraints: ', //idinfo/useconst))"/>
                    </gco:CharacterString>
                  </gmd:otherConstraints>
                </gmd:MD_LegalConstraints>
              </gmd:resourceConstraints>
            </xsl:for-each>
            <gmd:resourceConstraints>
              <gmd:MD_LegalConstraints>
                <gmd:accessConstraints>
                  <gmd:MD_RestrictionCode>
                    <xsl:attribute name="codeList">
                      <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
                    </xsl:attribute>
                    <xsl:attribute name="codeListValue">
                      <xsl:sequence select="xs:string(('otherRestrictions'))"/>
                    </xsl:attribute>
                    <xsl:sequence select="'otherRestrictions'"/>
                  </gmd:MD_RestrictionCode>
                </gmd:accessConstraints>
                <gmd:otherConstraints>
                  <gco:CharacterString>
                    <xsl:sequence select="normalize-space(concat ('Access Constraints: ', //idinfo/accconst))"/>
                  </gco:CharacterString>
                </gmd:otherConstraints>
              </gmd:MD_LegalConstraints>
            </gmd:resourceConstraints>
            <xsl:for-each select="idinfo/secinfo">
              <gmd:resourceConstraints>
                <gmd:MD_SecurityConstraints>
                  <xsl:if test=".//secclass">
                    <gmd:classification>
                      <xsl:variable name="var412_result_vmf13_inputtoresult" as="xs:string?">
                        <xsl:call-template name="vmf:vmf13_inputtoresult">
                          <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
                        </xsl:call-template>
                      </xsl:variable>
                      <xsl:variable name="var409_cond_result_exists" as="xs:string?" select="(if (fn:exists($var412_result_vmf13_inputtoresult)) then $var412_result_vmf13_inputtoresult else ())"/>
                      <xsl:choose>
                        <xsl:when test="fn:exists($var409_cond_result_exists)">
                          <gmd:MD_ClassificationCode>
                            <xsl:attribute name="codeList">
                              <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
                            </xsl:attribute>
                            <xsl:attribute name="codeListValue">
                              <xsl:sequence select="xs:string($var409_cond_result_exists)"/>
                            </xsl:attribute>
                            <!--<xsl:variable name="var411_result_vmf14_inputtoresult" as="xs:string?">
                              <xsl:call-template name="vmf:vmf14_inputtoresult">
                                <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
                              </xsl:call-template>
                            </xsl:variable>-->
                            <xsl:sequence select="$var409_cond_result_exists"/>
                          </gmd:MD_ClassificationCode>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:comment>Security Classification not mapped to MD_ClassificationCode</xsl:comment>
                          <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                          <xsl:copy-of select=".//secclass"/>
                          <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                        </xsl:otherwise>
                      </xsl:choose>
                    </gmd:classification>
                  </xsl:if>
                  <gmd:classificationSystem>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(secsys))"/>
                    </gco:CharacterString>
                  </gmd:classificationSystem>
                  <gmd:handlingDescription>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(sechandl))"/>
                    </gco:CharacterString>
                  </gmd:handlingDescription>
                </gmd:MD_SecurityConstraints>
              </gmd:resourceConstraints>
            </xsl:for-each>
            <xsl:for-each select="idinfo/citation/citeinfo/lworkcit/citeinfo">
              <!--<xsl:variable name="var413_lworkcit" as="node()" select="."/>-->
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetName>
                    <xsl:call-template name="CI_Citation"/>
                  </gmd:aggregateDataSetName>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode'))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(('largerWorkCitation'))"/>
                      </xsl:attribute>
                      <xsl:sequence select="'largerWorkCitation'"/>
                    </gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <xsl:for-each select="idinfo/crossref/citeinfo">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetName>
                    <xsl:call-template name="CI_Citation"/>
                  </gmd:aggregateDataSetName>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <xsl:for-each select="idinfo/descript/documnts/datdicrf/citeinfo">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetName>
                    <xsl:call-template name="CI_Citation"/>
                  </gmd:aggregateDataSetName>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                  <gmd:initiativeType>
                    <gmd:DS_InitiativeTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_InitiativeTypeCode" codeListValue="dataDictionary">dataDictionary</gmd:DS_InitiativeTypeCode>
                  </gmd:initiativeType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <xsl:for-each select="//scipap/citeinfo">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetName>
                    <xsl:call-template name="CI_Citation"/>
                  </gmd:aggregateDataSetName>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                  <gmd:initiativeType>
                    <gmd:DS_InitiativeTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_InitiativeTypeCode" codeListValue="sciencePaper">sciencePaper</gmd:DS_InitiativeTypeCode>
                  </gmd:initiativeType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <xsl:for-each select="idinfo/descript/documnts/userguid/citeinfo">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetName>
                    <xsl:call-template name="CI_Citation"/>
                  </gmd:aggregateDataSetName>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                  <gmd:initiativeType>
                    <gmd:DS_InitiativeTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_InitiativeTypeCode" codeListValue="userGuide">userGuide</gmd:DS_InitiativeTypeCode>
                  </gmd:initiativeType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <!--MD_AggregateInformation -->
            <xsl:for-each select="//agginfo/conpckid">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetIdentifier>
                    <gmd:MD_Identifier>
                      <gmd:code>
                        <gco:CharacterString>
                          <xsl:value-of select="normalize-space(datsetid)"/>
                        </gco:CharacterString>
                      </gmd:code>
                    </gmd:MD_Identifier>
                  </gmd:aggregateDataSetIdentifier>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="largerWorkCitation">largerWorkCitation</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <xsl:for-each select="//agginfo/compinfo">
              <gmd:aggregationInfo>
                <gmd:MD_AggregateInformation>
                  <gmd:aggregateDataSetIdentifier>
                    <gmd:MD_Identifier>
                      <gmd:code>
                        <gco:CharacterString>
                          <xsl:value-of select="normalize-space(aggmemid/datsetid)"/>
                        </gco:CharacterString>
                      </gmd:code>
                    </gmd:MD_Identifier>
                  </gmd:aggregateDataSetIdentifier>
                  <xsl:if test="aggcrit">
                    <xsl:comment>Aggregration Criteria not mapped from FGDC</xsl:comment>
                    <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                    <xsl:copy-of select="aggcrit"/>
                    <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                  </xsl:if>
                  <gmd:associationType>
                    <gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode" codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
                  </gmd:associationType>
                  <gmd:initiativeType>
                    <gmd:DS_InitiativeTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_InitiativeTypeCode" codeListValue="collection">collection</gmd:DS_InitiativeTypeCode>
                  </gmd:initiativeType>
                </gmd:MD_AggregateInformation>
              </gmd:aggregationInfo>
            </xsl:for-each>
            <!-- spatialRepresentationType -->
            <xsl:for-each select="spdoinfo/direct">
              <gmd:spatialRepresentationType>
                <xsl:variable name="var659_result_vmf15_inputtoresult" as="xs:string?">
                  <xsl:call-template name="vmf:vmf15_inputtoresult">
                    <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
                  </xsl:call-template>
                </xsl:variable>
                <xsl:if test="fn:exists($var659_result_vmf15_inputtoresult)">
                  <gmd:MD_SpatialRepresentationTypeCode>
                    <xsl:attribute name="codeList">
                      <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode'))"/>
                    </xsl:attribute>
                    <xsl:attribute name="codeListValue">
                      <xsl:sequence select="xs:string($var659_result_vmf15_inputtoresult)"/>
                    </xsl:attribute>
                    <xsl:sequence select="$var659_result_vmf15_inputtoresult"/>
                  </gmd:MD_SpatialRepresentationTypeCode>
                </xsl:if>
              </gmd:spatialRepresentationType>
            </xsl:for-each>
            <gmd:language>
              <gco:CharacterString>
                <xsl:sequence select="'eng; USA'"/>
              </gco:CharacterString>
            </gmd:language>
            <xsl:for-each select="idinfo/keywords/theme">
              <!--<xsl:variable name="var661_theme" as="node()" select="."/>-->
              <xsl:for-each select="themekey">
                <xsl:variable name="varTopicCategoryExists">
                  <xsl:if test="normalize-space(../themekt)">
                    <xsl:choose>
                      <xsl:when test="contains(../themekt, 'ISO 19115')">true</xsl:when>
                      <xsl:otherwise>false</xsl:otherwise>
                    </xsl:choose>
                  </xsl:if>
                </xsl:variable>
                <xsl:if test="$varTopicCategoryExists='true'">
                  <xsl:if test="not(number(.))">
                    <gmd:topicCategory>
                    <gmd:MD_TopicCategoryCode>
                      <xsl:choose>
                        <xsl:when test="normalize-space(upper-case(.))='BIOTA'">biota</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='BOUNDARIES'">boundaries</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='CLIMATOLOGYMETEOROLOGYATMOSPHERE'">climatologyMeteorologyAtmosphere</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='ECONOMY'">economy</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='ELEVATION'">elevation</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='ENVIRONMENT'">environment</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='FARMING'">farming</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='GEOSCIENTIFICINFORMATION'">geoscientificInformation</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='HEALTH'">health</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='IMAGERYBASEMAPSEARTHCOVER'">imageryBaseMapsEarthCover</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='INLANDWATERS'">inlandWaters</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='INTELLIGENCEMILITARY'">intelligenceMilitary</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='LOCATION'">location</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='OCEANS'">oceans</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='PLANNINGCADASTRE'">planningCadastre</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='SOCIETY'">society</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='STRUCTURE'">structure</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='TRANSPORTATION'">transportation</xsl:when>
                        <xsl:when test="normalize-space(upper-case(.))='UTILITIESCOMMUNICATION'">utilitiesCommunication</xsl:when>
                        
                        <xsl:otherwise>
                          <xsl:value-of select="normalize-space(.)"/>
                        </xsl:otherwise>
                      </xsl:choose>
                    </gmd:MD_TopicCategoryCode>
                  </gmd:topicCategory></xsl:if>
                </xsl:if>
              </xsl:for-each>
            </xsl:for-each>
            <xsl:for-each select="//idinfo/native">
              <xsl:variable name="var668_native" as="node()" select="."/>
              <gmd:environmentDescription>
                <xsl:variable name="var670_cond_result_exists" as="xs:string?">
                  <xsl:choose>
                    <xsl:when test="fn:exists($var201_metadata/distinfo/techpreq)">
                      <xsl:variable name="var675_map_select_distinfo" as="xs:string*">
                        <xsl:for-each select="$var201_metadata/distinfo/techpreq">
                          <xsl:sequence select="xs:string(.)"/>
                        </xsl:for-each>
                      </xsl:variable>
                      <xsl:if test="fn:exists($var675_map_select_distinfo)">
                        <xsl:sequence select="fn:string-join($var675_map_select_distinfo, ' ')"/>
                      </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="' '"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:for-each select="$var670_cond_result_exists">
                  <gco:CharacterString>
                    <xsl:variable name="var673_cond_result_exists" as="xs:string" select="(if (fn:exists($var201_metadata/distinfo/techpreq)) then ' Technical Prerequisites: ' else ' ')"/>
                    <xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat('Native Dataset Environment: ', xs:string($var668_native)), $var673_cond_result_exists), .)))"/>
                  </gco:CharacterString>
                </xsl:for-each>
              </gmd:environmentDescription>
            </xsl:for-each>
            <gmd:extent>
              <gmd:EX_Extent>
                <xsl:attribute name="id">
                  <xsl:sequence select="'boundingExtent'"/>
                </xsl:attribute>
                <xsl:for-each select="idinfo/spdom/frarea">
                  <gmd:description>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Frame Area: ', xs:string(xs:double(frareavl))), ' Frame Area Units: '), xs:string(xs:string(frareaun))))"/>
                    </gco:CharacterString>
                  </gmd:description>
                </xsl:for-each>
                <xsl:for-each select="idinfo/spdom/dsgpoly">
                  <xsl:variable name="var680_dsgpoly" as="node()" select="."/>
                  <gmd:geographicElement>
                    <gmd:EX_BoundingPolygon>
                      <gmd:polygon>
                        <gml:Polygon>
                          <xsl:attribute name="gml:id">
                            <xsl:sequence select="'boundingPolygon'"/>
                          </xsl:attribute>
                          <gml:interior>
                            <gml:LinearRing>
                              <gml:coordinates>
                                <xsl:variable name="var685_map_select_grngpoin" as="xs:string*">
                                  <xsl:for-each select="dsgpolyo/grngpoin">
                                    <xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
                                  </xsl:for-each>
                                </xsl:variable>
                                <xsl:variable name="var682_cond_result_exists" as="xs:string*">
                                  <xsl:choose>
                                    <xsl:when test="fn:exists($var685_map_select_grngpoin)">
                                      <xsl:for-each select="dsgpolyo/grngpoin">
                                        <xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
                                      </xsl:for-each>
                                    </xsl:when>
                                    <xsl:otherwise>
                                      <xsl:for-each select="dsgpolyo/gring">
                                        <xsl:sequence select="xs:string(.)"/>
                                      </xsl:for-each>
                                    </xsl:otherwise>
                                  </xsl:choose>
                                </xsl:variable>
                                <xsl:for-each select="$var682_cond_result_exists">
                                  <xsl:attribute name="decimal">
                                    <xsl:sequence select="fn:normalize-space(.)"/>
                                  </xsl:attribute>
                                </xsl:for-each>
                              </gml:coordinates>
                            </gml:LinearRing>
                          </gml:interior>
                        </gml:Polygon>
                      </gmd:polygon>
                    </gmd:EX_BoundingPolygon>
                  </gmd:geographicElement>
                </xsl:for-each>
                <xsl:if test="idinfo/spdom">
                  <gmd:geographicElement>
                    <gmd:EX_GeographicBoundingBox>
                      <xsl:attribute name="id">
                        <xsl:sequence select="'boundingGeographicBoundingBox'"/>
                      </xsl:attribute>
                      <gmd:westBoundLongitude>
                        <gco:Decimal>
                          <xsl:sequence select="xs:string((idinfo/spdom/bounding/westbc))"/>
                        </gco:Decimal>
                      </gmd:westBoundLongitude>
                      <gmd:eastBoundLongitude>
                        <gco:Decimal>
                          <xsl:sequence select="xs:string((idinfo/spdom/bounding/eastbc))"/>
                        </gco:Decimal>
                      </gmd:eastBoundLongitude>
                      <gmd:southBoundLatitude>
                        <gco:Decimal>
                          <xsl:sequence select="xs:string((idinfo/spdom/bounding/southbc))"/>
                        </gco:Decimal>
                      </gmd:southBoundLatitude>
                      <gmd:northBoundLatitude>
                        <gco:Decimal>
                          <xsl:sequence select="xs:string((idinfo/spdom/bounding/northbc))"/>
                        </gco:Decimal>
                      </gmd:northBoundLatitude>
                    </gmd:EX_GeographicBoundingBox>
                  </gmd:geographicElement>
                </xsl:if>
                <!-- sngdate -->
                <xsl:for-each select="idinfo/timeperd/timeinfo/sngdate">
                  <gmd:temporalElement>
                    <gmd:EX_TemporalExtent>
                      <xsl:choose>
                        <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown'))">
                          <gmd:extent gco:nilReason="unknown"/>
                        </xsl:when>
                        <xsl:when test="contains(lower-case(normalize-space(./time)), 'unknown')">
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:when>
                        <xsl:when test="./time">
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                  <xsl:with-param name="timeField" select="normalize-space(./time)"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:otherwise>
                      </xsl:choose>
                    </gmd:EX_TemporalExtent>
                  </gmd:temporalElement>
                </xsl:for-each>
                <!-- multiple single dates -->
                <xsl:for-each select="idinfo/timeperd/timeinfo/mdattim/sngdate">
                  <gmd:temporalElement>
                    <gmd:EX_TemporalExtent>
                      <xsl:choose>
                        <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown'))">
                          <gmd:extent gco:nilReason="unknown"/>
                        </xsl:when>
                        <xsl:when test="contains(lower-case(normalize-space(./time)), 'unknown')">
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="caldate"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:when>
                        <xsl:when test="./time">
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="caldate"/>
                                  <xsl:with-param name="timeField" select="time"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmd:extent>
                            <gml:TimeInstant>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:timePosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="caldate"/>
                                </xsl:call-template>
                              </gml:timePosition>
                            </gml:TimeInstant>
                          </gmd:extent>
                        </xsl:otherwise>
                      </xsl:choose>
                    </gmd:EX_TemporalExtent>
                  </gmd:temporalElement>
                </xsl:for-each>
                <!-- date range -->
                <!-- idinfo/timeperd/timeinfo/rngdates to EX_TemporalExtent/gml:TimePeriod-->
                <xsl:for-each select="idinfo/timeperd/timeinfo/rngdates">
                  <gmd:temporalElement>
                    <gmd:EX_TemporalExtent>
                      <xsl:attribute name="id">
                        <xsl:sequence select="'boundingTemporalExtent'"/>
                      </xsl:attribute>
                      <gmd:extent>
                        <gml:TimePeriod>
                          <xsl:attribute name="gml:id">
                            <xsl:value-of select="generate-id()"/>
                          </xsl:attribute>
                          <xsl:choose>
                            <xsl:when test="contains(lower-case(normalize-space(begdate)), 'unknown')">
                              <gml:beginPosition indeterminatePosition="unknown"/>
                            </xsl:when>
                            <xsl:when test="contains(lower-case(normalize-space(./begtime)), 'unknown')">
                              <gml:beginPosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(./begdate)"/>
                                </xsl:call-template>
                              </gml:beginPosition>
                            </xsl:when>
                            <xsl:when test="./begtime">
                              <gml:beginPosition>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="normalize-space(./begdate)"/>
                                  <xsl:with-param name="timeField" select="normalize-space(./begtime)"/>
                                </xsl:call-template>
                              </gml:beginPosition>
                            </xsl:when>
                            <xsl:otherwise>
                              <gml:beginPosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(begdate)"/>
                                </xsl:call-template>
                              </gml:beginPosition>
                            </xsl:otherwise>
                          </xsl:choose>
                          <xsl:choose>
                            <xsl:when test="contains(lower-case(normalize-space(enddate)), 'unknown')">
                              <gml:endPosition indeterminatePosition="unknown"/>
                            </xsl:when>
                            <xsl:when test="contains(lower-case(normalize-space(enddate)), 'present')">
                              <gml:endPosition indeterminatePosition="now"/>
                            </xsl:when>
                            <xsl:when test="contains(lower-case(normalize-space(./endtime)), 'unknown')">
                              <gml:endPosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                </xsl:call-template>
                              </gml:endPosition>
                            </xsl:when>
                            <xsl:when test="(./endtime)">
                              <gml:endPosition>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                  <xsl:with-param name="timeField" select="normalize-space(./endtime)"/>
                                </xsl:call-template>
                              </gml:endPosition>
                            </xsl:when>
                            <xsl:otherwise>
                              <gml:endPosition>
                                <xsl:call-template name="fgdc2isoDate">
                                  <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                </xsl:call-template>
                              </gml:endPosition>
                            </xsl:otherwise>
                          </xsl:choose>
                        </gml:TimePeriod>
                      </gmd:extent>
                    </gmd:EX_TemporalExtent>
                  </gmd:temporalElement>
                </xsl:for-each>
              </gmd:EX_Extent>
            </gmd:extent>
            <xsl:if test="//supplinf">
              <gmd:supplementalInformation>
                <gco:CharacterString>
                  <xsl:sequence select="normalize-space(idinfo/descript/supplinf)"/>
                </gco:CharacterString>
              </gmd:supplementalInformation>
            </xsl:if>
          </gmd:MD_DataIdentification>
        </gmd:identificationInfo>
      </xsl:for-each>
      <xsl:for-each select="//bandidnt">
        <gmd:contentInfo>
          <xsl:comment>translated from //idinfo/bandidnt to MI_CoverageDescription</xsl:comment>
          <gmi:MI_CoverageDescription>
            <xsl:if test="numbands">
              <xsl:comment>FGDC content not mapped to ISO. From Xpath: //idinfo/bandidnt/numbands</xsl:comment>
              <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
              <xsl:copy-of select="./numbands"/>
              <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
            </xsl:if>
            <gmd:attributeDescription>
              <xsl:variable name="var1250_cond_result_exists" as="xs:string?" select="(if (fn:exists(inbident/bandid)) then 'Individual Band Identification' else ())"/>
              <xsl:if test="fn:exists($var1250_cond_result_exists)">
                <gco:RecordType>
                  <xsl:sequence select="$var1250_cond_result_exists"/>
                </gco:RecordType>
              </xsl:if>
            </gmd:attributeDescription>
            <gmd:contentType>
              <gmd:MD_CoverageContentTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MD_CoverageContentTypeCode" codeListValue="image">image</gmd:MD_CoverageContentTypeCode>
            </gmd:contentType>
            <xsl:for-each select="inbident">
              <gmd:dimension>
                <gmd:MD_Band>
                  <gmd:sequenceIdentifier>
                    <gco:MemberName>
                      <gco:aName>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(bandid))"/>
                        </gco:CharacterString>
                      </gco:aName>
                      <gco:attributeType>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                        </xsl:attribute>
                      </gco:attributeType>
                    </gco:MemberName>
                  </gmd:sequenceIdentifier>
                  <gmd:descriptor>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(bmmodid))"/>
                    </gco:CharacterString>
                  </gmd:descriptor>
                </gmd:MD_Band>
              </gmd:dimension>
            </xsl:for-each>
          </gmi:MI_CoverageDescription>
        </gmd:contentInfo>
      </xsl:for-each>
      <xsl:for-each select="//eainfo/detailed">
        <gmd:contentInfo>
          <gmi:MI_CoverageDescription>
            <gmd:attributeDescription>
              <gco:RecordType>
                <xsl:value-of select="normalize-space(./enttyp/enttypl)"/>
                <xsl:text>: </xsl:text>
                <xsl:value-of select="normalize-space(./enttyp/enttypd)"/>
              </gco:RecordType>
            </gmd:attributeDescription>
            <xsl:comment>Entity Type Definition Source not translated: <xsl:value-of select="./enttyp/enttypds"/></xsl:comment>
            <gmd:contentType gco:nilReason="unknown"/>
            <xsl:for-each select="attr/attrdomv/rdom">
              <gmd:dimension>
                <gmd:MD_Band>
                  <gmd:sequenceIdentifier>
                    <gco:MemberName>
                      <gco:aName>
                        <gco:CharacterString>
                          <xsl:value-of select="normalize-space(../../attrlabl)"/>
                        </gco:CharacterString>
                      </gco:aName>
                      <gco:attributeType gco:nilReason="unknown"/>
                    </gco:MemberName>
                  </gmd:sequenceIdentifier>
                  <gmd:descriptor>
                    <gco:CharacterString>
                      <xsl:value-of select="normalize-space(../../attrdef)"/>
                    </gco:CharacterString>
                  </gmd:descriptor>
                  <xsl:comment>Attribute Definition Source not translated: <xsl:value-of select="../../attrdefs"/></xsl:comment>
                  <gmd:maxValue>
                    <xsl:choose>
                      <xsl:when test="string(rdommax) castable as xs:integer">
                        <gco:Real>
                          <xsl:value-of select="normalize-space(rdommax)"/>
                        </gco:Real>
                      </xsl:when>
                      <xsl:when test="string(rdommax) castable as xs:decimal">
                        <gco:Real>
                          <xsl:value-of select="normalize-space(rdommax)"/>
                        </gco:Real>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:attribute name="gco:nilReason" select="'unknown'"/>
                      </xsl:otherwise>
                    </xsl:choose>
                  </gmd:maxValue>
                  <gmd:minValue>
                    <xsl:choose>
                      <xsl:when test="string(rdommin) castable as xs:integer">
                        <gco:Real>
                          <xsl:value-of select="normalize-space(rdommin)"/>
                        </gco:Real>
                      </xsl:when>
                      <xsl:when test="string(rdommin) castable as xs:decimal">
                        <gco:Real>
                          <xsl:value-of select="normalize-space(rdommin)"/>
                        </gco:Real>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:attribute name="gco:nilReason" select="'unknown'"/>
                      </xsl:otherwise>
                    </xsl:choose>
                  </gmd:minValue>
                  <xsl:choose>
                    <xsl:when test="attrunit">
                      <gmd:units>
                        <gml:UnitDefinition>
                          <xsl:attribute name="gml:id">
                            <xsl:value-of select="generate-id()"/>
                          </xsl:attribute>
                          <gml:identifier codeSpace="local">
                            <xsl:value-of select="normalize-space(./attrunit)"/>
                          </gml:identifier>
                          <gml:name>
                            <xsl:value-of select="normalize-space(./attrunit)"/>
                          </gml:name>
                        </gml:UnitDefinition>
                      </gmd:units>
                    </xsl:when>
                    <xsl:otherwise>
                      <gmd:units gco:nilReason="missing"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </gmd:MD_Band>
              </gmd:dimension>
            </xsl:for-each>
            <xsl:for-each select="./attr">
              <xsl:if test="./attrdomv/edom">
                <gmi:rangeElementDescription>
                  <gmi:MI_RangeElementDescription>
                    <gmi:name>
                      <gco:CharacterString>
                        <xsl:for-each select="attrlabl">
                          <xsl:value-of select="normalize-space(.)" separator="; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:name>
                    <gmi:definition>
                      <gco:CharacterString>
                        <xsl:for-each select="attrdef">
                          <xsl:value-of select="normalize-space(.)" separator="; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:definition>
                    <xsl:comment>Attribute Definition Source not translated: <xsl:value-of select="normalize-space(attrdefs)"/></xsl:comment>
                    <xsl:for-each select="./attrdomv/edom">
                      <gmi:rangeElement>
                        <gco:Record>
                          <xsl:for-each select="edomv">
                            <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                          </xsl:for-each>
                          <xsl:text> | </xsl:text>
                          <xsl:for-each select="edomvd">
                            <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                          </xsl:for-each>
                        </gco:Record>
                      </gmi:rangeElement>
                    </xsl:for-each>
                  </gmi:MI_RangeElementDescription>
                </gmi:rangeElementDescription>
              </xsl:if>
              <xsl:if test="./attrdomv/udom">
                <gmi:rangeElementDescription>
                  <gmi:MI_RangeElementDescription>
                    <gmi:name>
                      <gco:CharacterString>
                        <xsl:for-each select="./attrlabl">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:name>
                    <gmi:definition>
                      <gco:CharacterString>
                        <xsl:for-each select="./attrdef">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:definition>
                    <xsl:comment>Attribute Definition Source not translated: <xsl:value-of select="normalize-space(attrdefs)"/></xsl:comment>
                    <gmi:rangeElement>
                      <gco:Record>
                        <xsl:for-each select="./attrdomv/udom">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:Record>
                    </gmi:rangeElement>
                  </gmi:MI_RangeElementDescription>
                </gmi:rangeElementDescription>
              </xsl:if>
              <xsl:if test="attrdomv/codesetd">
                <gmi:rangeElementDescription>
                  <gmi:MI_RangeElementDescription>
                    <gmi:name>
                      <gco:CharacterString>
                        <xsl:for-each select="./attrlabl">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:name>
                    <gmi:definition>
                      <gco:CharacterString>
                        <xsl:for-each select="./attrdef">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:CharacterString>
                    </gmi:definition>
                    <xsl:comment>Attribute Definition Source not translated: <xsl:value-of select="normalize-space(attrdefs)"/></xsl:comment>
                    <gmi:rangeElement>
                      <gco:Record>
                        <xsl:for-each select="./attrdomv/codesetd/codesetn">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                        <xsl:text> | </xsl:text>
                        <xsl:for-each select="./attrdomv/codesetd/codesets">
                          <xsl:value-of select="normalize-space(.)" separator="' ; "/>
                        </xsl:for-each>
                      </gco:Record>
                    </gmi:rangeElement>
                  </gmi:MI_RangeElementDescription>
                </gmi:rangeElementDescription>
              </xsl:if>
            </xsl:for-each>
          </gmi:MI_CoverageDescription>
        </gmd:contentInfo>
      </xsl:for-each>
      <xsl:for-each select="//eainfo/overview">
        <gmd:contentInfo>
          <gmd:MD_FeatureCatalogueDescription>
            <gmd:includedWithDataset gco:nilReason="missing"/>
            <gmd:featureCatalogueCitation>
              <gmd:CI_Citation>
                <gmd:title>
                  <gco:CharacterString>Entity and Attribute Overview: <xsl:value-of select="normalize-space(eaover)"/></gco:CharacterString>
                </gmd:title>
                <gmd:date gco:nilReason="inapplicable"/>
                <gmd:otherCitationDetails>
                  <gco:CharacterString>
                    <xsl:for-each select="eadetcit">Entity and Attribute Detail Citation: <xsl:value-of select="normalize-space(.)" separator="; "/></xsl:for-each>
                  </gco:CharacterString>
                </gmd:otherCitationDetails>
              </gmd:CI_Citation>
            </gmd:featureCatalogueCitation>
          </gmd:MD_FeatureCatalogueDescription>
        </gmd:contentInfo>
      </xsl:for-each>
      <xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var1188_metadata" as="node()" select="."/>
        <xsl:for-each select="dataqual/cloud">
          <gmd:contentInfo>
            <xsl:comment>translated from dataqual/cloud to MD_ImageDescription</xsl:comment>
            <gmd:MD_ImageDescription>
              <gmd:attributeDescription gco:nilReason="inapplicable"/>
              <gmd:contentType gco:nilReason="inapplicable"/>
              <gmd:cloudCoverPercentage>
                <xsl:if test="fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown')">
                  <xsl:attribute name="gco:nilReason">
                    <xsl:value-of select="'unknown'"/>
                  </xsl:attribute>
                </xsl:if>
                <xsl:if test="not(fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown'))">
                  <gco:Real>
                    <xsl:sequence select="xs:string((xs:string(.)))"/>
                  </gco:Real>
                </xsl:if>
              </gmd:cloudCoverPercentage>
            </gmd:MD_ImageDescription>
          </gmd:contentInfo>
        </xsl:for-each>
        <xsl:for-each select="$var1188_metadata/idinfo/proclevl">
          <xsl:variable name="var1192_proclevl" as="node()" select="."/>
          <gmd:contentInfo>
            <gmd:MD_ImageDescription>
              <gmd:attributeDescription gco:nilReason="inapplicable"/>
              <gmd:contentType gco:nilReason="inapplicable"/>
              <gmd:processingLevelCode>
                <gmd:MD_Identifier>
                  <xsl:for-each select="prolevau/citeinfo">
                    <gmd:authority>
                      <xsl:call-template name="CI_Citation"/>
                    </gmd:authority>
                  </xsl:for-each>
                  <gmd:code>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(prolevid))"/>
                    </gco:CharacterString>
                  </gmd:code>
                </gmd:MD_Identifier>
              </gmd:processingLevelCode>
            </gmd:MD_ImageDescription>
          </gmd:contentInfo>
        </xsl:for-each>
      </xsl:for-each>
      <!-- MD_Distribution -->
      <xsl:if test="//distinfo">
        <gmd:distributionInfo>
          <gmd:MD_Distribution>
            <xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform">
              <xsl:variable name="var1253_digform" as="node()" select="."/>
              <!-- distributionFormat -->
              <gmd:distributionFormat>
                <gmd:MD_Format>
                  <gmd:name>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(digtinfo/formname)"/>
                    </gco:CharacterString>
                  </gmd:name>
                  <gmd:version>
                    <xsl:choose>
                      <!-- formverd added by ted.habermann@noaa.gov 2012-04-28 -->
                      <xsl:when test="./digtinfo/formvern or ./digtinfo/formverd">
                        <gco:CharacterString>
                          <xsl:value-of select="normalize-space(concat(./digtinfo/formvern,' ',./digtinfo/formverd))"/>
                        </gco:CharacterString>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:attribute name="gco:nilReason">
                          <xsl:sequence select="'unknown'"/>
                        </xsl:attribute>
                      </xsl:otherwise>
                    </xsl:choose>
                  </gmd:version>
                  <xsl:for-each select="digtinfo/formspec">
                    <gmd:specification>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:specification>
                  </xsl:for-each>
                  <xsl:for-each select="digtinfo/filedec">
                    <gmd:fileDecompressionTechnique>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
                      </gco:CharacterString>
                    </gmd:fileDecompressionTechnique>
                  </xsl:for-each>
                </gmd:MD_Format>
              </gmd:distributionFormat>
            </xsl:for-each>
            <xsl:for-each select="$var1_instance/metadata/distinfo">
              <xsl:variable name="var1276_distinfo" as="node()" select="."/>
              <!-- distributor -->
              <gmd:distributor>
                <gmd:MD_Distributor>
                  <gmd:distributorContact>
                    <xsl:call-template name="CI_ResponsibleParty">
                      <xsl:with-param name="role">distributor</xsl:with-param>
                    </xsl:call-template>
                  </gmd:distributorContact>
                  <xsl:for-each select="stdorder">
                    <xsl:variable name="var1322_stdorder" as="node()" select="."/>
                    <gmd:distributionOrderProcess>
                      <gmd:MD_StandardOrderProcess>
                        <xsl:if test=".//resdesc">
                          <xsl:comment>FGDC content not mapped to ISO. From Xpath: //distinfo/stdorder/resdesc</xsl:comment>
                          <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                          <xsl:copy-of select="./resdesc"/>
                          <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                        </xsl:if>
                        <gmd:fees>
                          <gco:CharacterString>
                            <xsl:sequence select="fn:normalize-space(xs:string(fees))"/>
                          </gco:CharacterString>
                        </gmd:fees>
                        <xsl:for-each select="//distinfo/availabl">
                          <!-- time period -->
                          <gmd:plannedAvailableDateTime>
                            <xsl:choose>
                              <!-- sngDate -->
                              <xsl:when test=".//sngdate">
                                <xsl:choose>
                                  <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(timeinfo/sngdate/caldate))), 'unknown'))">
                                    <xsl:attribute name="gco:nilReason">
                                      <xsl:sequence select="xs:string('unknown')"/>
                                    </xsl:attribute>
                                  </xsl:when>
                                  <xsl:when test="contains(lower-case(normalize-space(timeinfo/sngdate/time)), 'unknown')">
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/sngdate/caldate)"/>
                                        <xsl:with-param name="timeField" select="'00:00:00'"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                  </xsl:when>
                                  <xsl:when test="normalize-space(timeinfo/sngdate/time)">
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/sngdate/caldate)"/>
                                        <xsl:with-param name="timeField" select="normalize-space(timeinfo/sngdate/time)"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                  </xsl:when>
                                  <xsl:otherwise>
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/sngdate/caldate)"/>
                                        <xsl:with-param name="timeField" select="'00:00:00'"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                  </xsl:otherwise>
                                </xsl:choose>
                              </xsl:when>
                              <xsl:when test=".//rngdates">
                                <xsl:choose>
                                  <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(timeinfo/rngdates/begdate))), 'unknown'))">
                                    <xsl:attribute name="gco:nilReason">
                                      <xsl:sequence select="xs:string('unknown')"/>
                                    </xsl:attribute>
                                  </xsl:when>
                                  <xsl:when test="contains(lower-case(normalize-space(timeinfo/rngdates/begtime)), 'unknown')">
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/rngdates/begdate)"/>
                                        <xsl:with-param name="timeField" select="'00:00:00'"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                  </xsl:when>
                                  <xsl:when test="normalize-space(timeinfo/rngdates/begtime)">
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/rngdates/begdate)"/>
                                        <xsl:with-param name="timeField" select="normalize-space(timeinfo/rngdates/begtime)"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                  </xsl:when>
                                  <xsl:otherwise>
                                    <gco:DateTime>
                                      <xsl:call-template name="fgdc2isoDateTime">
                                        <xsl:with-param name="dateField" select="normalize-space(timeinfo/rngdates/begdate)"/>
                                        <xsl:with-param name="timeField" select="'00:00:00'"/>
                                      </xsl:call-template>
                                    </gco:DateTime>
                                    <xsl:comment>FGDC content not mapped to ISO. From Xpath: //distinfo/availabl/timeinfo/rngdates/enddate</xsl:comment>
                                    <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                                    <xsl:copy-of select=".//timeinfo/rngdates/enddate"/>
                                    <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                                  </xsl:otherwise>
                                </xsl:choose>
                              </xsl:when>
                            </xsl:choose>
                          </gmd:plannedAvailableDateTime>
                        </xsl:for-each>
                        <xsl:for-each select="ordering">
                          <xsl:variable name="var1705_ordering" as="node()" select="."/>
                          <gmd:orderingInstructions>
                            <xsl:variable name="var1707_cond_result_exists" as="xs:string?">
                              <xsl:choose>
                                <xsl:when test="fn:exists($var1322_stdorder/digform/digtopt/onlinopt/accinstr)">
                                  <xsl:variable name="var1722_map_select_digform" as="xs:string*">
                                    <xsl:for-each select="$var1322_stdorder/digform/digtopt/onlinopt/accinstr">
                                      <xsl:sequence select="xs:string(.)"/>
                                    </xsl:for-each>
                                  </xsl:variable>
                                  <xsl:if test="fn:exists($var1722_map_select_digform)">
                                    <xsl:sequence select="fn:string-join($var1722_map_select_digform, ' ')"/>
                                  </xsl:if>
                                </xsl:when>
                                <xsl:otherwise>
                                  <xsl:sequence select="' '"/>
                                </xsl:otherwise>
                              </xsl:choose>
                            </xsl:variable>
                            <xsl:for-each select="$var1707_cond_result_exists">
                              <xsl:variable name="var1710_cond_result_exists" as="xs:string?">
                                <xsl:choose>
                                  <xsl:when test="$var1322_stdorder/nondig">
                                    <xsl:for-each select="$var1322_stdorder/nondig">
                                      <xsl:sequence select="xs:string(.)"/>
                                    </xsl:for-each>
                                  </xsl:when>
                                  <xsl:otherwise>
                                    <xsl:sequence select="' '"/>
                                  </xsl:otherwise>
                                </xsl:choose>
                              </xsl:variable>
                              <xsl:if test="fn:exists($var1710_cond_result_exists)">
                                <xsl:variable name="var1711_cond_result_exists" as="xs:string?">
                                  <xsl:choose>
                                    <xsl:when test="$var1276_distinfo/custom">
                                      <xsl:for-each select="$var1276_distinfo/custom">
                                        <xsl:sequence select="xs:string(.)"/>
                                      </xsl:for-each>
                                    </xsl:when>
                                    <xsl:otherwise>
                                      <xsl:sequence select="' '"/>
                                    </xsl:otherwise>
                                  </xsl:choose>
                                </xsl:variable>
                                <xsl:if test="fn:exists($var1711_cond_result_exists)">
                                  <gco:CharacterString>
                                    <xsl:variable name="var1712_cond_result_exists" as="xs:string" select="(if (fn:exists($var1322_stdorder/digform/digtopt/onlinopt/accinstr)) then 'Access Instructions: ' else ' ')"/>
                                    <xsl:variable name="var1713_cond_result_exists" as="xs:string" select="(if (fn:exists($var1322_stdorder/nondig)) then 'Non-Digital Form: ' else ' ')"/>
                                    <xsl:variable name="var1714_cond_result_exists" as="xs:string" select="(if (fn:exists($var1276_distinfo/custom)) then ' Custom Order Process: ' else ' ')"/>
                                    <xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat($var1712_cond_result_exists, .), $var1713_cond_result_exists), ' '), $var1710_cond_result_exists), ' '), 'Ordering Instructions: '), ' '), xs:string($var1705_ordering)), $var1714_cond_result_exists), $var1711_cond_result_exists)))"/>
                                  </gco:CharacterString>
                                </xsl:if>
                              </xsl:if>
                            </xsl:for-each>
                          </gmd:orderingInstructions>
                        </xsl:for-each>
                        <xsl:for-each select="turnarnd">
                          <gmd:turnaround>
                            <gco:CharacterString>
                              <xsl:sequence select="fn:normalize-space(fn:normalize-space(xs:string(.)))"/>
                            </gco:CharacterString>
                          </gmd:turnaround>
                        </xsl:for-each>
                      </gmd:MD_StandardOrderProcess>
                    </gmd:distributionOrderProcess>
                  </xsl:for-each>
                </gmd:MD_Distributor>
              </gmd:distributor>
            </xsl:for-each>
            <xsl:if test="//stdorder//onlinopt">
              <!-- transferOptions -->
              <gmd:transferOptions>
                <gmd:MD_DigitalTransferOptions>
                  <xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/transize">
                    <gmd:transferSize>
                      <gco:Real>
                        <xsl:choose>
                          <!-- Ted Habermann added tests for units on transferSize -->
                          <xsl:when test="contains(.,'MB')">
                            <xsl:value-of select="normalize-space(substring-before(.,'MB'))"/>
                          </xsl:when>
                          <xsl:when test="contains(.,'mb')">
                            <xsl:value-of select="normalize-space(substring-before(.,'mb'))"/>
                          </xsl:when>
                          <xsl:when test="contains(.,'KB')">
                            <xsl:value-of select="xs:double(normalize-space(substring-before(.,'KB'))) div xs:double(1000.0)"/>
                          </xsl:when>
                          <xsl:when test="contains(.,'kb')">
                            <xsl:value-of select="xs:double(normalize-space(substring-before(.,'KB'))) div xs:double(1000.0)"/>
                          </xsl:when>
                          <xsl:otherwise>
                            <xsl:sequence select="xs:string(.)"/>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gco:Real>
                    </gmd:transferSize>
                  </xsl:for-each>
                  <xsl:for-each select="//networka/CI_OnlineResource">
                    <gmd:onLine>
                      <xsl:call-template name="CI_OnlineResource">
                        <xsl:with-param name="source" select="'CI_OnlineResource'"/>
                      </xsl:call-template>
                    </gmd:onLine>
                  </xsl:for-each>
                  <xsl:for-each select="//networka/networkr">
                    <gmd:onLine>
                      <xsl:call-template name="CI_OnlineResource">
                        <xsl:with-param name="source" select="'networkr'"/>
                      </xsl:call-template>
                    </gmd:onLine>
                  </xsl:for-each>
                  <!--<xsl:variable name="networkr" as="xs:string*">
                    <xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
                      <xsl:sequence select="xs:string(.)"/>
                    </xsl:for-each>
                  </xsl:variable>-->
                  <!--<xsl:for-each select="fn:distinct-values($networkr)">
                    <gmd:onLine>
                      <gmd:CI_OnlineResource>
                        <gmd:linkage>
                          <gmd:URL>
                            <xsl:sequence select="xs:string(fn:normalize-space(.))"/>
                          </gmd:URL>
                        </gmd:linkage>
                        <xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/oncomp">
                          <gmd:description>
                            <gco:CharacterString>
                              <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                            </gco:CharacterString>
                          </gmd:description>
                        </xsl:for-each>
                      </gmd:CI_OnlineResource>
                    </gmd:onLine>
                  </xsl:for-each>-->
                  <!--<xsl:for-each select="$var1_instance/metadata/idinfo/citation/citeinfo/onlink">
                    <xsl:comment>URL mapped from fgdc xpath: //idinfo/citation/citeinfo/onlink</xsl:comment>
                    <gmd:onLine>
                      <gmd:CI_OnlineResource>
                        <gmd:linkage>
                          <xsl:for-each select="fn:distinct-values(xs:string(.))">
                            <gmd:URL>
                              <xsl:sequence select="xs:string(fn:normalize-space(.))"/>
                            </gmd:URL>
                          </xsl:for-each>
                        </gmd:linkage>
                      </gmd:CI_OnlineResource>
                    </gmd:onLine>
                  </xsl:for-each>-->
                </gmd:MD_DigitalTransferOptions>
              </gmd:transferOptions>
            </xsl:if>
            <xsl:for-each-group select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/offoptn" group-by="xs:string(xs:string(offmedia))">
              <xsl:variable name="var1741_cur_result_groupby" as="item()+" select="current-group()"/>
              <!-- transferOptions -->
              <gmd:transferOptions>
                <gmd:MD_DigitalTransferOptions>
                  <gmd:offLine>
                    <gmd:MD_Medium>
                      <gmd:name>
                        <xsl:variable name="var1781_map_result_groupitems" as="xs:string+">
                          <xsl:for-each select="$var1741_cur_result_groupby">
                            <xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
                          </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="var1780_map_result_distinctvalues" as="xs:string*">
                          <xsl:for-each select="fn:distinct-values($var1781_map_result_groupitems)">
                            <xsl:variable name="var1784_result_vmf17_inputtoresult" as="xs:string?">
                              <xsl:call-template name="vmf:vmf17_inputtoresult">
                                <xsl:with-param name="input" select="fn:upper-case(.)"/>
                              </xsl:call-template>
                            </xsl:variable>
                            <xsl:if test="fn:exists($var1784_result_vmf17_inputtoresult)">
                              <xsl:sequence select="$var1784_result_vmf17_inputtoresult"/>
                            </xsl:if>
                          </xsl:for-each>
                        </xsl:variable>
                        <xsl:variable name="var1771_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1780_map_result_distinctvalues)) then fn:string-join($var1780_map_result_distinctvalues, ' ') else ())"/>
                        <xsl:variable name="var1744_cond_result_exists" as="xs:string?">
                          <xsl:if test="$var1771_cond_result_exists">
                            <xsl:variable name="var1774_map_result_groupitems" as="xs:string+">
                              <xsl:for-each select="$var1741_cur_result_groupby">
                                <xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
                              </xsl:for-each>
                            </xsl:variable>
                            <xsl:variable name="var1773_map_result_distinctvalues" as="xs:string*">
                              <xsl:for-each select="fn:distinct-values($var1774_map_result_groupitems)">
                                <xsl:variable name="var1777_result_vmf17_inputtoresult" as="xs:string?">
                                  <xsl:call-template name="vmf:vmf17_inputtoresult">
                                    <xsl:with-param name="input" select="fn:upper-case(.)"/>
                                  </xsl:call-template>
                                </xsl:variable>
                                <xsl:if test="fn:exists($var1777_result_vmf17_inputtoresult)">
                                  <xsl:sequence select="$var1777_result_vmf17_inputtoresult"/>
                                </xsl:if>
                              </xsl:for-each>
                            </xsl:variable>
                            <xsl:if test="fn:exists($var1773_map_result_distinctvalues)">
                              <xsl:sequence select="fn:string-join($var1773_map_result_distinctvalues, ' ')"/>
                            </xsl:if>
                          </xsl:if>
                        </xsl:variable>
                        <xsl:choose>
                          <xsl:when test="fn:exists($var1744_cond_result_exists)">
                            <gmd:MD_MediumNameCode>
                              <xsl:variable name="var1748_map_result_groupitems" as="xs:string+">
                                <xsl:for-each select="$var1741_cur_result_groupby">
                                  <xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
                                </xsl:for-each>
                              </xsl:variable>
                              <xsl:variable name="var1747_map_result_distinctvalues" as="xs:string*">
                                <xsl:for-each select="fn:distinct-values($var1748_map_result_groupitems)">
                                  <xsl:variable name="var1751_result_vmf17_inputtoresult" as="xs:string?">
                                    <xsl:call-template name="vmf:vmf17_inputtoresult">
                                      <xsl:with-param name="input" select="fn:upper-case(.)"/>
                                    </xsl:call-template>
                                  </xsl:variable>
                                  <xsl:if test="fn:exists($var1751_result_vmf17_inputtoresult)">
                                    <xsl:sequence select="$var1751_result_vmf17_inputtoresult"/>
                                  </xsl:if>
                                </xsl:for-each>
                              </xsl:variable>
                              <xsl:variable name="var1746_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1747_map_result_distinctvalues)) then fn:string-join($var1747_map_result_distinctvalues, ' ') else ())"/>
                              <xsl:variable name="var1745_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1746_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode' else ())"/>
                              <xsl:if test="fn:exists($var1745_cond_result_exists)">
                                <xsl:attribute name="codeList">
                                  <xsl:sequence select="xs:string(($var1745_cond_result_exists))"/>
                                </xsl:attribute>
                              </xsl:if>
                              <xsl:attribute name="codeListValue">
                                <xsl:sequence select="xs:string($var1744_cond_result_exists)"/>
                              </xsl:attribute>
                              <xsl:variable name="var1765_map_result_groupitems" as="xs:string+">
                                <xsl:for-each select="$var1741_cur_result_groupby">
                                  <xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
                                </xsl:for-each>
                              </xsl:variable>
                              <xsl:variable name="var1764_map_result_distinctvalues" as="xs:string*">
                                <xsl:for-each select="fn:distinct-values($var1765_map_result_groupitems)">
                                  <xsl:variable name="var1768_result_vmf17_inputtoresult" as="xs:string?">
                                    <xsl:call-template name="vmf:vmf17_inputtoresult">
                                      <xsl:with-param name="input" select="fn:upper-case(.)"/>
                                    </xsl:call-template>
                                  </xsl:variable>
                                  <xsl:if test="fn:exists($var1768_result_vmf17_inputtoresult)">
                                    <xsl:sequence select="$var1768_result_vmf17_inputtoresult"/>
                                  </xsl:if>
                                </xsl:for-each>
                              </xsl:variable>
                              <xsl:variable name="var1755_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1764_map_result_distinctvalues)) then fn:string-join($var1764_map_result_distinctvalues, ' ') else ())"/>
                              <xsl:sequence select="$var1744_cond_result_exists"/>
                            </gmd:MD_MediumNameCode>
                          </xsl:when>
                          <xsl:otherwise>
                            <xsl:attribute name="gco:nilReason" select="'template'"/>
                            <xsl:comment>FGDC content not mapped to ISO MD_MediumCode. From Xpath: //distinfo/stdorder/digform/digtopt/offoptn/offmedia </xsl:comment>
                            <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                            <xsl:copy-of select=".//offmedia"/>
                            <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gmd:name>
                      <xsl:for-each select="$var1741_cur_result_groupby/reccap/recden">
                        <gmd:density>
                          <gco:Real>
                            <xsl:sequence select="xs:string(xs:double(.))"/>
                          </gco:Real>
                        </gmd:density>
                      </xsl:for-each>
                      <xsl:for-each select="$var1741_cur_result_groupby/reccap">
                        <gmd:densityUnits>
                          <gco:CharacterString>
                            <xsl:sequence select="fn:normalize-space(xs:string(recdenu))"/>
                          </gco:CharacterString>
                        </gmd:densityUnits>
                      </xsl:for-each>
                      <!-- fix mediumFormat  -->
                      <xsl:if test="recfmt">
                        <gmd:mediumFormat>
                          <xsl:variable name="var1801_map_result_groupitems" as="xs:string*">
                            <xsl:for-each select="$var1741_cur_result_groupby/recfmt">
                              <xsl:variable name="var1804_result_vmf19_inputtoresult" as="xs:string?">
                                <xsl:call-template name="vmf:vmf19_inputtoresult">
                                  <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
                                </xsl:call-template>
                              </xsl:variable>
                              <xsl:if test="fn:exists($var1804_result_vmf19_inputtoresult)">
                                <xsl:sequence select="$var1804_result_vmf19_inputtoresult"/>
                              </xsl:if>
                            </xsl:for-each>
                          </xsl:variable>
                          <xsl:variable name="var1791_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1801_map_result_groupitems)) then fn:string-join($var1801_map_result_groupitems, ' ') else ())"/>
                          <xsl:for-each select="$var1791_cond_result_exists">
                            <gmd:MD_MediumFormatCode>
                              <xsl:attribute name="codeList">
                                <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'))"/>
                              </xsl:attribute>
                              <xsl:attribute name="codeListValue">
                                <xsl:value-of select="xs:string(.)"/>
                              </xsl:attribute>
                              <!--<xsl:variable name="var1797_map_result_groupitems" as="xs:string*">
                                <xsl:for-each select="$var1741_cur_result_groupby/recfmt">
                                  <xsl:variable name="var1800_result_vmf20_inputtoresult" as="xs:string?">
                                    <xsl:call-template name="vmf:vmf20_inputtoresult">
                                      <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
                                    </xsl:call-template>
                                  </xsl:variable>
                                  <xsl:if test="fn:exists($var1800_result_vmf20_inputtoresult)">
                                    <xsl:sequence select="$var1800_result_vmf20_inputtoresult"/>
                                  </xsl:if>
                                </xsl:for-each>
                              </xsl:variable>-->
                              <xsl:sequence select="."/>
                            </gmd:MD_MediumFormatCode>
                          </xsl:for-each>
                        </gmd:mediumFormat>
                      </xsl:if>
                      <xsl:variable name="var1805_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
                      <xsl:if test="fn:exists($var1805_cond_result_exists)">
                        <xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont">
                          <xsl:variable name="var1806_formcont" as="node()" select="."/>
                          <xsl:variable name="var1808_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1741_cur_result_groupby/compat)) then ' Compatibility Information: ' else ())"/>
                          <!-- These two lines were commented out by Ted Habermann 20121025 -->
                          <!-- <xsl:if test="fn:exists($var1808_cond_result_exists)">
                            <xsl:for-each select="$var1741_cur_result_groupby/compat"> -->
                          <gmd:mediumNote>
                            <gco:CharacterString>
                              <xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat($var1805_cond_result_exists, fn:normalize-space(xs:string($var1806_formcont))), $var1808_cond_result_exists), xs:string(.)))"/>
                            </gco:CharacterString>
                          </gmd:mediumNote>
                          <!-- </xsl:for-each>
                          </xsl:if> -->
                        </xsl:for-each>
                      </xsl:if>
                    </gmd:MD_Medium>
                  </gmd:offLine>
                </gmd:MD_DigitalTransferOptions>
              </gmd:transferOptions>
            </xsl:for-each-group>
          </gmd:MD_Distribution>
        </gmd:distributionInfo>
      </xsl:if>
      <!-- Data Quality -->
      <xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var1811_metadata" as="node()" select="."/>
        <xsl:for-each select="dataqual">
          <gmd:dataQualityInfo>
            <gmd:DQ_DataQuality>
              <gmd:scope>
                <gmd:DQ_Scope>
                  <gmd:level>
                    <gmd:MD_ScopeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MD_ScopeCode" codeListValue="dataset">dataset</gmd:MD_ScopeCode>
                  </gmd:level>
                </gmd:DQ_Scope>
              </gmd:scope>
              <xsl:for-each select="posacc/horizpa/horizpar">
                <gmd:report>
                  <gmd:DQ_AbsoluteExternalPositionalAccuracy>
                    <gmd:nameOfMeasure>
                      <gco:CharacterString>
                        <xsl:sequence select="'Horizontal Positional Accuracy Report'"/>
                      </gco:CharacterString>
                    </gmd:nameOfMeasure>
                    <gmd:evaluationMethodDescription>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:evaluationMethodDescription>
                    <gmd:result gco:nilReason="missing"/>
                  </gmd:DQ_AbsoluteExternalPositionalAccuracy>
                </gmd:report>
              </xsl:for-each>
              <!--horizontal position -->
              <xsl:for-each select="posacc/horizpa/qhorizpa">
                <gmd:report>
                  <gmd:DQ_AbsoluteExternalPositionalAccuracy>
                    <gmd:nameOfMeasure>
                      <gco:CharacterString>
                        <xsl:sequence select="'Horizontal Positional Accuracy'"/>
                      </gco:CharacterString>
                    </gmd:nameOfMeasure>
                    <xsl:if test=".//horizpae">
                      <gmd:measureDescription>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(horizpae))"/>
                        </gco:CharacterString>
                      </gmd:measureDescription>
                    </xsl:if>
                    <gmd:result>
                      <gmd:DQ_QuantitativeResult>
                        <gmd:valueUnit>
                          <gml:BaseUnit>
                            <xsl:attribute name="gml:id">
                              <xsl:value-of select="generate-id()"/>
                            </xsl:attribute>
                            <gml:identifier>
                              <xsl:attribute name="codeSpace">
                                <xsl:sequence select="xs:string(('local'))"/>
                              </xsl:attribute>
                              <xsl:text>meters</xsl:text>
                            </gml:identifier>
                            <gml:unitsSystem nilReason="unknown"/>
                          </gml:BaseUnit>
                        </gmd:valueUnit>
                        <xsl:choose>
                          <xsl:when test=".//horizpav">
                            <gmd:value>
                              <gco:Record>
                                <xsl:sequence select="xs:string(./horizpav)"/>
                              </gco:Record>
                            </gmd:value>
                          </xsl:when>
                          <xsl:otherwise>
                            <gmd:value gco:nilReason="missing"/>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gmd:DQ_QuantitativeResult>
                    </gmd:result>
                  </gmd:DQ_AbsoluteExternalPositionalAccuracy>
                </gmd:report>
              </xsl:for-each>
              <xsl:for-each select="posacc/vertacc/vertaccr">
                <gmd:report>
                  <gmd:DQ_AbsoluteExternalPositionalAccuracy>
                    <gmd:nameOfMeasure>
                      <gco:CharacterString>
                        <xsl:sequence select="'Vertical Positional Accuracy Report'"/>
                      </gco:CharacterString>
                    </gmd:nameOfMeasure>
                    <gmd:evaluationMethodDescription>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                      </gco:CharacterString>
                    </gmd:evaluationMethodDescription>
                    <gmd:result gco:nilReason="missing"/>
                  </gmd:DQ_AbsoluteExternalPositionalAccuracy>
                </gmd:report>
              </xsl:for-each>
              <xsl:for-each select="posacc/vertacc/qvertpa">
                <gmd:report>
                  <gmd:DQ_AbsoluteExternalPositionalAccuracy>
                    <gmd:nameOfMeasure>
                      <gco:CharacterString>
                        <xsl:sequence select="'Vertical Positional Accuracy'"/>
                      </gco:CharacterString>
                    </gmd:nameOfMeasure>
                    <xsl:if test=".//vertacce">
                      <gmd:measureDescription>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(vertacce))"/>
                        </gco:CharacterString>
                      </gmd:measureDescription>
                    </xsl:if>
                    <gmd:result>
                      <gmd:DQ_QuantitativeResult>
                        <gmd:valueUnit>
                          <gml:BaseUnit>
                            <xsl:attribute name="gml:id">
                              <xsl:value-of select="generate-id()"/>
                            </xsl:attribute>
                            <gml:identifier>
                              <xsl:attribute name="codeSpace">
                                <xsl:sequence select="xs:string(('local'))"/>
                              </xsl:attribute>
                              <xsl:text>meters</xsl:text>
                            </gml:identifier>
                            <gml:unitsSystem nilReason="unknown"/>
                          </gml:BaseUnit>
                        </gmd:valueUnit>
                        <xsl:choose>
                          <xsl:when test=".//vertaccv">
                            <gmd:value>
                              <gco:Record>
                                <xsl:sequence select="xs:string(./vertaccv)"/>
                              </gco:Record>
                            </gmd:value>
                          </xsl:when>
                          <xsl:otherwise>
                            <gmd:value gco:nilReason="missing"/>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gmd:DQ_QuantitativeResult>
                    </gmd:result>
                  </gmd:DQ_AbsoluteExternalPositionalAccuracy>
                </gmd:report>
              </xsl:for-each>
              <gmd:report>
                <gmd:DQ_CompletenessCommission>
                  <gmd:evaluationMethodDescription>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(complete))"/>
                    </gco:CharacterString>
                  </gmd:evaluationMethodDescription>
                  <gmd:result>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                    </xsl:attribute>
                  </gmd:result>
                </gmd:DQ_CompletenessCommission>
              </gmd:report>
              <gmd:report>
                <gmd:DQ_ConceptualConsistency>
                  <gmd:measureDescription>
                    <gco:CharacterString>
                      <xsl:sequence select="fn:normalize-space(xs:string(logic))"/>
                    </gco:CharacterString>
                  </gmd:measureDescription>
                  <gmd:result>
                    <xsl:attribute name="gco:nilReason">
                      <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                    </xsl:attribute>
                  </gmd:result>
                </gmd:DQ_ConceptualConsistency>
              </gmd:report>
              <xsl:for-each select="attracc">
                <xsl:variable name="var1828_attracc" as="node()" select="."/>
                <xsl:for-each select="qattracc">
                  <gmd:report>
                    <gmd:DQ_QuantitativeAttributeAccuracy>
                      <gmd:nameOfMeasure>
                        <gco:CharacterString>
                          <xsl:sequence select="'Quantitative Attribute Accuracy Assessment'"/>
                        </gco:CharacterString>
                      </gmd:nameOfMeasure>
                      <gmd:measureDescription>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(attracce))"/>
                        </gco:CharacterString>
                      </gmd:measureDescription>
                      <gmd:evaluationMethodDescription>
                        <xsl:for-each select="$var1828_attracc/attraccr">
                          <gco:CharacterString>
                            <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                          </gco:CharacterString>
                        </xsl:for-each>
                      </gmd:evaluationMethodDescription>
                      <gmd:result>
                        <gmd:DQ_QuantitativeResult>
                          <gmd:valueUnit>
                            <gml:BaseUnit>
                              <xsl:attribute name="gml:id">
                                <xsl:value-of select="generate-id()"/>
                              </xsl:attribute>
                              <gml:identifier>
                                <xsl:attribute name="codeSpace">
                                  <xsl:sequence select="xs:string(('local'))"/>
                                </xsl:attribute>
                                <xsl:text>meters</xsl:text>
                              </gml:identifier>
                              <gml:unitsSystem nilReason="unknown"/>
                            </gml:BaseUnit>
                          </gmd:valueUnit>
                          <gmd:value>
                            <xsl:for-each select="attraccv">
                              <gco:Record>
                                <xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
                              </gco:Record>
                            </xsl:for-each>
                          </gmd:value>
                        </gmd:DQ_QuantitativeResult>
                      </gmd:result>
                    </gmd:DQ_QuantitativeAttributeAccuracy>
                  </gmd:report>
                </xsl:for-each>
              </xsl:for-each>
              <gmd:lineage>
                <gmd:LI_Lineage>
                  <xsl:for-each select="lineage/procstep">
                    <xsl:variable name="var1836_procstep" as="node()" select="."/>
                    <gmd:processStep>
                      <gmi:LE_ProcessStep>
                        <gmd:description>
                          <gco:CharacterString>
                            <xsl:sequence select="fn:normalize-space(xs:string(procdesc))"/>
                          </gco:CharacterString>
                        </gmd:description>
                        <gmd:dateTime>
                          <xsl:choose>
                            <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown'))">
                              <xsl:attribute name="gco:nilReason">
                                <xsl:sequence select="xs:string('unknown')"/>
                              </xsl:attribute>
                            </xsl:when>
                            <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'not complete'))">
                              <xsl:attribute name="gco:nilReason">
                                <xsl:sequence select="xs:string('unknown')"/>
                              </xsl:attribute>
                            </xsl:when>
                            <xsl:when test="./proctime">
                              <gco:DateTime>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                  <xsl:with-param name="timeField" select="normalize-space(./proctime)"/>
                                </xsl:call-template>
                              </gco:DateTime>
                            </xsl:when>
                            <xsl:otherwise>
                              <gco:DateTime>
                                <xsl:call-template name="fgdc2isoDateTime">
                                  <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                  <xsl:with-param name="timeField" select="'00:00:00'"/>
                                </xsl:call-template>
                              </gco:DateTime>
                            </xsl:otherwise>
                          </xsl:choose>
                        </gmd:dateTime>
                        <xsl:for-each select="proccont">
                          <gmd:processor>
                            <xsl:call-template name="CI_ResponsibleParty">
                              <xsl:with-param name="role">processor</xsl:with-param>
                            </xsl:call-template>
                          </gmd:processor>
                        </xsl:for-each>
                        <!-- source and output added by ted.habermann@noaa.gov 2012-04-28 -->
                        <xsl:for-each select=".//srcused">
                          <xsl:element name="gmd:source">
                            <!-- Ted Habermann Added translation of ' ' to '_' and drop perentheses, slash and comma -->
                            <xsl:attribute name="xlink:href" select="concat('#',translate(normalize-space(.),' ()/,','_'))"/>
                          </xsl:element>
                        </xsl:for-each>
                        <xsl:for-each select=".//srcprod">
                          <xsl:element name="gmi:output">
                            <!-- Ted Habermann Added translation of ' ' to '_' and drop perentheses, slash and comma -->
                            <xsl:attribute name="xlink:href" select="concat('#',translate(normalize-space(.),' ()/,','_'))"/>
                          </xsl:element>
                        </xsl:for-each>
                      </gmi:LE_ProcessStep>
                    </gmd:processStep>
                  </xsl:for-each>
                  <xsl:for-each select="lineage/srcinfo">
                    <xsl:variable name="var2381_srcinfo" as="node()" select="."/>
                    <gmd:source>
                      <gmd:LI_Source>
                        <xsl:if test="./srccitea">
                          <xsl:choose>
                            <xsl:when test="upper-case(normalize-space(./srccitea))='NONE'"/>
                            <xsl:otherwise>
                              <xsl:call-template name="idTransform"/>
                            </xsl:otherwise>
                          </xsl:choose>
                        </xsl:if>
                        <gmd:description>
                          <gco:CharacterString>
                            <xsl:sequence select="fn:normalize-space(fn:concat(fn:concat('Source Contribution: ', xs:string(srccontr)), 'Source Type: ', xs:string(typesrc)))"/>
                          </gco:CharacterString>
                        </gmd:description>
                        <xsl:if test="./srcscale">
                          <gmd:scaleDenominator>
                            <gmd:MD_RepresentativeFraction>
                              <xsl:comment>srcscale: <xsl:value-of select="./srcscale"/></xsl:comment>
                              <gmd:denominator>
                                <xsl:for-each select="srcscale">
                                  <xsl:choose>
                                    <xsl:when test="(fn:lower-case(normalize-space(.)) = 'unknown')">
                                      <xsl:attribute name="gco:nilReason" select="'unknown'"/>
                                    </xsl:when>
                                    <xsl:when test="normalize-space(.) castable as xs:integer">
                                      <gco:Integer>
                                        <xsl:choose>
                                          <xsl:when test="contains(.,':')">
                                            <!-- Ted Habermann - extracting denominator from strings like 1:250000 -->
                                            <xsl:sequence select="translate(substring-after(.,':'),',','')"/>
                                          </xsl:when>
                                          <xsl:otherwise>
                                            <!-- remove commas from the integer - Ted Habermann -->
                                            <xsl:sequence select="translate(xs:string(.),',','')"/>
                                          </xsl:otherwise>
                                        </xsl:choose>
                                      </gco:Integer>
                                    </xsl:when>
                                    <xsl:otherwise>
                                      <xsl:attribute name="gco:nilReason" select="'unknown'"/>
                                    </xsl:otherwise>
                                  </xsl:choose>
                                </xsl:for-each>
                              </gmd:denominator>
                            </gmd:MD_RepresentativeFraction>
                          </gmd:scaleDenominator>
                        </xsl:if>
                        <xsl:for-each select="srccite/citeinfo">
                          <gmd:sourceCitation>
                            <xsl:call-template name="CI_Citation"/>
                          </gmd:sourceCitation>
                        </xsl:for-each>
                        <gmd:sourceExtent>
                          <gmd:EX_Extent>
                            <xsl:for-each select="srctime/timeinfo/sngdate">
                              <gmd:temporalElement>
                                <gmd:EX_TemporalExtent>
                                  <xsl:choose>
                                    <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown'))">
                                      <gmd:extent gco:nilReason="unknown"/>
                                    </xsl:when>
                                    <xsl:when test="contains(lower-case(normalize-space(./time)), 'unknown')">
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:when>
                                    <xsl:when test="./time">
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDateTime">
                                              <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                              <xsl:with-param name="timeField" select="normalize-space(time)"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:when>
                                    <xsl:otherwise>
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(caldate)"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:otherwise>
                                  </xsl:choose>
                                </gmd:EX_TemporalExtent>
                              </gmd:temporalElement>
                            </xsl:for-each>
                            <xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
                              <gmd:temporalElement>
                                <gmd:EX_TemporalExtent>
                                  <xsl:choose>
                                    <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown'))">
                                      <gmd:extent gco:nilReason="unknown"/>
                                    </xsl:when>
                                    <xsl:when test="contains(lower-case(normalize-space(./time)), 'unknown')">
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="caldate"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:when>
                                    <xsl:when test="./time">
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDateTime">
                                              <xsl:with-param name="dateField" select="caldate"/>
                                              <xsl:with-param name="timeField" select="time"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:when>
                                    <xsl:otherwise>
                                      <gmd:extent>
                                        <gml:TimeInstant>
                                          <xsl:attribute name="gml:id">
                                            <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <gml:timePosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="caldate"/>
                                            </xsl:call-template>
                                          </gml:timePosition>
                                        </gml:TimeInstant>
                                      </gmd:extent>
                                    </xsl:otherwise>
                                  </xsl:choose>
                                </gmd:EX_TemporalExtent>
                              </gmd:temporalElement>
                            </xsl:for-each>
                            <xsl:for-each select="srctime/timeinfo/rngdates">
                              <gmd:temporalElement>
                                <xsl:if test="contains(lower-case(normalize-space(begdate)), 'unknown')">
                                  <xsl:attribute name="gco:nilReason">unknown</xsl:attribute>
                                </xsl:if>
                                <gmd:EX_TemporalExtent>
                                  <gmd:extent>
                                    <gml:TimePeriod>
                                      <xsl:attribute name="gml:id">
                                        <xsl:value-of select="generate-id()"/>
                                      </xsl:attribute>
                                      <xsl:choose>
                                        <xsl:when test="contains(lower-case(normalize-space(begdate)), 'unknown')">
                                          <gml:beginPosition indeterminatePosition="unknown"/>
                                        </xsl:when>
                                        <xsl:when test="contains(lower-case(normalize-space(begtiime)), 'unknown')">
                                          <gml:beginPosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(./begdate)"/>
                                            </xsl:call-template>
                                          </gml:beginPosition>
                                        </xsl:when>
                                        <xsl:when test="begtime">
                                          <gml:beginPosition>
                                            <xsl:call-template name="fgdc2isoDateTime">
                                              <xsl:with-param name="dateField" select="normalize-space(./begdate)"/>
                                              <xsl:with-param name="timeField" select="normalize-space(./begtime)"/>
                                            </xsl:call-template>
                                          </gml:beginPosition>
                                        </xsl:when>
                                        <xsl:otherwise>
                                          <gml:beginPosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(./begdate)"/>
                                            </xsl:call-template>
                                          </gml:beginPosition>
                                        </xsl:otherwise>
                                      </xsl:choose>
                                      <xsl:choose>
                                        <xsl:when test="contains(lower-case(normalize-space(enddate)), 'unknown')">
                                          <gml:endPosition indeterminatePosition="unknown"/>
                                        </xsl:when>
                                        <xsl:when test="contains(lower-case(normalize-space(enddate)), 'present')">
                                          <gml:endPosition indeterminatePosition="now"/>
                                        </xsl:when>
                                        <xsl:when test="contains(lower-case(normalize-space(endtime)), 'unknown')">
                                          <gml:endPosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                            </xsl:call-template>
                                          </gml:endPosition>
                                        </xsl:when>
                                        <xsl:when test="endtime">
                                          <gml:endPosition>
                                            <xsl:call-template name="fgdc2isoDateTime">
                                              <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                              <xsl:with-param name="timeField" select="normalize-space(./endtime)"/>
                                            </xsl:call-template>
                                          </gml:endPosition>
                                        </xsl:when>
                                        <xsl:otherwise>
                                          <gml:endPosition>
                                            <xsl:call-template name="fgdc2isoDate">
                                              <xsl:with-param name="dateField" select="normalize-space(./enddate)"/>
                                            </xsl:call-template>
                                          </gml:endPosition>
                                        </xsl:otherwise>
                                      </xsl:choose>
                                    </gml:TimePeriod>
                                  </gmd:extent>
                                </gmd:EX_TemporalExtent>
                              </gmd:temporalElement>
                            </xsl:for-each>
                          </gmd:EX_Extent>
                        </gmd:sourceExtent>
                      </gmd:LI_Source>
                    </gmd:source>
                  </xsl:for-each>
                </gmd:LI_Lineage>
              </gmd:lineage>
            </gmd:DQ_DataQuality>
          </gmd:dataQualityInfo>
        </xsl:for-each>
      </xsl:for-each>
      <!-- mission history -->
      <xsl:if test="//misshist">
        <gmd:dataQualityInfo>
          <gmd:DQ_DataQuality>
            <gmd:scope>
              <gmd:DQ_Scope>
                <gmd:level>
                  <gmx:MX_ScopeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MX_ScopeCode" codeListValue="platformSeries">platformSeries</gmx:MX_ScopeCode>
                </gmd:level>
                <gmd:levelDescription>
                  <gmd:MD_ScopeDescription>
                    <gmd:other>
                      <gco:CharacterString>Mission History</gco:CharacterString>
                    </gmd:other>
                  </gmd:MD_ScopeDescription>
                </gmd:levelDescription>
              </gmd:DQ_Scope>
            </gmd:scope>
            <gmd:lineage>
              <gmd:LI_Lineage>
                <xsl:if test="//misshist/missstdt">
                  <gmd:processStep>
                    <gmi:LE_ProcessStep>
                      <gmd:description>
                        <gco:CharacterString>
                          <xsl:text>Mission Start Date</xsl:text>
                        </gco:CharacterString>
                      </gmd:description>
                      <gmd:dateTime>
                        <xsl:choose>
                          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(//missstdt/sngdate/caldate))), 'unknown'))">
                            <xsl:attribute name="gco:nilReason">
                              <xsl:text>unknown</xsl:text>
                            </xsl:attribute>
                          </xsl:when>
                          <xsl:otherwise>
                            <gco:DateTime>
                              <xsl:call-template name="fgdc2isoDateTime">
                                <xsl:with-param name="dateField" select="normalize-space(//missstdt/sngdate/caldate)"/>
                                <xsl:with-param name="timeField" select="'00:00:00'"/>
                              </xsl:call-template>
                            </gco:DateTime>
                          </xsl:otherwise>
                        </xsl:choose>
                        <xsl:value-of select="normalize-space(/sngdate/caldate)"/>
                      </gmd:dateTime>
                    </gmi:LE_ProcessStep>
                  </gmd:processStep>
                </xsl:if>
                <xsl:for-each select="//misshist/misssige/procstep">
                  <gmd:processStep>
                    <gmi:LE_ProcessStep>
                      <gmd:description>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(procdesc))"/>
                        </gco:CharacterString>
                      </gmd:description>
                      <gmd:dateTime>
                        <xsl:choose>
                          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown'))">
                            <xsl:attribute name="gco:nilReason">
                              <xsl:sequence select="xs:string('unknown')"/>
                            </xsl:attribute>
                          </xsl:when>
                          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'not complete'))">
                            <xsl:attribute name="gco:nilReason">
                              <xsl:sequence select="xs:string('unknown')"/>
                            </xsl:attribute>
                          </xsl:when>
                          <xsl:when test="./proctime">
                            <gco:DateTime>
                              <xsl:call-template name="fgdc2isoDateTime">
                                <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                <xsl:with-param name="timeField" select="normalize-space(./proctime)"/>
                              </xsl:call-template>
                            </gco:DateTime>
                          </xsl:when>
                          <xsl:otherwise>
                            <gco:DateTime>
                              <xsl:call-template name="fgdc2isoDateTime">
                                <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                <xsl:with-param name="timeField" select="'00:00:00'"/>
                              </xsl:call-template>
                            </gco:DateTime>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gmd:dateTime>
                      <xsl:for-each select="proccont">
                        <xsl:variable name="var2016_proccont" as="node()" select="."/>
                        <gmd:processor>
                          <xsl:call-template name="CI_ResponsibleParty">
                            <xsl:with-param name="role">processor</xsl:with-param>
                          </xsl:call-template>
                        </gmd:processor>
                      </xsl:for-each>
                      <xsl:if test="./procinfo">
                        <gmi:processingInformation>
                          <gmi:LE_Processing>
                            <xsl:for-each select="procinfo">
                              <xsl:for-each select="procsoft/prsoref/citeinfo">
                                <gmi:softwareReference>
                                  <xsl:call-template name="CI_Citation"/>
                                </gmi:softwareReference>
                              </xsl:for-each>
                            </xsl:for-each>
                            <xsl:for-each select="algoinfo">
                              <gmi:algorithm>
                                <gmi:LE_Algorithm>
                                  <xsl:for-each select="algodesc/algoref/citeinfo">
                                    <gmi:citation>
                                      <xsl:call-template name="CI_Citation"/>
                                    </gmi:citation>
                                  </xsl:for-each>
                                  <xsl:for-each select="algodesc/algotexd">
                                    <gmi:description>
                                      <gco:CharacterString>
                                        <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                                      </gco:CharacterString>
                                    </gmi:description>
                                  </xsl:for-each>
                                </gmi:LE_Algorithm>
                              </gmi:algorithm>
                            </xsl:for-each>
                          </gmi:LE_Processing>
                        </gmi:processingInformation>
                      </xsl:if>
                    </gmi:LE_ProcessStep>
                  </gmd:processStep>
                </xsl:for-each>
                <xsl:for-each select="misshist/misssige/procstep/algoinfo/algochhi/algochde/procstep">
                  <gmd:processStep>
                    <gmi:LE_ProcessStep>
                      <gmd:description>
                        <gco:CharacterString>
                          <xsl:sequence select="fn:normalize-space(xs:string(procdesc))"/>
                        </gco:CharacterString>
                      </gmd:description>
                      <gmd:dateTime>
                        <xsl:choose>
                          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown'))">
                            <xsl:attribute name="gco:nilReason">
                              <xsl:sequence select="xs:string('unknown')"/>
                            </xsl:attribute>
                          </xsl:when>
                          <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'not complete'))">
                            <xsl:attribute name="gco:nilReason">
                              <xsl:sequence select="xs:string('unknown')"/>
                            </xsl:attribute>
                          </xsl:when>
                          <xsl:when test="./proctime">
                            <gco:DateTime>
                              <xsl:call-template name="fgdc2isoDateTime">
                                <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                <xsl:with-param name="timeField" select="normalize-space(./proctime)"/>
                              </xsl:call-template>
                            </gco:DateTime>
                          </xsl:when>
                          <xsl:otherwise>
                            <gco:DateTime>
                              <xsl:call-template name="fgdc2isoDateTime">
                                <xsl:with-param name="dateField" select="normalize-space(./procdate)"/>
                                <xsl:with-param name="timeField" select="'00:00:00'"/>
                              </xsl:call-template>
                            </gco:DateTime>
                          </xsl:otherwise>
                        </xsl:choose>
                      </gmd:dateTime>
                      <xsl:for-each select="proccont">
                        <xsl:variable name="var2272_proccont" as="node()" select="."/>
                        <gmd:processor>
                          <xsl:call-template name="CI_ResponsibleParty">
                            <xsl:with-param name="role">processor</xsl:with-param>
                          </xsl:call-template>
                        </gmd:processor>
                      </xsl:for-each>
                      <xsl:for-each select="procinfo">
                        <xsl:variable name="var2312_procinfo" as="node()" select="."/>
                        <gmi:processingInformation>
                          <gmi:LE_Processing>
                            <gmi:identifier>
                              <gmd:MD_Identifier>
                                <xsl:for-each select="procidfs/citeinfo">
                                  <gmd:authority>
                                    <xsl:call-template name="CI_Citation"/>
                                  </gmd:authority>
                                </xsl:for-each>
                                <gmd:code>
                                  <xsl:attribute name="gco:nilReason">
                                    <xsl:sequence select="xs:string(xs:string('unknown'))"/>
                                  </xsl:attribute>
                                </gmd:code>
                              </gmd:MD_Identifier>
                            </gmi:identifier>
                          </gmi:LE_Processing>
                        </gmi:processingInformation>
                      </xsl:for-each>
                      <xsl:for-each select="srcprod">
                        <gmi:output>
                          <gmi:LE_Source>
                            <gmd:description>
                              <gco:CharacterString>
                                <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
                              </gco:CharacterString>
                            </gmd:description>
                          </gmi:LE_Source>
                        </gmi:output>
                      </xsl:for-each>
                    </gmi:LE_ProcessStep>
                  </gmd:processStep>
                </xsl:for-each>
              </gmd:LI_Lineage>
            </gmd:lineage>
          </gmd:DQ_DataQuality>
        </gmd:dataQualityInfo>
      </xsl:if>
      <xsl:for-each select="$var1_instance/metadata">
        <xsl:variable name="var2950_metadata" as="node()" select="."/>
        <xsl:for-each select="//metainfo/metac">
          <gmd:metadataConstraints>
            <gmd:MD_LegalConstraints>
              <gmd:accessConstraints>
                <gmd:MD_RestrictionCode>
                  <xsl:attribute name="codeList">
                    <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
                  </xsl:attribute>
                  <xsl:attribute name="codeListValue">
                    <xsl:sequence select="xs:string(('otherRestrictions'))"/>
                  </xsl:attribute>
                  <xsl:text>otherRestrictions</xsl:text>
                </gmd:MD_RestrictionCode>
              </gmd:accessConstraints>
              <gmd:otherConstraints>
                <gco:CharacterString>
                  <xsl:value-of select="concat('Metadata Access Constraints: ', normalize-space(.))"/>
                </gco:CharacterString>
              </gmd:otherConstraints>
            </gmd:MD_LegalConstraints>
          </gmd:metadataConstraints>
        </xsl:for-each>
      </xsl:for-each>
      <xsl:for-each select="//metainfo/metuc">
        <gmd:metadataConstraints>
          <gmd:MD_LegalConstraints>
            <gmd:accessConstraints>
              <gmd:MD_RestrictionCode>
                <xsl:attribute name="codeList">
                  <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
                </xsl:attribute>
                <xsl:attribute name="codeListValue">
                  <xsl:sequence select="xs:string(('otherRestrictions'))"/>
                </xsl:attribute>
                <xsl:text>otherRestrictions</xsl:text>
              </gmd:MD_RestrictionCode>
            </gmd:accessConstraints>
            <gmd:otherConstraints>
              <gco:CharacterString>
                <xsl:value-of select="concat('Metadata Use Constraints: ', normalize-space(.))"/>
              </gco:CharacterString>
            </gmd:otherConstraints>
          </gmd:MD_LegalConstraints>
        </gmd:metadataConstraints>
      </xsl:for-each>
      <xsl:for-each select="$var1_instance/metadata/metainfo/metsi">
        <gmd:metadataConstraints>
          <gmd:MD_SecurityConstraints>
            <xsl:if test="metsc">
              <gmd:classification>
                <xsl:variable name="var2962_result_vmf13_inputtoresult" as="xs:string?">
                  <xsl:call-template name="vmf:vmf13_inputtoresult">
                    <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(metsc))))"/>
                  </xsl:call-template>
                </xsl:variable>
                <xsl:variable name="var2961_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2962_result_vmf13_inputtoresult)) then $var2962_result_vmf13_inputtoresult else ())"/>
                <xsl:choose>
                  <xsl:when test="fn:exists($var2961_cond_result_exists)">
                    <gmd:MD_ClassificationCode>
                      <xsl:attribute name="codeListValue">
                        <xsl:sequence select="xs:string(($var2961_cond_result_exists))"/>
                      </xsl:attribute>
                      <xsl:attribute name="codeList">
                        <xsl:sequence select="xs:string(('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
                      </xsl:attribute>
                    </gmd:MD_ClassificationCode>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:attribute name="gco:nilReason">missing</xsl:attribute>
                    <xsl:comment>FGDC content not mapped to ISO. From Xpath: </xsl:comment>
                    <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                    <xsl:copy-of select="//metsc"/>
                    <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                  </xsl:otherwise>
                </xsl:choose>
              </gmd:classification>
            </xsl:if>
            <gmd:classificationSystem>
              <gco:CharacterString>
                <xsl:sequence select="fn:normalize-space(xs:string(metscs))"/>
              </gco:CharacterString>
            </gmd:classificationSystem>
          </gmd:MD_SecurityConstraints>
        </gmd:metadataConstraints>
      </xsl:for-each>
      <gmd:metadataMaintenance>
        <gmd:MD_MaintenanceInformation>
          <gmd:maintenanceAndUpdateFrequency>
            <gmd:MD_MaintenanceFrequencyCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode" codeListValue="annually">annually</gmd:MD_MaintenanceFrequencyCode>
          </gmd:maintenanceAndUpdateFrequency>
          <xsl:for-each select="$var1_instance/metadata/metainfo/metfrd">
            <gmd:dateOfNextUpdate>
              <gco:Date>
                <xsl:call-template name="fgdc2isoDate">
                  <xsl:with-param name="dateField" select="normalize-space(.)"/>
                </xsl:call-template>
              </gco:Date>
            </gmd:dateOfNextUpdate>
          </xsl:for-each>
          <gmd:maintenanceNote>
            <gco:CharacterString> This metadata was automatically generated from the <xsl:value-of select="normalize-space(//metainfo/metstdn)"/> standard (version <xsl:value-of select="normalize-space(//metainfo/metstdv)"/>) using the <xsl:value-of select="$LastUpdateXSLT"/> version of the <xsl:value-of select="$thisXSLT"/>.</gco:CharacterString>
          </gmd:maintenanceNote>
          <gmd:maintenanceNote>
            <gco:CharacterString>
              <xsl:text>Translated from FGDC </xsl:text>
              <xsl:value-of select="current-dateTime()"/>
            </gco:CharacterString>
          </gmd:maintenanceNote>
          <xsl:for-each select="//metainfo/metrd">
            <gmd:maintenanceNote>
              <gco:CharacterString>
                <xsl:text>Last Metadata Review Date: </xsl:text>
                <xsl:call-template name="fgdc2isoDate">
                  <xsl:with-param name="dateField" select="normalize-space(.)"/>
                </xsl:call-template>
              </gco:CharacterString>
            </gmd:maintenanceNote>
          </xsl:for-each>
          <xsl:for-each select="//metainfo/metc/cntinfo">
            <gmd:contact>
              <xsl:call-template name="CI_ResponsibleParty">
                <xsl:with-param name="role">pointOfContact</xsl:with-param>
              </xsl:call-template>
            </gmd:contact>
          </xsl:for-each>
        </gmd:MD_MaintenanceInformation>
      </gmd:metadataMaintenance>
      <xsl:if test="//plainsid|//plmiinfo|//instinfo">
        <gmi:acquisitionInformation>
          <gmi:MI_AcquisitionInformation>
            <!-- MI_Instrument -->
            <xsl:choose>
              <xsl:when test="exists(//instinfo)">
                <xsl:for-each select="//instinfo[not(.=preceding::instinfo)]">
                  <gmi:instrument>
                    <gmi:MI_Instrument>
                      <xsl:for-each select=".//instref/citeinfo">
                        <gmi:citation>
                          <xsl:call-template name="CI_Citation"/>
                        </gmi:citation>
                      </xsl:for-each>
                      <gmi:identifier>
                        <gmd:MD_Identifier>
                          <gmd:code>
                            <gco:CharacterString>
                              <xsl:value-of select="instflnm"/>
                            </gco:CharacterString>
                          </gmd:code>
                        </gmd:MD_Identifier>
                      </gmi:identifier>
                      <xsl:choose>
                        <xsl:when test="instdesc/insttyp">
                          <gmi:type>
                            <gco:CharacterString>
                              <xsl:value-of select="normalize-space(instdesc/insttyp)"/>
                            </gco:CharacterString>
                          </gmi:type>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmi:type gco:nilReason="missing"/>
                        </xsl:otherwise>
                      </xsl:choose>
                      <xsl:if test="instdesc/opmode|instdesc/colltype|instdesc/instpdes|instdesc/othcolde">
                        <gmi:description>
                          <gco:CharacterString>
                            <xsl:if test="instdesc/opmode">Operation Mode: <xsl:value-of select="normalize-space(instdesc/opmode)"/>, </xsl:if>
                            <xsl:if test="instdesc/colltype">Collection Type: <xsl:value-of select="normalize-space(instdesc/colltype)"/></xsl:if>
                            <xsl:if test="instdesc/instpdes">, Properties Description: <xsl:value-of select="normalize-space(instdesc/instpdes)"/></xsl:if>
                            <xsl:if test="instdesc/othcolde">, Collection Description: <xsl:value-of select="normalize-space(instdesc/othcolde)"/></xsl:if>
                          </gco:CharacterString>
                        </gmi:description>
                      </xsl:if>
                    </gmi:MI_Instrument>
                  </gmi:instrument>
                  <xsl:if test="//instinfo/instdesc/scan">
                    <xsl:comment>Scan Description section not translated to ISO. FGDC Xpath: //instinfo/instdesc/scan</xsl:comment>
                  </xsl:if>
                  <xsl:if test="//instinfo/instdesc/orininfo">
                    <xsl:comment>Sensor Orientation section is not translated to ISO. FGDC Xpath: //instinfo/instdesc/orininfo</xsl:comment>
                  </xsl:if>
                  <xsl:if test="//instinfo/instdesc/fram">
                    <xsl:comment>Frame Camera Description section is not translated to ISO. FGDC Xpath: //instinfo/instdesc/frame</xsl:comment>
                  </xsl:if>
                </xsl:for-each>
              </xsl:when>
              <xsl:when test="//plainsid/instflnm">
                <xsl:for-each select="distinct-values(//plainsid/instflnm)">
                  <gmi:instrument>
                    <gmi:MI_Instrument>
                      <gmi:identifier>
                        <gmd:MD_Identifier>
                          <gmd:code>
                            <gco:CharacterString>
                              <xsl:value-of select="normalize-space(.)"/>
                            </gco:CharacterString>
                          </gmd:code>
                        </gmd:MD_Identifier>
                      </gmi:identifier>
                      <gmi:type gco:nilReason="missing"/>
                    </gmi:MI_Instrument>
                  </gmi:instrument>
                </xsl:for-each>
              </xsl:when>
            </xsl:choose>
            <!-- MI_Operation -->
            <xsl:choose>
              <xsl:when test="//plmiinfo/missinfo">
                <xsl:for-each select="//missinfo">
                  <gmi:operation>
                    <gmi:MI_Operation>
                      <xsl:if test="./missdesc">
                        <gmi:description>
                          <gco:CharacterString>
                            <xsl:value-of select="normalize-space(./missdesc)"/>
                          </gco:CharacterString>
                        </gmi:description>
                      </xsl:if>
                      <xsl:if test="//missinfo/misshist">
                        <xsl:comment>Mission History is translated to Data Quality > Lineage section of ISO. FGDC Xpath: //missinfo/misshist</xsl:comment>
                      </xsl:if>
                      <xsl:choose>
                        <xsl:when test="./missname">
                          <gmi:identifier>
                            <gmd:MD_Identifier>
                              <gmd:code>
                                <gco:CharacterString>
                                  <xsl:value-of select="normalize-space(./missname)"/>
                                </gco:CharacterString>
                              </gmd:code>
                            </gmd:MD_Identifier>
                          </gmi:identifier>
                          <!-- Added by ted habermann to included mission name from plainsid as well -->
                          <xsl:if test="//plainsid/missname">
                            <xsl:for-each select="//plainsid/missname">
                              <gmi:identifier>
                                <gmd:MD_Identifier>
                                  <gmd:code>
                                    <gco:CharacterString>
                                      <xsl:value-of select="normalize-space(.)"/>
                                    </gco:CharacterString>
                                  </gmd:code>
                                </gmd:MD_Identifier>
                              </gmi:identifier>
                            </xsl:for-each>
                          </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmi:identifier gco:nilReason="missing"/>
                        </xsl:otherwise>
                      </xsl:choose>
                      <xsl:choose>
                        <xsl:when test=".//misscomp">
                          <gmi:status>
                            <gmd:MD_ProgressCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#MD_ProgressCode" codeListValue="completed">completed</gmd:MD_ProgressCode>
                          </gmi:status>
                          <xsl:comment>Mission Completion Date is not translated to ISO. FGDC Xpath: //missinfo/misshist/misscomp</xsl:comment>
                          <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                          <xsl:copy-of select="//missinfo/misshist/misscomp"/>
                          <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmi:status gco:nilReason="unknown"/>
                        </xsl:otherwise>
                      </xsl:choose>
                      <gmi:parentOperation gco:nilReason="inapplicable"/>
                    </gmi:MI_Operation>
                  </gmi:operation>
                </xsl:for-each>
              </xsl:when>
              <xsl:when test="//plainsid/missname">
                <xsl:for-each select="distinct-values(//plainsid/missname)">
                  <gmi:operation>
                    <gmi:MI_Operation>
                      <gmi:identifier>
                        <gmd:MD_Identifier>
                          <gmd:code>
                            <gco:CharacterString>
                              <xsl:value-of select="normalize-space(.)"/>
                            </gco:CharacterString>
                          </gmd:code>
                        </gmd:MD_Identifier>
                      </gmi:identifier>
                      <gmi:status gco:nilReason="missing"/>
                      <gmi:parentOperation gco:nilReason="inapplicable"/>
                    </gmi:MI_Operation>
                  </gmi:operation>
                </xsl:for-each>
              </xsl:when>
            </xsl:choose>
            <!-- MI_Platform-->
            <xsl:choose>
              <xsl:when test="//plmiinfo/platinfo">
                 <xsl:for-each select="//platinfo">
                  <gmi:platform>
                    <gmi:MI_Platform>
                      <!--<xsl:choose>
                        <xsl:when test="platflnm">
                          <gmi:identifier>
                            <gmd:MD_Identifier>
                              <gmd:code>
                                <gco:CharacterString>
                                  <xsl:value-of select="platflnm"/>
                                </gco:CharacterString>
                              </gmd:code>
                            </gmd:MD_Identifier>
                          </gmi:identifier>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmi:identifier gco:nilReason="missing"/>
                        </xsl:otherwise>
                      </xsl:choose>-->
                      <!-- Added by Ted Habermann -->
                      <xsl:if test="//plainsid">
                        <xsl:for-each select="//platflnm">
                          <gmi:identifier>
                            <gmd:MD_Identifier>
                              <gmd:code>
                                <gco:CharacterString>
                                  <xsl:value-of select="normalize-space(concat(../platfsnm,'>',.))"/>
                                </gco:CharacterString>
                              </gmd:code>
                            </gmd:MD_Identifier>
                          </gmi:identifier>
                        </xsl:for-each>
                      </xsl:if>
                      <xsl:choose>
                        <xsl:when test="platdesc">
                          <gmi:description>
                            <gco:CharacterString>
                              <xsl:value-of select="normalize-space(platdesc)"/>
                            </gco:CharacterString>
                          </gmi:description>
                        </xsl:when>
                        <xsl:otherwise>
                          <gmi:description gco:nilReason="missing"/>
                        </xsl:otherwise>
                      </xsl:choose>
                      <xsl:for-each select="platspon">
                        <gmi:sponsor>
                          <gmd:CI_ResponsibleParty>
                            <gmd:organisationName>
                              <gco:CharacterString>
                                <xsl:value-of select="normalize-space(.)"/>
                              </gco:CharacterString>
                            </gmd:organisationName>
                            <gmd:role>
                              <gmd:CI_RoleCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#CI_RoleCode" codeListValue="sponsor">sponsor</gmd:CI_RoleCode>
                            </gmd:role>
                          </gmd:CI_ResponsibleParty>
                        </gmi:sponsor>
                      </xsl:for-each>
                      <gmi:instrument gco:nilReason="missing"/>
                      <xsl:if test=".//platstdt">
                        <xsl:comment> Platform Start Date not mapped to ISO. </xsl:comment>
                        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                        <xsl:copy-of select=".//platstdt"/>
                        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                      </xsl:if>
                      <xsl:if test=".//platforb">
                        <xsl:comment> Platform Orbit Description not mapped to ISO. </xsl:comment>
                        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                        <xsl:copy-of select=".//platforb"/>
                        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                      </xsl:if>
                      <xsl:if test=".//fltprot">
                        <xsl:comment> Flight Protocoal Description not mapped to ISO. </xsl:comment>
                        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
                        <xsl:copy-of select=".//fltprot"/>
                        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
                      </xsl:if>
                    </gmi:MI_Platform>
                  </gmi:platform>
                </xsl:for-each>
              </xsl:when>
              <xsl:when test="//plainsid/platflnm">                
                <xsl:for-each select="distinct-values(//platflnm)">
                  <gmi:platform>
                    <gmi:MI_Platform>
                      <gmi:identifier>
                        <gmd:MD_Identifier>
                          <gmd:code>
                            <gco:CharacterString>
                              <xsl:value-of select="normalize-space(.)"/>
                            </gco:CharacterString>
                          </gmd:code>
                        </gmd:MD_Identifier>
                      </gmi:identifier>
                      <gmi:description gco:nilReason="missing"/>
                      <gmi:instrument gco:nilReason="missing"/>
                    </gmi:MI_Platform>
                  </gmi:platform>
                </xsl:for-each>
              </xsl:when>
            </xsl:choose>
          </gmi:MI_AcquisitionInformation>
        </gmi:acquisitionInformation>
      </xsl:if>
    </gmi:MI_Metadata>
  </xsl:template>
  <xsl:template name="CI_Citation">
    <gmd:CI_Citation>
      <gmd:title>
        <gco:CharacterString>
          <xsl:sequence select="fn:normalize-space(xs:string(title))"/>
        </gco:CharacterString>
      </gmd:title>
      <gmd:date>
        <gmd:CI_Date>
          <gmd:date>
            <xsl:choose>
              <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(./pubdate))), 'unknown'))">
                <xsl:attribute name="gco:nilReason">
                  <xsl:sequence select="xs:string('unknown')"/>
                </xsl:attribute>
              </xsl:when>
              <xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(./pubdate))), 'unpublished material'))">
                <xsl:attribute name="gco:nilReason">
                  <xsl:sequence select="xs:string('inapplicable')"/>
                </xsl:attribute>
              </xsl:when>
              <xsl:when test="contains(lower-case(normalize-space(pubtime)), 'unknown')">
                <gco:Date>
                  <xsl:call-template name="fgdc2isoDate">
                    <xsl:with-param name="dateField" select="normalize-space(./pubdate)"/>
                  </xsl:call-template>
                </gco:Date>
              </xsl:when>
              <xsl:when test="pubtime">
                <gco:DateTime>
                  <xsl:call-template name="fgdc2isoDateTime">
                    <xsl:with-param name="dateField" select="normalize-space(./pubdate)"/>
                    <xsl:with-param name="timeField" select="normalize-space(pubtime)"/>
                  </xsl:call-template>
                </gco:DateTime>
              </xsl:when>
              <xsl:otherwise>
                <gco:Date>
                  <xsl:call-template name="fgdc2isoDate">
                    <xsl:with-param name="dateField" select="normalize-space(./pubdate)"/>
                  </xsl:call-template>
                </gco:Date>
              </xsl:otherwise>
            </xsl:choose>
          </gmd:date>
          <gmd:dateType>
            <gmd:CI_DateTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode" codeListValue="publication">publication</gmd:CI_DateTypeCode>
          </gmd:dateType>
        </gmd:CI_Date>
      </gmd:date>
      <xsl:for-each select="./edition">
        <gmd:edition>
          <gco:CharacterString>
            <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
          </gco:CharacterString>
        </gmd:edition>
      </xsl:for-each>
      <!--<gmd:editionDate/>-->
      <xsl:if test="citId">
        <gmd:identifier>
          <gmd:MD_Identifier>
            <gmd:code>
              <gco:CharacterString>
                <xsl:value-of select="normalize-space(citId)"/>
              </gco:CharacterString>
            </gmd:code>
          </gmd:MD_Identifier>
        </gmd:identifier>
      </xsl:if>
      <xsl:for-each select="./pubinfo">
        <gmd:citedResponsibleParty>
          <xsl:call-template name="CI_ResponsibleParty">
            <xsl:with-param name="role" select="'publisher'"/>
          </xsl:call-template>
        </gmd:citedResponsibleParty>
      </xsl:for-each>
      <xsl:for-each select="./origin">
        <gmd:citedResponsibleParty>
          <xsl:call-template name="CI_ResponsibleParty">
            <xsl:with-param name="role" select="'originator'"/>
          </xsl:call-template>
        </gmd:citedResponsibleParty>
      </xsl:for-each>
      <xsl:if test="onlink|CI_OnlineResource">
        <xsl:for-each select="onlink">
          <gmd:citedResponsibleParty>
            <gmd:CI_ResponsibleParty>
              <gmd:organisationName gco:nilReason="missing"/>
              <gmd:contactInfo>
                <gmd:CI_Contact>
                  <gmd:onlineResource>
                    <xsl:call-template name="CI_OnlineResource">
                      <xsl:with-param name="source" select="'citation'"/>
                    </xsl:call-template>
                  </gmd:onlineResource>
                </gmd:CI_Contact>
              </gmd:contactInfo>
              <gmd:role gco:nilReason="inapplicable"/>
            </gmd:CI_ResponsibleParty>
          </gmd:citedResponsibleParty>
        </xsl:for-each>
        <xsl:for-each select="./CI_OnlineResource">
          <gmd:citedResponsibleParty>
            <gmd:CI_ResponsibleParty>
              <gmd:organisationName gco:nilReason="withheld"/>
              <gmd:contactInfo>
                <gmd:CI_Contact>
                  <gmd:onlineResource>
                    <xsl:call-template name="CI_OnlineResource">
                      <xsl:with-param name="source" select="'CI_OnlineResource'"/>
                    </xsl:call-template>
                  </gmd:onlineResource>
                </gmd:CI_Contact>
              </gmd:contactInfo>
              <gmd:role gco:nilReason="inapplicable"/>
            </gmd:CI_ResponsibleParty>
          </gmd:citedResponsibleParty>
        </xsl:for-each>
      </xsl:if>
      <xsl:if test="./geoform">
        <gmd:presentationForm>
          <xsl:variable name="var277_cond_result_exists" as="xs:string?">
            <xsl:if test="./geoform">
              <xsl:for-each select="./geoform">
                <xsl:variable name="var288_result_vmf7_inputtoresult" as="xs:string?">
                  <xsl:call-template name="vmf:vmf7_inputtoresult">
                    <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
                  </xsl:call-template>
                </xsl:variable>
                <xsl:if test="fn:exists($var288_result_vmf7_inputtoresult)">
                  <xsl:sequence select="$var288_result_vmf7_inputtoresult"/>
                </xsl:if>
              </xsl:for-each>
            </xsl:if>
          </xsl:variable>
          <xsl:if test="fn:exists($var277_cond_result_exists)">
            <gmd:CI_PresentationFormCode>
              <xsl:variable name="var278_cond_result_exists" as="xs:string?" select="(if (fn:exists(./geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
              <xsl:if test="fn:exists($var278_cond_result_exists)">
                <xsl:attribute name="codeList">
                  <xsl:sequence select="xs:string(($var278_cond_result_exists))"/>
                </xsl:attribute>
              </xsl:if>
              <xsl:attribute name="codeListValue">
                <xsl:sequence select="xs:string(($var277_cond_result_exists))"/>
              </xsl:attribute>
              <xsl:sequence select="$var277_cond_result_exists"/>
            </gmd:CI_PresentationFormCode>
          </xsl:if>
        </gmd:presentationForm>
      </xsl:if>
      <xsl:for-each select="./serinfo">
        <gmd:series>
          <gmd:CI_Series>
            <gmd:name>
              <gco:CharacterString>
                <xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
              </gco:CharacterString>
            </gmd:name>
            <gmd:issueIdentification>
              <gco:CharacterString>
                <xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
              </gco:CharacterString>
            </gmd:issueIdentification>
          </gmd:CI_Series>
        </gmd:series>
      </xsl:for-each>
      <xsl:for-each select="./othercit">
        <gmd:otherCitationDetails>
          <gco:CharacterString>
            <xsl:sequence select="fn:normalize-space(xs:string(.))"/>
          </gco:CharacterString>
        </gmd:otherCitationDetails>
      </xsl:for-each>
      <!-- <gmd:collectiveTitle/>
      <gmd:ISBN/>
      <gmd:ISSN/>-->
    </gmd:CI_Citation>
  </xsl:template>
  <xsl:template name="idTransform">
    <xsl:variable name="id">
      <xsl:value-of select="translate(normalize-space(./srccitea),' ()/,&amp;'':','_')"/>
    </xsl:variable>
    <xsl:attribute name="id">
      <xsl:value-of select="concat('_',$id)"/>
    </xsl:attribute>
    <!--  Added translation of ' ' to '_' and drop parentheses, slash, comma, colon, &.  -->
  </xsl:template>
  <!--CI_ResponsibleParty-->
  <xsl:template name="CI_ResponsibleParty">
    <xsl:param name="role"/>
    <gmd:CI_ResponsibleParty>
      <!-- citation publisher -->
      <xsl:choose>
        <xsl:when test="$role='publisher'">
          <gmd:organisationName>
            <gco:CharacterString>
              <xsl:value-of select="publish"/>
            </gco:CharacterString>
          </gmd:organisationName>
          <gmd:contactInfo>
            <gmd:CI_Contact>
              <gmd:address>
                <gmd:CI_Address>
                  <xsl:if test="contains(pubplace, ',')">
                    <gmd:city>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:substring-before(xs:string(pubplace), ',')"/>
                      </gco:CharacterString>
                    </gmd:city>
                    <gmd:administrativeArea>
                      <gco:CharacterString>
                        <xsl:sequence select="fn:substring-after(xs:string(pubplace), ',')"/>
                      </gco:CharacterString>
                    </gmd:administrativeArea>
                  </xsl:if>
                  <xsl:if test="not(contains(pubplace, ','))">
                    <gmd:administrativeArea>
                      <gco:CharacterString>
                        <xsl:sequence select="normalize-space(pubplace)"/>
                      </gco:CharacterString>
                    </gmd:administrativeArea>
                  </xsl:if>
                </gmd:CI_Address>
              </gmd:address>
            </gmd:CI_Contact>
          </gmd:contactInfo>
        </xsl:when>
        <!-- citation//origin -->
        <xsl:when test="$role='originator'">
          <gmd:organisationName>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:organisationName>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="Contact2ResponsibleParty"/>
        </xsl:otherwise>
      </xsl:choose>
      <gmd:role>
        <gmd:CI_RoleCode>
          <xsl:attribute name="codeList" select="'http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#CI_RoleCode'"/>
          <xsl:attribute name="codeListValue">
            <xsl:value-of select="$role"/>
          </xsl:attribute>
          <xsl:value-of select="$role"/>
        </gmd:CI_RoleCode>
      </gmd:role>
    </gmd:CI_ResponsibleParty>
  </xsl:template>
  <xsl:template name="Contact2ResponsibleParty">
    <xsl:for-each select=".//cntper">
      <gmd:individualName>
        <gco:CharacterString>
          <xsl:value-of select="normalize-space(.)"/>
        </gco:CharacterString>
      </gmd:individualName>
    </xsl:for-each>
    <xsl:for-each select=".//cntorg">
      <gmd:organisationName>
        <gco:CharacterString>
          <xsl:value-of select="normalize-space(.)"/>
        </gco:CharacterString>
      </gmd:organisationName>
    </xsl:for-each>
    <xsl:for-each select=".//cntpos">
      <gmd:positionName>
        <gco:CharacterString>
          <xsl:value-of select="normalize-space(.)"/>
        </gco:CharacterString>
      </gmd:positionName>
    </xsl:for-each>
    <gmd:contactInfo>
      <gmd:CI_Contact>
        <xsl:choose>
          <xsl:when test=".//cntvoice or .//cntfax">
            <gmd:phone>
              <gmd:CI_Telephone>
                <xsl:for-each select=".//cntvoice">
                  <gmd:voice>
                    <gco:CharacterString>
                      <xsl:value-of select="normalize-space(.)"/>
                    </gco:CharacterString>
                  </gmd:voice>
                </xsl:for-each>
                <xsl:for-each select=".//cntfax">
                  <gmd:facsimile>
                    <gco:CharacterString>
                      <xsl:value-of select="normalize-space(.)"/>
                    </gco:CharacterString>
                  </gmd:facsimile>
                </xsl:for-each>
              </gmd:CI_Telephone>
            </gmd:phone>
          </xsl:when>
        </xsl:choose>
        <xsl:choose>
          <xsl:when test=".//cntaddr">
            <xsl:for-each select=".//cntaddr[1]">
              <gmd:address>
                <gmd:CI_Address>
                  <xsl:for-each select=".//address">
                    <gmd:deliveryPoint>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:deliveryPoint>
                  </xsl:for-each>
                  <xsl:for-each select=".//city">
                    <gmd:city>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:city>
                  </xsl:for-each>
                  <xsl:for-each select=".//state">
                    <gmd:administrativeArea>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:administrativeArea>
                  </xsl:for-each>
                  <xsl:for-each select=".//postal">
                    <gmd:postalCode>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:postalCode>
                  </xsl:for-each>
                  <xsl:for-each select=".//country">
                    <gmd:country>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:country>
                  </xsl:for-each>
                  <xsl:for-each select="../cntemail">
                    <gmd:electronicMailAddress>
                      <gco:CharacterString>
                        <xsl:value-of select="normalize-space(.)"/>
                      </gco:CharacterString>
                    </gmd:electronicMailAddress>
                  </xsl:for-each>
                </gmd:CI_Address>
              </gmd:address>
            </xsl:for-each>
          </xsl:when>
          <xsl:when test="..//cntemail">
            <gmd:address>
              <gmd:CI_Address>
                <xsl:for-each select="..//cntemail">
                  <gmd:electronicMailAddress>
                    <gco:CharacterString>
                      <xsl:value-of select="normalize-space(.)"/>
                    </gco:CharacterString>
                  </gmd:electronicMailAddress>
                </xsl:for-each>
              </gmd:CI_Address>
            </gmd:address>
          </xsl:when>
        </xsl:choose>
        <xsl:for-each select=".//hours">
          <gmd:hoursOfService>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:hoursOfService>
        </xsl:for-each>
        <xsl:for-each select=".//cntinst">
          <gmd:contactInstructions>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:contactInstructions>
        </xsl:for-each>
      </gmd:CI_Contact>
    </gmd:contactInfo>
  </xsl:template>
  <xsl:template name="CI_OnlineResource">
    <xsl:param name="source"/>
    <!--<xsl:comment>source: <xsl:value-of select="$source"/></xsl:comment>-->
    <xsl:if test="$source='citation'">
      <gmd:CI_OnlineResource>
        <gmd:linkage>
          <gmd:URL>
            <xsl:value-of select="normalize-space(.)"/>
          </gmd:URL>
        </gmd:linkage>
      </gmd:CI_OnlineResource>
    </xsl:if>
    <xsl:if test="$source='networkr'">
      <gmd:CI_OnlineResource>
        <gmd:linkage>
          <gmd:URL>
            <xsl:value-of select="normalize-space(.)"/>
          </gmd:URL>
        </gmd:linkage>
      </gmd:CI_OnlineResource>
    </xsl:if>
    <xsl:if test="$source='CI_OnlineResource'">
      <gmd:CI_OnlineResource>
        <gmd:linkage>
          <gmd:URL>
            <xsl:value-of select="normalize-space(linkage)"/>
          </gmd:URL>
        </gmd:linkage>
        <xsl:for-each select="protocol">
          <gmd:protocol>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:protocol>
        </xsl:for-each>
        <xsl:for-each select="applicationProfile">
          <gmd:applicationProfile>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:applicationProfile>
        </xsl:for-each>
        <xsl:for-each select="name">
          <gmd:name>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:name>
        </xsl:for-each>
        <xsl:for-each select="description">
          <gmd:description>
            <gco:CharacterString>
              <xsl:value-of select="normalize-space(.)"/>
            </gco:CharacterString>
          </gmd:description>
        </xsl:for-each>
        <xsl:for-each select="function">
          <gmd:function>
            <xsl:variable name="function">
              <xsl:call-template name="functionCode">
                <xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
              </xsl:call-template>
            </xsl:variable>
            <gmd:CI_OnLineFunctionCode>
              <xsl:attribute name="codeList">http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#CI_OnLineFunctionCode</xsl:attribute>
              <xsl:attribute name="codeListValue">
                <xsl:value-of select="$function"/>
              </xsl:attribute>
              <xsl:value-of select="$function"/>
            </gmd:CI_OnLineFunctionCode>
          </gmd:function>
        </xsl:for-each>
      </gmd:CI_OnlineResource>
    </xsl:if>
  </xsl:template>
  <xsl:template name="fgdc2isoDate">
    <xsl:param name="dateField"/>
    <xsl:variable name="dateVar" as="xs:string">
      <xsl:choose>
        <xsl:when test="string-length($dateField)=6">
          <xsl:value-of select="concat($dateField,'01')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=4">
          <xsl:value-of select="concat($dateField,'0101')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=8 and substring($dateField,5,4)='0000'">
          <!-- Added by Ted Habermann to deal with dates like 19990000 -->
          <xsl:value-of select="concat(substring($dateField,1,4),'0101')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=8 and substring($dateField,7,2)='00'">
          <!-- Added by Ted Habermann to deal with dates like 19990500 -->
          <xsl:value-of select="concat(substring($dateField,1,6),'01')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=8">
          <xsl:value-of select="$dateField"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="99990101"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="Year">
      <xsl:value-of select="number(substring($dateVar,1,4))"/>
    </xsl:variable>
    <xsl:variable name="Month">
      <xsl:variable name="tempMonth">
        <xsl:value-of select="number(substring($dateVar,5, 2))"/>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="string-length($tempMonth) &lt; 2">
          <xsl:value-of select="concat(0,$tempMonth)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$tempMonth"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="Day">
      <xsl:variable name="tempDay">
        <xsl:value-of select="number(substring($dateVar,7, 2))"/>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="string-length($tempDay) &lt; 2">
          <xsl:value-of select="concat(0,$tempDay)"/>
        </xsl:when>
        <xsl:when test="$tempDay = '00'">
          <!-- Added by Ted Habermann to deal with dates of 00 -->
          <xsl:value-of select="'01'"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$tempDay"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="dateISO">
      <xsl:value-of select="concat($Year,'-',$Month,'-',$Day)"/>
    </xsl:variable>
    <xsl:value-of select="$dateISO"/>
  </xsl:template>
  <xsl:template name="fgdc2isoDateTime">
    <!-- todo: translate FGDC time field if exists -->
    <xsl:param name="dateField"/>
    <xsl:param name="timeField"/>
    <xsl:variable name="dateVar" as="xs:string">
      <xsl:choose>
        <xsl:when test="string-length($dateField)=6">
          <xsl:value-of select="concat($dateField,'01')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=4">
          <xsl:value-of select="concat($dateField,'0101')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=8 and substring($dateField,5,4)='0000'">
          <xsl:value-of select="concat(substring($dateField,1,4),'0101')"/>
        </xsl:when>
        <xsl:when test="string-length($dateField)=8">
          <xsl:value-of select="$dateField"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="99990101"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="Year">
      <xsl:value-of select="number(substring($dateVar,1,4))"/>
    </xsl:variable>
    <xsl:variable name="Month">
      <xsl:variable name="tempMonth">
        <xsl:value-of select="number(substring($dateVar,5, 2))"/>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="string-length($tempMonth) &lt; 2">
          <xsl:value-of select="concat(0,$tempMonth)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$tempMonth"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="Day">
      <xsl:variable name="tempDay">
        <xsl:value-of select="substring($dateVar,7, 2)"/>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="string-length($tempDay) &lt; 2">
          <xsl:value-of select="concat(0,$tempDay)"/>
        </xsl:when>
        <xsl:when test="$tempDay = '00'">
          <!-- Added by Ted Habermann to deal with dates of 00 -->
          <xsl:value-of select="'01'"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$tempDay"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="dateISO">
      <xsl:value-of select="concat($Year,'-',$Month,'-',$Day)"/>
    </xsl:variable>
    <!--
      Time variable manipulation started by Ted Habermann for specific cases
      Definitely not comprehensive
    -->
    <xsl:variable name="timeVar" as="xs:string">
      <xsl:choose>
        <xsl:when test="string-length($timeField)=6 and not(contains($timeField,':'))">      		
      	 <xsl:value-of select="concat(substring($timeField,1,2),':',substring($timeField,3,2),':',substring($timeField,5,2))"/>
        </xsl:when>
        <xsl:when test="string-length($timeField)=8 and contains($timeField,':')">
          <xsl:value-of select="$timeField"/>
        </xsl:when>
        <xsl:when test="string-length($timeField)=8 and substring($timeField,7,2)='00'">
          <xsl:value-of select="concat(substring($timeField,1,2),':',substring($timeField,3,2),':',substring($timeField,5,2))"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="'00:00:00'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:value-of select="concat($dateISO,'T',$timeVar)"/>
  </xsl:template>
</xsl:stylesheet>
