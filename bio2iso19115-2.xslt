<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	FGDC Biological Profile to ISO 19115-2 Transform using XPath 2.0 January 2013

	This is the XML Style sheet that transforms metadata conforming to the Biological Profile of the Content Standards
	for Digital Geospatial Metadata of the Federal Geographic Data Committee FGDC-STD-001.1-1999 version to the 
	ISO 19115-2:2009(E).  This stylesheet can be applied to FGDC BIO XML to generate ISO 19115-2 XML with the NBII 
	Biological Metadata Extensions.

	This file was generated by Altova MapForce 2009sp1

	Authors:
	This is the result of a collaboration of the Metadata Transform Working Group. 
	For further information, please contact NOAA's National Coastal Data 
	Development Center (NCDDC).
				National Coastal Data Development Center
				Toll Free: 866.732.2382
				E-mail: ncddcmetadata@noaa.gov

	Distribution Liability:
		NOAA makes no warranty regarding these data, expressed or implied, 
		nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		NODC and NCDDC cannot assume liability for any damages caused by any 
		errors or omissions in these data, nor as a result of the failure of these data 
		to function on a particular system. These files were developed for opensource uses.
	
	Use Constraints:
		The user is responsible for the results of any application of these transforms for other than its
		intended purpose. These transforms cannot guarantee valid output. Additional editing
		may need to be done in order to have valid records. The intent of these transforms is
		to get as much of the FGDC valid content mapped to ISO content as possible but cannot 
		guarantee against loss of information. Please feel free to edit transforms as needed for 
		your organizations needs. 

	Revisions:
	    	 20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to their proper namespace. 
		20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
		20100323 (JLM) Repeatability issues (repeating at characterString level instead
							 of attribute level) were fixed with grouping. Stratum Keyword 
							 thesauri and keywords were corrected. These elements were 
							 switched in the previous mappings. 'Unknown' was added as default
							 value to Spatial Rep. transformation parameter ability. 'Unknown' was 
							 added a default for mandatory fields that did not have content exist in
							 the FGDC source record. Extra spaces were removed from dates. 
		20100407 (JLM) Cleaned up the dates and also removed un-used elements.
		20100503 (JLM) Changed the MD_ root to MI_ to be more interoperable. Also 
							 added fileIdentifier.
		20100512 (JLM) Normalized spaces to clean up text. 
		20100721 (JLM) Added Extent ids.
	   	20100802 (JLM) Removed line that prohibited creation of taxon info when un-man FGDC 
							 element was not used. Added value-false content if Distribtuion Liability 
							 Statement DNE. 
		20100811 (JLM) Removed mapping of onlink linkage to datasetURI, instead mapped to 
							 Dist Info linkage URL. 
		20100223 (JLM) Corrected for error not mapping otherConstraints. Corrected error to
							 repeat at gmd:distributionFormat instead of name and version. Changed 
							 language from 'eng' to 'eng; USA'. Corrected ISO name and version.
							 Made allowances for srcscal = "unknown". 
		20100917 (JLM) Used updated ISO bio schema and edited transform for changes to 
							 schema tags. All changes took place at gmd:taxonomy.
		20110210 (JLM) Added logic to remove number values from Topic Category. 
		20110224 (JLM) Fixed keyword issues. Added spatial representation type code content between 
							 tags. 'Entity and Attribute Information' was added as the default title value for 
							 feature catalogue citation.'unknown' was added as default date for feature catalogue 
							 citation. Updated metadata standard name and version to use best practices. Added 
							 role to aggregation information responsible party. Corrected codeList in aggregation
							 information. Deleted empty element tags. If reference system RS_Identifier code
							 was missing, set the default value to 'unknown'. Moved EX_BoundingPolygon id 
							 to Polygon id. Corrected report issues in data quality. Corrected date/time issues.
		20110225 (KAM) Added logic to hardcode nilReason 'unknown' if idref in taxonomic system does not exist.
		20110419 (JLM) Corrected online resource and distribution info issues. Corrected cross reference
							 date/time issues. Added which version of transform was used in metadata maintenance.
		20110502 (JLM) Corrected sequencing for taxon keywords.  Corrected issues found when there were
							 multiple source dates within lineage. 
		20110617 (JLM) Corrected the hardcoding of "Unknown" to "unknown" for nilReason. Corrected repeatability 
							 of MD_Constraints if both metadata legal and security constraints exist. Added mapping from 
							 spref>horizsys>geograph to spatialRepresentationInfo>MD_GridSpatialRep. Corrected error 
							 produced if cloud cover percentage is a number or if it contains "Unknown". Corrected location 
							 of temporal extent IDs.  Corrected Dist Info and online linkages. Corrected publisher information 
							 not displaying in data identification. Corrected planned available date/times not showing (unknown 
							 times will not display,  that is an optional field).  Removed FGDC extension  information from mapping. 
							 Added maintenance note about spatial ref. Corrected bounding coordinates from type double 
							 (in FGDC) to type decimal (in ISO) to prevent the addition of extra decimal spaces. Added mapping of 
							 cross reference publisher info. Added mapping of cross reference online link. 
		20111115 (JLM) Added other domain values to the value map between geographic coordinate units and resolution scale uom. Previously only "Decimal
							 degrees" would map.
		20120629 (JLM) Added some spatial reference logic to add components to reference system info.
		20130124 (JLM) Updated mapping of attraccr (was not mapping previously if quattracc was missing) to create a new data quality report at DQ_NonQuantitativeAttributeAccuracy>measureDescription and using nilReason=inapplicable result.
-->

<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmi="http://www.isotc211.org/2005/gmi" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.isotc211.org/2005/gmi">
	<xsl:template name="vmf:vmf1_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf2_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf3_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf4_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf5_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='Decimal degrees'">
				<xsl:value-of select="'decimalDegrees'"/>
			</xsl:when>
			<xsl:when test="$input='Decimal minutes'">
				<xsl:value-of select="'decimalMinutes'"/>
			</xsl:when>
			<xsl:when test="$input='Decimal seconds'">
				<xsl:value-of select="'decimalSeconds'"/>
			</xsl:when>
			<xsl:when test="$input='Degrees and decimal minutes'">
				<xsl:value-of select="'degreesAndDecimalMinutes'"/>
			</xsl:when>
			<xsl:when test="$input='Degrees, minutes, and decimal seconds'">
				<xsl:value-of select="'degreesMinutesAndDecimalSeconds'"/>
			</xsl:when>
			<xsl:when test="$input='Radians'">
				<xsl:value-of select="'radians'"/>
			</xsl:when>
			<xsl:when test="$input='Grads'">
				<xsl:value-of select="'grads'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf6_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf7_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf8_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf9_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf10_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf11_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf12_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf13_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf14_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf15_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf16_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf17_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='farming'">
				<xsl:value-of select="'farming'"/>
			</xsl:when>
			<xsl:when test="$input='biota'">
				<xsl:value-of select="'biota'"/>
			</xsl:when>
			<xsl:when test="$input='boundaries'">
				<xsl:value-of select="'boundaries'"/>
			</xsl:when>
			<xsl:when test="$input='climatologymeteorologyatmosphere'">
				<xsl:value-of select="'climatologyMeteorologyAtmosphere'"/>
			</xsl:when>
			<xsl:when test="$input='economy'">
				<xsl:value-of select="'economy'"/>
			</xsl:when>
			<xsl:when test="$input='elevation'">
				<xsl:value-of select="'elevation'"/>
			</xsl:when>
			<xsl:when test="$input='environment'">
				<xsl:value-of select="'environment'"/>
			</xsl:when>
			<xsl:when test="$input='geoscientificinformation'">
				<xsl:value-of select="'geoscientificInformation'"/>
			</xsl:when>
			<xsl:when test="$input='health'">
				<xsl:value-of select="'health'"/>
			</xsl:when>
			<xsl:when test="$input='imagerybasemapsearthcover'">
				<xsl:value-of select="'imageryBaseMapsEarthCover'"/>
			</xsl:when>
			<xsl:when test="$input='intelligencemilitary'">
				<xsl:value-of select="'intelligenceMilitary'"/>
			</xsl:when>
			<xsl:when test="$input='inlandwaters'">
				<xsl:value-of select="'inlandWaters'"/>
			</xsl:when>
			<xsl:when test="$input='location'">
				<xsl:value-of select="'location'"/>
			</xsl:when>
			<xsl:when test="$input='oceans'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
			<xsl:when test="$input='planningcadastre'">
				<xsl:value-of select="'planningCadastre'"/>
			</xsl:when>
			<xsl:when test="$input='society'">
				<xsl:value-of select="'society'"/>
			</xsl:when>
			<xsl:when test="$input='structure'">
				<xsl:value-of select="'structure'"/>
			</xsl:when>
			<xsl:when test="$input='transportation'">
				<xsl:value-of select="'transportation'"/>
			</xsl:when>
			<xsl:when test="$input='utilitiescommunication'">
				<xsl:value-of select="'utilitiesCommunication'"/>
			</xsl:when>
			<xsl:when test="$input='ocean'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf18_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf19_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf20_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf21_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<xsl:function name="grp:key1a877320">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:sequence select="xs:string(xs:token(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key1a49e9d0">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:template match="/">
		<gmi:MI_Metadata>
			<xsl:attribute name="xsi:schemaLocation" separator=" ">
				<xsl:sequence select="'http://www.isotc211.org/2005/gmi ftp://ftp.ncddc.noaa.gov/pub/Metadata/Online_ISO_Training/Intro_to_ISO/schemas/ISObio/schema.xsd'"/>
			</xsl:attribute>
			<xsl:variable name="var1_instance" as="node()" select="."/>
			<gmd:fileIdentifier>
				<xsl:for-each select="$var1_instance/metadata">
					<gco:CharacterString>
						<xsl:sequence select="fn:concat('gov.noaa.nodc.ncddc.', fn:substring-before(fn:base-uri(.), '.xml'))"/>
					</gco:CharacterString>
				</xsl:for-each>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>
					<xsl:sequence select="'eng; USA'"/>
				</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('utf8'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
					</xsl:attribute>
					<xsl:sequence select="'utf8'"/>
				</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('dataset'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
					</xsl:attribute>
					<xsl:sequence select="'dataset'"/>
				</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<xsl:variable name="var5_map_select_metadata" as="xs:string?">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var4_cond_result_exists" as="xs:string?">
						<xsl:choose>
							<xsl:when test="fn:exists($var5_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:if test="fn:exists($var4_cond_result_exists)">
						<gmd:individualName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space($var4_cond_result_exists)"/>
							</gco:CharacterString>
						</gmd:individualName>
					</xsl:if>
					<xsl:variable name="var14_map_select_metadata" as="xs:string?">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var13_cond_result_exists" as="xs:string?">
						<xsl:choose>
							<xsl:when test="fn:exists($var14_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:if test="fn:exists($var13_cond_result_exists)">
						<gmd:organisationName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space($var13_cond_result_exists)"/>
							</gco:CharacterString>
						</gmd:organisationName>
					</xsl:if>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
							</gco:CharacterString>
						</gmd:positionName>
					</xsl:for-each>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<gmd:phone>
								<gmd:CI_Telephone>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var26_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:voice>
											<gco:CharacterString>
												<xsl:sequence select="$var26_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:voice>
									</xsl:for-each-group>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var30_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:facsimile>
											<gco:CharacterString>
												<xsl:sequence select="$var30_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:facsimile>
									</xsl:for-each-group>
								</gmd:CI_Telephone>
							</gmd:phone>
							<xsl:for-each select="$var1_instance/metadata">
								<xsl:variable name="var32_metadata" as="node()" select="."/>
								<xsl:for-each select="metainfo/metc/cntinfo/cntaddr">
									<gmd:address>
										<gmd:CI_Address>
											<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var38_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:deliveryPoint>
													<gco:CharacterString>
														<xsl:sequence select="$var38_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:deliveryPoint>
											</xsl:for-each-group>
											<gmd:city>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
												</gco:CharacterString>
											</gmd:city>
											<gmd:administrativeArea>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
												</gco:CharacterString>
											</gmd:administrativeArea>
											<gmd:postalCode>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
												</gco:CharacterString>
											</gmd:postalCode>
											<xsl:for-each select="country">
												<gmd:country>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:country>
											</xsl:for-each>
											<xsl:for-each-group select="$var32_metadata/metainfo/metc/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var44_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:electronicMailAddress>
													<gco:CharacterString>
														<xsl:sequence select="$var44_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:electronicMailAddress>
											</xsl:for-each-group>
										</gmd:CI_Address>
									</gmd:address>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
								<gmd:hoursOfService>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:hoursOfService>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
								<gmd:contactInstructions>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:contactInstructions>
							</xsl:for-each>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<gmd:role>
						<gmd:CI_RoleCode>
							<xsl:attribute name="codeList">
								<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeListValue">
								<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeSpace">
								<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
							</xsl:attribute>
							<xsl:sequence select="'pointOfContact'"/>
						</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:for-each select="$var1_instance/metadata">
					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished'))">
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd))))))"/>
						</xsl:attribute>
					</xsl:if>
				</xsl:for-each>
				<xsl:for-each select="$var1_instance/metadata">
					<xsl:variable name="var55_cond_result_logicalor" as="xs:string?">
						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'present')))">
							<xsl:variable name="var60_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(fn:string(metainfo/metd)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
									<xsl:choose>
										<xsl:when test="fn:ends-with(., '-')">
											<xsl:if test="fn:ends-with(., '-')">
												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
												</xsl:if>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="."/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var59_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values($var60_map_result_distinctvalues)">
									<xsl:variable name="var65_cond_result_endswith" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
													</xsl:if>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var65_cond_result_endswith)">
										<xsl:sequence select="$var65_cond_result_endswith"/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:exists($var59_map_result_distinctvalues)">
								<xsl:sequence select="fn:string-join($var59_map_result_distinctvalues, ' ')"/>
							</xsl:if>
						</xsl:if>
					</xsl:variable>
					<xsl:for-each select="$var55_cond_result_logicalor">
						<gco:Date>
							<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
						</gco:Date>
					</xsl:for-each>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:sequence select="'ISO 19115-2 Geographic Information - Metadata - Part 2: Extensions for Imagery and Gridded Data with Biological Extensions'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:sequence select="'ISO 19115-2:2009(E)'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var72_metadata" as="node()" select="."/>
				<xsl:for-each select="spdoinfo">
					<gmd:spatialRepresentationInfo>
						<xsl:for-each select="rastinfo">
							<xsl:variable name="var76_rastinfo" as="node()" select="."/>
							<gmd:MD_GridSpatialRepresentation>
								<gmd:numberOfDimensions>
									<xsl:variable name="var78_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(rowcount)) then xs:decimal(1) else ())"/>
									<xsl:if test="fn:exists($var78_cond_result_exists)">
										<xsl:variable name="var79_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(colcount)) then xs:decimal(1) else ())"/>
										<xsl:if test="fn:exists($var79_cond_result_exists)">
											<xsl:variable name="var80_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(vrtcount)) then xs:decimal(1) else ())"/>
											<xsl:if test="fn:exists($var80_cond_result_exists)">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer((($var78_cond_result_exists + $var79_cond_result_exists) + $var80_cond_result_exists)))"/>
												</gco:Integer>
											</xsl:if>
										</xsl:if>
									</xsl:if>
								</gmd:numberOfDimensions>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var83_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then 'row' else ())"/>
												<xsl:if test="fn:exists($var83_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var84_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var84_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var84_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var83_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var85_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/rowcount)) then '001' else ())"/>
														<xsl:if test="fn:exists($var85_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var85_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var83_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/rowcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var90_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then 'column' else ())"/>
												<xsl:if test="fn:exists($var90_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var91_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var91_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var91_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var90_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var92_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/colcount)) then '002' else ())"/>
														<xsl:if test="fn:exists($var92_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var92_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var90_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/colcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var97_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then 'vertical' else ())"/>
												<xsl:if test="fn:exists($var97_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var98_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var98_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var98_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var97_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var99_cond_result_exists" as="xs:string?" select="(if (fn:exists($var76_rastinfo/vrtcount)) then '003' else ())"/>
														<xsl:if test="fn:exists($var99_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var99_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var97_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var76_rastinfo/vrtcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<gmd:cellGeometry>
									<xsl:variable name="var105_result_vmf1_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf1_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var102_cond_result_exists" as="xs:string?" select="(if (fn:exists($var105_result_vmf1_inputtoresult)) then $var105_result_vmf1_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var102_cond_result_exists)">
										<gmd:MD_CellGeometryCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var102_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var104_result_vmf2_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf2_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(rasttype)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var103_cond_result_exists" as="xs:string?" select="(if (fn:exists($var104_result_vmf2_inputtoresult)) then $var104_result_vmf2_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var103_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var103_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var102_cond_result_exists"/>
										</gmd:MD_CellGeometryCode>
									</xsl:if>
								</gmd:cellGeometry>
								<gmd:transformationParameterAvailability>
									<xsl:variable name="var106_cond_result_exists" as="xs:string?" select="(if (fn:exists(rowcount)) then 'unknown' else ())"/>
									<xsl:if test="fn:exists($var106_cond_result_exists)">
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string($var106_cond_result_exists))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:transformationParameterAvailability>
							</gmd:MD_GridSpatialRepresentation>
						</xsl:for-each>
						<xsl:for-each select="ptvctinf">
							<xsl:variable name="var107_ptvctinf" as="node()" select="."/>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="vpfterm">
									<gmd:topologyLevel>
										<gmd:MD_TopologyLevelCode>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(fn:string(vpflevel))))"/>
											</xsl:attribute>
										</gmd:MD_TopologyLevelCode>
									</gmd:topologyLevel>
								</xsl:for-each>
								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<xsl:variable name="var134_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm">
													<xsl:sequence select="fn:string(sdtstype)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var111_cond_result_exists" as="xs:string?">
												<xsl:if test="fn:exists($var134_map_select_sdtsterm)">
													<xsl:variable name="var136_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var134_map_select_sdtsterm)">
																<xsl:variable name="var142_map_select_sdtsterm" as="xs:string*">
																	<xsl:for-each select="sdtsterm">
																		<xsl:if test="fn:exists($var134_map_select_sdtsterm)">
																			<xsl:sequence select="fn:string(sdtstype)"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var142_map_select_sdtsterm)">
																	<xsl:sequence select="fn:string-join($var142_map_select_sdtsterm, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="vpfterm">
																	<xsl:sequence select="fn:string(vpflevel)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var136_cond_result_exists">
														<xsl:variable name="var139_result_vmf3_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf3_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var139_result_vmf3_inputtoresult)">
															<xsl:sequence select="$var139_result_vmf3_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var111_cond_result_exists)">
												<gmd:MD_GeometricObjectTypeCode>
													<xsl:variable name="var112_map_select_vpfterm" as="xs:string?">
														<xsl:for-each select="vpfterm">
															<xsl:sequence select="fn:string(vpflevel)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var113_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm">
															<xsl:sequence select="fn:string(sdtstype)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string((if ((fn:exists($var113_map_select_sdtsterm) or fn:exists($var112_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(fn:string($var111_cond_result_exists)))"/>
													</xsl:attribute>
													<xsl:variable name="var119_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm">
															<xsl:sequence select="fn:string(sdtstype)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var118_cond_result_exists" as="xs:string?">
														<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
															<xsl:variable name="var121_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var119_map_select_sdtsterm)">
																		<xsl:variable name="var127_map_select_sdtsterm" as="xs:string*">
																			<xsl:for-each select="sdtsterm">
																				<xsl:if test="fn:exists($var119_map_select_sdtsterm)">
																					<xsl:sequence select="fn:string(sdtstype)"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var127_map_select_sdtsterm)">
																			<xsl:sequence select="fn:string-join($var127_map_select_sdtsterm, ' ')"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="vpfterm">
																			<xsl:sequence select="fn:string(vpflevel)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var121_cond_result_exists">
																<xsl:variable name="var124_result_vmf4_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf4_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:if test="fn:exists($var124_result_vmf4_inputtoresult)">
																	<xsl:sequence select="$var124_result_vmf4_inputtoresult"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var118_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string($var118_cond_result_exists)))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="fn:string($var111_cond_result_exists)"/>
												</gmd:MD_GeometricObjectTypeCode>
											</xsl:if>
										</gmd:geometricObjectType>
										<gmd:geometricObjectCount>
											<xsl:variable name="var152_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm/ptvctcnt">
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var149_cond_result_exists" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists($var152_map_select_sdtsterm)">
														<xsl:for-each select="sdtsterm/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="vpfterm/vpfinfo/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var149_cond_result_exists">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:geometricObjectCount>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
							</gmd:MD_VectorSpatialRepresentation>
						</xsl:for-each>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var160_metadata" as="node()" select="."/>
				<xsl:for-each select="spref/horizsys/geograph">
					<gmd:spatialRepresentationInfo>
						<gmd:MD_GridSpatialRepresentation>
							<gmd:numberOfDimensions>
								<gco:Integer>
									<xsl:sequence select="xs:string(xs:integer(xs:decimal(2)))"/>
								</gco:Integer>
							</gmd:numberOfDimensions>
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('column'))"/>
											</xsl:attribute>
											<xsl:sequence select="'column'"/>
										</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:dimensionSize>
									<gmd:resolution>
										<gco:Scale>
											<xsl:variable name="var164_result_vmf5_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf5_inputtoresult">
													<xsl:with-param name="input" select="xs:string(xs:token(geogunit))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var164_result_vmf5_inputtoresult)">
												<xsl:attribute name="uom">
													<xsl:sequence select="xs:string(xs:string($var164_result_vmf5_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="xs:string(xs:double(latres))"/>
										</gco:Scale>
									</gmd:resolution>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('row'))"/>
											</xsl:attribute>
											<xsl:sequence select="'row'"/>
										</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:dimensionSize>
									<gmd:resolution>
										<gco:Scale>
											<xsl:variable name="var165_result_vmf5_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf5_inputtoresult">
													<xsl:with-param name="input" select="xs:string(xs:token(geogunit))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var165_result_vmf5_inputtoresult)">
												<xsl:attribute name="uom">
													<xsl:sequence select="xs:string(xs:string($var165_result_vmf5_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="xs:string(xs:double(longres))"/>
										</gco:Scale>
									</gmd:resolution>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
							<gmd:cellGeometry>
								<xsl:variable name="var166_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)">
											<xsl:for-each select="$var160_metadata/spdoinfo/rastinfo">
												<xsl:variable name="var176_result_vmf1_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf1_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:token(rasttype))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var176_result_vmf1_inputtoresult)">
													<xsl:sequence select="$var176_result_vmf1_inputtoresult"/>
												</xsl:if>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="''"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var166_cond_result_exists)">
									<gmd:MD_CellGeometryCode>
										<xsl:attribute name="codeList">
											<xsl:variable name="var167_cond_result_exists" as="xs:string" select="(if (fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode' else '')"/>
											<xsl:sequence select="xs:string(xs:anyURI($var167_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI($var166_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:variable name="var168_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var160_metadata/spdoinfo/rastinfo/rasttype)">
													<xsl:for-each select="$var160_metadata/spdoinfo/rastinfo">
														<xsl:variable name="var172_result_vmf2_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf2_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:token(rasttype))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var172_result_vmf2_inputtoresult)">
															<xsl:sequence select="$var172_result_vmf2_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var168_cond_result_exists)">
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI($var168_cond_result_exists))"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:sequence select="$var166_cond_result_exists"/>
									</gmd:MD_CellGeometryCode>
								</xsl:if>
							</gmd:cellGeometry>
							<gmd:transformationParameterAvailability>
								<gco:Boolean>
									<xsl:sequence select="xs:string(((('0' != 'false') and ('false' != 'false')) and fn:boolean('false')))"/>
								</gco:Boolean>
							</gmd:transformationParameterAvailability>
						</gmd:MD_GridSpatialRepresentation>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<gmd:code>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:code>
									<gmd:codeSpace>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:codeSpace>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/planar/mapproj">
				<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'https://www.ngdc.noaa.gov/docucomp/597772c0-751c-11e1-b0c4-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'https://www.ngdc.noaa.gov/docucomp/597772c0-751c-11e1-b0c4-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'NAD83 / Conus Albers' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'albers')) then 'NAD83 / Conus Albers' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/planar/mapproj">
				<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'https://www.ngdc.noaa.gov/docucomp/895cc120-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'https://www.ngdc.noaa.gov/docucomp/895cc120-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'WGS 84 / World Mercator' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(fn:lower-case(xs:string(xs:string(mapprojn))), 'mercator')) then 'WGS 84 / World Mercator' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '84')) then 'https://www.ngdc.noaa.gov/docucomp/2504d000-8345-11e1-b0c4-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '84')) then 'https://www.ngdc.noaa.gov/docucomp/2504d000-8345-11e1-b0c4-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '84')) then 'World Geodetic System 1984' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '84')) then 'World Geodetic System 1984' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '83')) then 'https://www.ngdc.noaa.gov/docucomp/65f8b220-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '83')) then 'https://www.ngdc.noaa.gov/docucomp/65f8b220-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '83')) then 'North American Datum 1983' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '83')) then 'North American Datum 1983' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic/horizdn">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '27')) then 'https://www.ngdc.noaa.gov/docucomp/32c8e7d0-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(.)), '27')) then 'https://www.ngdc.noaa.gov/docucomp/32c8e7d0-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(.)), '27')) then 'North American Datum 1927' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(.)), '27')) then 'North American Datum 1927' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'https://www.ngdc.noaa.gov/docucomp/a75c0b90-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'https://www.ngdc.noaa.gov/docucomp/a75c0b90-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'Clarke 1866' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(ellips)), '1866')) then 'Clarke 1866' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spref/horizsys/geodetic">
				<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'https://www.ngdc.noaa.gov/docucomp/c3895520-95ed-11e0-aa80-0800200c9a66' else ()))">
					<gmd:referenceSystemInfo>
						<xsl:attribute name="xlink:href">
							<xsl:sequence select="xs:string(xs:anyURI((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'https://www.ngdc.noaa.gov/docucomp/c3895520-95ed-11e0-aa80-0800200c9a66' else ())))"/>
						</xsl:attribute>
						<xsl:if test="fn:exists((if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'Geodetic Reference System 1980' else ()))">
							<xsl:attribute name="xlink:title">
								<xsl:sequence select="(if (fn:contains(xs:string(xs:string(ellips)), '80')) then 'Geodetic Reference System 1980' else ())"/>
							</xsl:attribute>
						</xsl:if>
					</gmd:referenceSystemInfo>
				</xsl:if>
			</xsl:for-each>
			<gmd:metadataExtensionInfo>
				<gmd:MD_MetadataExtensionInformation>
					<gmd:extendedElementInformation>
						<gmd:MD_ExtendedElementInformation>
							<gmd:name>
								<gco:CharacterString>
									<xsl:sequence select="'Taxonomy System'"/>
								</gco:CharacterString>
							</gmd:name>
							<gmd:shortName>
								<gco:CharacterString>
									<xsl:sequence select="'Taxonsys'"/>
								</gco:CharacterString>
							</gmd:shortName>
							<gmd:definition>
								<gco:CharacterString>
									<xsl:sequence select="'Documentation of taxonomic sources, procedures, and treatments.'"/>
								</gco:CharacterString>
							</gmd:definition>
							<gmd:obligation>
								<gmd:MD_ObligationCode>
									<xsl:sequence select="'optional'"/>
								</gmd:MD_ObligationCode>
							</gmd:obligation>
							<gmd:dataType>
								<gmd:MD_DatatypeCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DatatypeCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('class'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('&quot;001&quot;&gt; class'))"/>
									</xsl:attribute>
								</gmd:MD_DatatypeCode>
							</gmd:dataType>
							<gmd:maximumOccurrence>
								<gco:CharacterString>
									<xsl:sequence select="'1'"/>
								</gco:CharacterString>
							</gmd:maximumOccurrence>
							<gmd:parentEntity>
								<gco:CharacterString>
									<xsl:sequence select="'MD_Identification'"/>
								</gco:CharacterString>
							</gmd:parentEntity>
							<gmd:rule>
								<gco:CharacterString>
									<xsl:sequence select="'New Metadata section as a class to MD_Identification'"/>
								</gco:CharacterString>
							</gmd:rule>
							<gmd:rationale>
								<gco:CharacterString>
									<xsl:sequence select="'The set of data elements contained within this class element represents an attempt to provide better documentation of taxonomic sources, procedures, and treatments.'"/>
								</gco:CharacterString>
							</gmd:rationale>
							<gmd:source>
								<gmd:CI_ResponsibleParty>
									<gmd:organisationName>
										<gco:CharacterString>
											<xsl:sequence select="'National Biological Information Infrastructure (NBII)'"/>
										</gco:CharacterString>
									</gmd:organisationName>
									<gmd:role>
										<gmd:CI_RoleCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
											</xsl:attribute>
										</gmd:CI_RoleCode>
									</gmd:role>
								</gmd:CI_ResponsibleParty>
							</gmd:source>
						</gmd:MD_ExtendedElementInformation>
					</gmd:extendedElementInformation>
				</gmd:MD_MetadataExtensionInformation>
			</gmd:metadataExtensionInfo>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var195_metadata" as="node()" select="."/>
				<gmd:identificationInfo>
					<gmd:MD_DataIdentification>
						<gmd:citation>
							<gmd:CI_Citation>
								<gmd:title>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(idinfo/citation/citeinfo/title))"/>
									</gco:CharacterString>
								</gmd:title>
								<gmd:date>
									<gmd:CI_Date>
										<gmd:date>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate)))))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:variable name="var198_cond_result_logicalor" as="xs:string?">
												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present')))">
													<xsl:variable name="var203_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
															<xsl:choose>
																<xsl:when test="fn:ends-with(., '-')">
																	<xsl:if test="fn:ends-with(., '-')">
																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="."/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var202_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var203_map_result_distinctvalues)">
															<xsl:variable name="var208_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var208_cond_result_endswith)">
																<xsl:sequence select="$var208_cond_result_endswith"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var202_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var202_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:for-each select="$var198_cond_result_logicalor">
												<gco:Date>
													<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
												</gco:Date>
											</xsl:for-each>
											<xsl:variable name="var216_cond_result_logicalor" as="xs:string?">
												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present')))">
													<xsl:variable name="var243_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(idinfo/citation/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
															<xsl:choose>
																<xsl:when test="fn:ends-with(., '-')">
																	<xsl:if test="fn:ends-with(., '-')">
																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="."/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var242_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var243_map_result_distinctvalues)">
															<xsl:variable name="var248_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var248_cond_result_endswith)">
																<xsl:sequence select="$var248_cond_result_endswith"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var242_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var242_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:for-each select="$var216_cond_result_logicalor">
												<xsl:variable name="var217_cur_cond_result_logicalor" as="xs:string" select="."/>
												<xsl:variable name="var219_map_select_pubtime" as="xs:string?">
													<xsl:for-each select="$var195_metadata/idinfo/citation/citeinfo/pubtime">
														<xsl:variable name="var240_result_vmf6_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf6_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var239_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var240_result_vmf6_inputtoresult)) then (if (fn:contains($var240_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
														<xsl:if test="not(fn:exists($var239_cond_result_exists))">
															<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:variable>
												<xsl:for-each select="fn:distinct-values($var219_map_select_pubtime)">
													<xsl:variable name="var224_cond_result_endswith" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:ends-with(., ':')">
																<xsl:if test="fn:ends-with(., ':')">
																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var224_cond_result_endswith)">
														<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith))), 'un'))">
															<gco:DateTime>
																<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var217_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var224_cond_result_endswith)))))))"/>
															</gco:DateTime>
														</xsl:if>
													</xsl:if>
												</xsl:for-each>
											</xsl:for-each>
										</gmd:date>
										<gmd:dateType>
											<gmd:CI_DateTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
												</xsl:attribute>
												<xsl:sequence select="'publication'"/>
											</gmd:CI_DateTypeCode>
										</gmd:dateType>
									</gmd:CI_Date>
								</gmd:date>
								<xsl:for-each select="idinfo/citation/citeinfo/edition">
									<gmd:edition>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:edition>
								</xsl:for-each>
								<xsl:for-each select="distinfo/resdesc">
									<gmd:identifier>
										<gmd:MD_Identifier>
											<gmd:code>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:code>
										</gmd:MD_Identifier>
									</gmd:identifier>
								</xsl:for-each>
								<xsl:for-each-group select="idinfo/citation/citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
									<xsl:variable name="var261_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
									<gmd:citedResponsibleParty>
										<gmd:CI_ResponsibleParty>
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="$var261_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:organisationName>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
													</xsl:attribute>
													<xsl:sequence select="'originator'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</gmd:citedResponsibleParty>
								</xsl:for-each-group>
								<xsl:for-each select="idinfo/citation/citeinfo/pubinfo">
									<gmd:citedResponsibleParty>
										<gmd:CI_ResponsibleParty>
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(publish)"/>
												</gco:CharacterString>
											</gmd:organisationName>
											<gmd:contactInfo>
												<gmd:CI_Contact>
													<gmd:address>
														<gmd:CI_Address>
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:substring-before(xs:string(pubplace), ',')"/>
																</gco:CharacterString>
															</gmd:city>
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:substring-after(xs:string(pubplace), ',')"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
														</gmd:CI_Address>
													</gmd:address>
												</gmd:CI_Contact>
											</gmd:contactInfo>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI('publisher'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI('010'))"/>
													</xsl:attribute>
													<xsl:sequence select="'publisher'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</gmd:citedResponsibleParty>
								</xsl:for-each>
								<gmd:presentationForm>
									<xsl:variable name="var268_result_vmf7_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf7_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/citation/citeinfo/geoform))))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var265_cond_result_exists" as="xs:string?" select="(if (fn:exists($var268_result_vmf7_inputtoresult)) then $var268_result_vmf7_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var265_cond_result_exists)">
										<gmd:CI_PresentationFormCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var265_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var267_result_vmf8_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf8_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(idinfo/citation/citeinfo/geoform))))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var266_cond_result_exists" as="xs:string?" select="(if (fn:exists($var267_result_vmf8_inputtoresult)) then $var267_result_vmf8_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var266_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var266_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var265_cond_result_exists"/>
										</gmd:CI_PresentationFormCode>
									</xsl:if>
								</gmd:presentationForm>
								<xsl:for-each select="idinfo/citation/citeinfo/serinfo">
									<gmd:series>
										<gmd:CI_Series>
											<gmd:name>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(sername)"/>
												</gco:CharacterString>
											</gmd:name>
											<gmd:issueIdentification>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(issue)"/>
												</gco:CharacterString>
											</gmd:issueIdentification>
										</gmd:CI_Series>
									</gmd:series>
								</xsl:for-each>
								<xsl:for-each select="idinfo/citation/citeinfo/othercit">
									<gmd:otherCitationDetails>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:otherCitationDetails>
								</xsl:for-each>
							</gmd:CI_Citation>
						</gmd:citation>
						<gmd:abstract>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/abstract))"/>
							</gco:CharacterString>
						</gmd:abstract>
						<gmd:purpose>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(idinfo/descript/purpose))"/>
							</gco:CharacterString>
						</gmd:purpose>
						<xsl:for-each-group select="idinfo/datacred" group-by="fn:normalize-space(xs:string(.))">
							<xsl:variable name="var275_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:credit>
								<gco:CharacterString>
									<xsl:sequence select="$var275_cur_result_groupby"/>
								</gco:CharacterString>
							</gmd:credit>
						</xsl:for-each-group>
						<gmd:status>
							<xsl:variable name="var280_result_vmf9_inputtoresult" as="xs:string?">
								<xsl:call-template name="vmf:vmf9_inputtoresult">
									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/progress)))"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="var277_cond_result_exists" as="xs:string?" select="(if (fn:exists($var280_result_vmf9_inputtoresult)) then $var280_result_vmf9_inputtoresult else ())"/>
							<xsl:if test="fn:exists($var277_cond_result_exists)">
								<gmd:MD_ProgressCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI($var277_cond_result_exists))"/>
									</xsl:attribute>
									<xsl:variable name="var279_result_vmf10_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf10_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/progress)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var278_cond_result_exists" as="xs:string?" select="(if (fn:exists($var279_result_vmf10_inputtoresult)) then $var279_result_vmf10_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var278_cond_result_exists)">
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI($var278_cond_result_exists))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:sequence select="$var277_cond_result_exists"/>
								</gmd:MD_ProgressCode>
							</xsl:if>
						</gmd:status>
						<xsl:for-each select="idinfo/ptcontac">
							<xsl:variable name="var281_ptcontac" as="node()" select="."/>
							<gmd:pointOfContact>
								<gmd:CI_ResponsibleParty>
									<xsl:variable name="var284_map_select_cntperp" as="xs:string?">
										<xsl:for-each select="cntinfo/cntperp/cntper">
											<xsl:sequence select="xs:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var283_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var284_map_select_cntperp)">
												<xsl:for-each select="cntinfo/cntperp/cntper">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="cntinfo/cntorgp/cntper">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var283_cond_result_exists)">
										<gmd:individualName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(fn:normalize-space($var283_cond_result_exists))"/>
											</gco:CharacterString>
										</gmd:individualName>
									</xsl:if>
									<xsl:variable name="var293_map_select_cntperp" as="xs:string?">
										<xsl:for-each select="cntinfo/cntperp/cntorg">
											<xsl:sequence select="xs:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var292_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var293_map_select_cntperp)">
												<xsl:for-each select="cntinfo/cntperp/cntorg">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="cntinfo/cntorgp/cntorg">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var292_cond_result_exists)">
										<gmd:organisationName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(fn:normalize-space($var292_cond_result_exists))"/>
											</gco:CharacterString>
										</gmd:organisationName>
									</xsl:if>
									<xsl:for-each select="cntinfo/cntpos">
										<gmd:positionName>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:positionName>
									</xsl:for-each>
									<gmd:contactInfo>
										<gmd:CI_Contact>
											<gmd:phone>
												<gmd:CI_Telephone>
													<xsl:for-each-group select="cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var305_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:voice>
															<gco:CharacterString>
																<xsl:sequence select="$var305_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:voice>
													</xsl:for-each-group>
													<xsl:for-each-group select="cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var309_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:facsimile>
															<gco:CharacterString>
																<xsl:sequence select="$var309_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:facsimile>
													</xsl:for-each-group>
												</gmd:CI_Telephone>
											</gmd:phone>
											<gmd:address>
												<xsl:for-each select="$var195_metadata/metainfo/metc/cntinfo/cntaddr">
													<gmd:CI_Address>
														<xsl:for-each-group select="$var281_ptcontac/cntinfo/cntaddr/address" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var315_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:deliveryPoint>
																<gco:CharacterString>
																	<xsl:sequence select="$var315_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:deliveryPoint>
														</xsl:for-each-group>
														<xsl:for-each select="$var281_ptcontac/cntinfo/cntaddr">
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																</gco:CharacterString>
															</gmd:city>
														</xsl:for-each>
														<xsl:for-each select="$var281_ptcontac/cntinfo/cntaddr">
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
														</xsl:for-each>
														<xsl:for-each select="$var281_ptcontac/cntinfo/cntaddr">
															<gmd:postalCode>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																</gco:CharacterString>
															</gmd:postalCode>
														</xsl:for-each>
														<xsl:for-each select="$var281_ptcontac/cntinfo/cntaddr/country">
															<gmd:country>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:country>
														</xsl:for-each>
														<xsl:for-each-group select="$var281_ptcontac/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var327_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:electronicMailAddress>
																<gco:CharacterString>
																	<xsl:sequence select="$var327_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:electronicMailAddress>
														</xsl:for-each-group>
													</gmd:CI_Address>
												</xsl:for-each>
											</gmd:address>
											<xsl:for-each select="cntinfo/hours">
												<gmd:hoursOfService>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:hoursOfService>
											</xsl:for-each>
											<xsl:for-each select="cntinfo/cntinst">
												<gmd:contactInstructions>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:contactInstructions>
											</xsl:for-each>
										</gmd:CI_Contact>
									</gmd:contactInfo>
									<gmd:role>
										<gmd:CI_RoleCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
											</xsl:attribute>
											<xsl:sequence select="'pointOfContact'"/>
										</gmd:CI_RoleCode>
									</gmd:role>
								</gmd:CI_ResponsibleParty>
							</gmd:pointOfContact>
						</xsl:for-each>
						<gmd:resourceMaintenance>
							<gmd:MD_MaintenanceInformation>
								<gmd:maintenanceAndUpdateFrequency>
									<xsl:variable name="var336_result_vmf11_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf11_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/update)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="var333_cond_result_exists" as="xs:string?" select="(if (fn:exists($var336_result_vmf11_inputtoresult)) then $var336_result_vmf11_inputtoresult else ())"/>
									<xsl:if test="fn:exists($var333_cond_result_exists)">
										<gmd:MD_MaintenanceFrequencyCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var333_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:variable name="var335_result_vmf12_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf12_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(idinfo/status/update)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:variable name="var334_cond_result_exists" as="xs:string?" select="(if (fn:exists($var335_result_vmf12_inputtoresult)) then $var335_result_vmf12_inputtoresult else ())"/>
											<xsl:if test="fn:exists($var334_cond_result_exists)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var334_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var333_cond_result_exists"/>
										</gmd:MD_MaintenanceFrequencyCode>
									</xsl:if>
								</gmd:maintenanceAndUpdateFrequency>
							</gmd:MD_MaintenanceInformation>
						</gmd:resourceMaintenance>
						<xsl:for-each select="eainfo/detailed/attr/attrmfrq">
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var342_result_vmf11_inputtoresult" as="xs:string?">
											<xsl:call-template name="vmf:vmf11_inputtoresult">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var339_cond_result_exists" as="xs:string?" select="(if (fn:exists($var342_result_vmf11_inputtoresult)) then $var342_result_vmf11_inputtoresult else ())"/>
										<xsl:if test="fn:exists($var339_cond_result_exists)">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI($var339_cond_result_exists))"/>
												</xsl:attribute>
												<xsl:variable name="var341_result_vmf12_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf12_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var340_cond_result_exists" as="xs:string?" select="(if (fn:exists($var341_result_vmf12_inputtoresult)) then $var341_result_vmf12_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var340_cond_result_exists)">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI($var340_cond_result_exists))"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var339_cond_result_exists"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:if>
									</gmd:maintenanceAndUpdateFrequency>
									<gmd:updateScope>
										<gmd:MD_ScopeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('attribute'))"/>
											</xsl:attribute>
										</gmd:MD_ScopeCode>
									</gmd:updateScope>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
						</xsl:for-each>
						<xsl:for-each select="idinfo/browse">
							<gmd:graphicOverview>
								<gmd:MD_BrowseGraphic>
									<gmd:fileName>
										<xsl:for-each-group select="." group-by="xs:string(browsen)">
											<xsl:variable name="var347_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space($var347_cur_result_groupby)"/>
											</gco:CharacterString>
										</xsl:for-each-group>
									</gmd:fileName>
									<gmd:fileDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(browsed))"/>
										</gco:CharacterString>
									</gmd:fileDescription>
									<gmd:fileType>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(browset)))"/>
										</gco:CharacterString>
									</gmd:fileType>
								</gmd:MD_BrowseGraphic>
							</gmd:graphicOverview>
						</xsl:for-each>
						<xsl:for-each-group select="idinfo/keywords/theme" group-by="(if (fn:contains(xs:string(xs:string(themekt)), 'ISO 19115')) then () else xs:string(xs:string(themekt)))">
							<xsl:variable name="var350_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var351_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var350_cur_result_groupby/themekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('theme'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
											</xsl:attribute>
											<xsl:sequence select="'theme'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var351_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/place" group-by="xs:string(xs:string(placekt))">
							<xsl:variable name="var356_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var357_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var356_cur_result_groupby/placekey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('place'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
											</xsl:attribute>
											<xsl:sequence select="'place'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var357_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/stratum" group-by="xs:string(xs:string(stratkt))">
							<xsl:variable name="var362_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var363_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var362_cur_result_groupby/stratkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('stratum'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('003'))"/>
											</xsl:attribute>
											<xsl:sequence select="'stratum'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var363_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/keywords/temporal" group-by="xs:string(xs:string(tempkt))">
							<xsl:variable name="var368_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var369_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var368_cur_result_groupby/tempkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('temporal'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
											</xsl:attribute>
											<xsl:sequence select="'temporal'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var369_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="idinfo/taxonomy/keywtax" group-by="xs:string(xs:string(taxonkt))">
							<xsl:variable name="var374_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var375_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var374_cur_result_groupby/taxonkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('taxon'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
											</xsl:attribute>
											<xsl:sequence select="'taxon'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var375_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('inapplicable'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:for-each-group select="dataqual/lineage/method/methodid" group-by="xs:string(xs:string(methkt))">
							<xsl:variable name="var380_cur_result_groupby" as="item()+" select="current-group()"/>
							<xsl:variable name="var381_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
							<gmd:descriptiveKeywords>
								<gmd:MD_Keywords>
									<xsl:for-each select="$var380_cur_result_groupby/methkey">
										<gmd:keyword>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:keyword>
									</xsl:for-each>
									<gmd:type>
										<gmd:MD_KeywordTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('discipline'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
											</xsl:attribute>
											<xsl:sequence select="'discipline'"/>
										</gmd:MD_KeywordTypeCode>
									</gmd:type>
									<gmd:thesaurusName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var381_cur_result_groupby)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('inapplicable'))"/>
												</xsl:attribute>
											</gmd:date>
										</gmd:CI_Citation>
									</gmd:thesaurusName>
								</gmd:MD_Keywords>
							</gmd:descriptiveKeywords>
						</xsl:for-each-group>
						<xsl:variable name="var385_cond_result_exists" as="xs:string?">
							<xsl:choose>
								<xsl:when test="fn:exists(distinfo/distliab)">
									<xsl:variable name="var390_map_select_distinfo" as="xs:string*">
										<xsl:for-each select="distinfo">
											<xsl:sequence select="xs:string(distliab)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var390_map_select_distinfo)">
										<xsl:sequence select="fn:string-join($var390_map_select_distinfo, ' ')"/>
									</xsl:if>
								</xsl:when>
								<xsl:otherwise>
									<xsl:sequence select="' '"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:for-each select="$var385_cond_result_exists">
							<gmd:resourceConstraints>
								<gmd:MD_LegalConstraints>
									<gmd:accessConstraints>
										<gmd:MD_RestrictionCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
											</xsl:attribute>
											<xsl:sequence select="'otherRestrictions'"/>
										</gmd:MD_RestrictionCode>
									</gmd:accessConstraints>
									<gmd:useConstraints>
										<gmd:MD_RestrictionCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
											</xsl:attribute>
											<xsl:sequence select="'otherRestrictions'"/>
										</gmd:MD_RestrictionCode>
									</gmd:useConstraints>
									<gmd:otherConstraints>
										<gco:CharacterString>
											<xsl:variable name="var388_cond_result_exists" as="xs:string" select="(if (fn:exists($var195_metadata/distinfo/distliab)) then ' Distribution Liability: ' else ' ')"/>
											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('Access Constraints: ', xs:string(xs:string($var195_metadata/idinfo/accconst))), ' Use Constraints: '), xs:string(xs:string($var195_metadata/idinfo/useconst))), $var388_cond_result_exists), .))"/>
										</gco:CharacterString>
									</gmd:otherConstraints>
								</gmd:MD_LegalConstraints>
							</gmd:resourceConstraints>
						</xsl:for-each>
						<xsl:for-each select="idinfo/secinfo">
							<gmd:resourceConstraints>
								<gmd:MD_SecurityConstraints>
									<gmd:classification>
										<xsl:variable name="var398_result_vmf13_inputtoresult" as="xs:string?">
											<xsl:call-template name="vmf:vmf13_inputtoresult">
												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var395_cond_result_exists" as="xs:string?" select="(if (fn:exists($var398_result_vmf13_inputtoresult)) then $var398_result_vmf13_inputtoresult else ())"/>
										<xsl:if test="fn:exists($var395_cond_result_exists)">
											<gmd:MD_ClassificationCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI($var395_cond_result_exists))"/>
												</xsl:attribute>
												<xsl:variable name="var397_result_vmf14_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf14_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(secclass))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var396_cond_result_exists" as="xs:string?" select="(if (fn:exists($var397_result_vmf14_inputtoresult)) then $var397_result_vmf14_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var396_cond_result_exists)">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI($var396_cond_result_exists))"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:sequence select="$var395_cond_result_exists"/>
											</gmd:MD_ClassificationCode>
										</xsl:if>
									</gmd:classification>
									<gmd:classificationSystem>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(secsys)"/>
										</gco:CharacterString>
									</gmd:classificationSystem>
									<gmd:handlingDescription>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(sechandl)"/>
										</gco:CharacterString>
									</gmd:handlingDescription>
								</gmd:MD_SecurityConstraints>
							</gmd:resourceConstraints>
						</xsl:for-each>
						<xsl:for-each select="idinfo/citation/citeinfo/lworkcit">
							<xsl:variable name="var399_lworkcit" as="node()" select="."/>
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<gmd:aggregateDataSetName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(citeinfo/title)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
															<xsl:attribute name="gco:nilReason">
																<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var402_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var407_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var406_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var407_map_result_distinctvalues)">
																		<xsl:variable name="var412_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var412_cond_result_endswith)">
																			<xsl:sequence select="$var412_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var406_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var406_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var402_cond_result_logicalor">
															<gco:Date>
																<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
															</gco:Date>
														</xsl:for-each>
														<xsl:variable name="var420_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var447_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var446_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var447_map_result_distinctvalues)">
																		<xsl:variable name="var452_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var452_cond_result_endswith)">
																			<xsl:sequence select="$var452_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var446_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var446_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var420_cond_result_logicalor">
															<xsl:variable name="var421_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var423_map_select_pubtime" as="xs:string?">
																<xsl:for-each select="$var399_lworkcit/citeinfo/pubtime">
																	<xsl:variable name="var444_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var443_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var444_result_vmf6_inputtoresult)) then (if (fn:contains($var444_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var443_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var423_map_select_pubtime)">
																<xsl:variable name="var428_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var428_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var428_cond_result_endswith))), 'un'))">
																		<gco:DateTime>
																			<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var421_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var428_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var428_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var428_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var428_cond_result_endswith)))))))"/>
																		</gco:DateTime>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:date>
													<gmd:dateType>
														<gmd:CI_DateTypeCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
															</xsl:attribute>
															<xsl:sequence select="'publication'"/>
														</gmd:CI_DateTypeCode>
													</gmd:dateType>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="citeinfo/edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each-group select="citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
												<xsl:variable name="var463_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="$var463_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
																</xsl:attribute>
																<xsl:sequence select="'resourceProvider'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each-group>
											<gmd:presentationForm>
												<xsl:variable name="var468_result_vmf7_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf7_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var465_cond_result_exists" as="xs:string?" select="(if (fn:exists($var468_result_vmf7_inputtoresult)) then $var468_result_vmf7_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var465_cond_result_exists)">
													<gmd:CI_PresentationFormCode>
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
														</xsl:attribute>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var465_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var467_result_vmf8_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf8_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var466_cond_result_exists" as="xs:string?" select="(if (fn:exists($var467_result_vmf8_inputtoresult)) then $var467_result_vmf8_inputtoresult else ())"/>
														<xsl:if test="fn:exists($var466_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var466_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var465_cond_result_exists"/>
													</gmd:CI_PresentationFormCode>
												</xsl:if>
											</gmd:presentationForm>
											<xsl:for-each select="citeinfo/serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(sername)"/>
															</gco:CharacterString>
														</gmd:name>
														<gmd:issueIdentification>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(issue)"/>
															</gco:CharacterString>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<gmd:otherCitationDetails>
												<xsl:for-each select="citeinfo/othercit">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</gmd:aggregateDataSetName>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('largerWorkCitation'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
											</xsl:attribute>
											<xsl:sequence select="'largerWorkCitation'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>
						<xsl:for-each select="idinfo/crossref">
							<xsl:variable name="var473_crossref" as="node()" select="."/>
							<gmd:aggregationInfo>
								<gmd:MD_AggregateInformation>
									<gmd:aggregateDataSetName>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(citeinfo/title)"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
															<xsl:attribute name="gco:nilReason">
																<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var476_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var481_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var480_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var481_map_result_distinctvalues)">
																		<xsl:variable name="var486_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var486_cond_result_endswith)">
																			<xsl:sequence select="$var486_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var480_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var480_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var476_cond_result_logicalor">
															<gco:Date>
																<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
															</gco:Date>
														</xsl:for-each>
														<xsl:variable name="var494_cond_result_logicalor" as="xs:string?">
															<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																<xsl:variable name="var521_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., '-')">
																				<xsl:if test="fn:ends-with(., '-')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var520_map_result_distinctvalues" as="xs:string*">
																	<xsl:for-each select="fn:distinct-values($var521_map_result_distinctvalues)">
																		<xsl:variable name="var526_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																							<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var526_cond_result_endswith)">
																			<xsl:sequence select="$var526_cond_result_endswith"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var520_map_result_distinctvalues)">
																	<xsl:sequence select="fn:string-join($var520_map_result_distinctvalues, ' ')"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var494_cond_result_logicalor">
															<xsl:variable name="var495_cur_cond_result_logicalor" as="xs:string" select="."/>
															<xsl:variable name="var497_map_select_pubtime" as="xs:string?">
																<xsl:for-each select="$var473_crossref/citeinfo/pubtime">
																	<xsl:variable name="var518_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var517_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var518_result_vmf6_inputtoresult)) then (if (fn:contains($var518_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																	<xsl:if test="not(fn:exists($var517_cond_result_exists))">
																		<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:for-each select="fn:distinct-values($var497_map_select_pubtime)">
																<xsl:variable name="var502_cond_result_endswith" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., ':')">
																			<xsl:if test="fn:ends-with(., ':')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var502_cond_result_endswith)">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var502_cond_result_endswith))), 'un'))">
																		<gco:DateTime>
																			<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var495_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var502_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var502_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var502_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var502_cond_result_endswith)))))))"/>
																		</gco:DateTime>
																	</xsl:if>
																</xsl:if>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:date>
													<gmd:dateType>
														<gmd:CI_DateTypeCode>
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
															</xsl:attribute>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
															</xsl:attribute>
															<xsl:sequence select="'publication'"/>
														</gmd:CI_DateTypeCode>
													</gmd:dateType>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="citeinfo/edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each-group select="citeinfo/origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
												<xsl:variable name="var537_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="$var537_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																</xsl:attribute>
																<xsl:sequence select="'originator'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each-group>
											<xsl:for-each select="citeinfo/pubinfo">
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(publish)"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:contactInfo>
															<gmd:CI_Contact>
																<gmd:address>
																	<gmd:CI_Address>
																		<gmd:city>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:substring-before(xs:string(pubplace), ',')"/>
																			</gco:CharacterString>
																		</gmd:city>
																		<gmd:administrativeArea>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:substring-after(xs:string(pubplace), ',')"/>
																			</gco:CharacterString>
																		</gmd:administrativeArea>
																	</gmd:CI_Address>
																</gmd:address>
																<xsl:for-each select="$var473_crossref/citeinfo/onlink">
																	<gmd:onlineResource>
																		<gmd:CI_OnlineResource>
																			<gmd:linkage>
																				<gmd:URL>
																					<xsl:sequence select="xs:string(xs:anyURI(xs:string(.)))"/>
																				</gmd:URL>
																			</gmd:linkage>
																		</gmd:CI_OnlineResource>
																	</gmd:onlineResource>
																</xsl:for-each>
															</gmd:CI_Contact>
														</gmd:contactInfo>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('publisher'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('009'))"/>
																</xsl:attribute>
																<xsl:sequence select="'publisher'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each>
											<gmd:presentationForm>
												<xsl:variable name="var546_result_vmf7_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf7_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:variable name="var543_cond_result_exists" as="xs:string?" select="(if (fn:exists($var546_result_vmf7_inputtoresult)) then $var546_result_vmf7_inputtoresult else ())"/>
												<xsl:if test="fn:exists($var543_cond_result_exists)">
													<gmd:CI_PresentationFormCode>
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
														</xsl:attribute>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var543_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var545_result_vmf8_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf8_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var544_cond_result_exists" as="xs:string?" select="(if (fn:exists($var545_result_vmf8_inputtoresult)) then $var545_result_vmf8_inputtoresult else ())"/>
														<xsl:if test="fn:exists($var544_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var544_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var543_cond_result_exists"/>
													</gmd:CI_PresentationFormCode>
												</xsl:if>
											</gmd:presentationForm>
											<xsl:for-each select="citeinfo/serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(sername)"/>
															</gco:CharacterString>
														</gmd:name>
														<gmd:issueIdentification>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(issue)"/>
															</gco:CharacterString>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<gmd:otherCitationDetails>
												<xsl:for-each select="citeinfo/othercit">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</gmd:aggregateDataSetName>
									<gmd:associationType>
										<gmd:DS_AssociationTypeCode>
											<xsl:variable name="var552_cond_result_exists" as="xs:string?" select="(if (fn:exists($var195_metadata/idinfo/citation/citeinfo/lworkcit/citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
											<xsl:variable name="var551_cond_result_exists" as="xs:string?" select="(if (fn:exists($var552_cond_result_exists)) then $var552_cond_result_exists else ())"/>
											<xsl:if test="fn:exists($var551_cond_result_exists)">
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI($var551_cond_result_exists))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('crossReference'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
											</xsl:attribute>
											<xsl:sequence select="'crossReference'"/>
										</gmd:DS_AssociationTypeCode>
									</gmd:associationType>
								</gmd:MD_AggregateInformation>
							</gmd:aggregationInfo>
						</xsl:for-each>
						<xsl:for-each select="idinfo/taxonomy">
							<gmd:taxonomy>
								<gmd:MD_TaxonSys>
									<gmd:classSys>
										<gmd:CI_Citation>
											<xsl:for-each select="taxonsys/classsys">
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(classcit/citeinfo/title))"/>
													</gco:CharacterString>
												</gmd:title>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys">
												<xsl:variable name="var557_classsys" as="node()" select="."/>
												<gmd:date>
													<gmd:CI_Date>
														<gmd:date>
															<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unpublished'))">
																<xsl:attribute name="gco:nilReason">
																	<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate)))))"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:variable name="var560_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'present')))">
																	<xsl:variable name="var565_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var564_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var565_map_result_distinctvalues)">
																			<xsl:variable name="var570_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var570_cond_result_endswith)">
																				<xsl:sequence select="$var570_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var564_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var564_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var560_cond_result_logicalor">
																<gco:Date>
																	<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																</gco:Date>
															</xsl:for-each>
															<xsl:variable name="var578_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'present')))">
																	<xsl:variable name="var585_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(classcit/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var584_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var585_map_result_distinctvalues)">
																			<xsl:variable name="var590_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var590_cond_result_endswith)">
																				<xsl:sequence select="$var590_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var584_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var584_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var578_cond_result_logicalor">
																<xsl:variable name="var579_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:for-each select="$var557_classsys/classcit/citeinfo/pubtime">
																	<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))), 'un'))">
																		<gco:DateTime>
																			<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var579_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))) and ('false' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))))) and fn:boolean(fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))) then 'T' else '')), fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))))"/>
																		</gco:DateTime>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</gmd:date>
														<gmd:dateType>
															<gmd:CI_DateTypeCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																</xsl:attribute>
															</gmd:CI_DateTypeCode>
														</gmd:dateType>
													</gmd:CI_Date>
												</gmd:date>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys/classcit/citeinfo/edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys">
												<xsl:variable name="var599_classsys" as="node()" select="."/>
												<xsl:for-each select="classcit/citeinfo/origin">
													<gmd:citedResponsibleParty>
														<gmd:CI_ResponsibleParty>
															<gmd:organisationName>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																</gco:CharacterString>
															</gmd:organisationName>
															<gmd:contactInfo>
																<gmd:CI_Contact>
																	<xsl:for-each select="$var599_classsys/classcit/citeinfo/onlink">
																		<gmd:onlineResource>
																			<gmd:CI_OnlineResource>
																				<gmd:linkage>
																					<gmd:URL>
																						<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
																					</gmd:URL>
																				</gmd:linkage>
																			</gmd:CI_OnlineResource>
																		</gmd:onlineResource>
																	</xsl:for-each>
																</gmd:CI_Contact>
															</gmd:contactInfo>
															<gmd:role>
																<gmd:CI_RoleCode>
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																	</xsl:attribute>
																	<xsl:attribute name="codeListValue">
																		<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																	</xsl:attribute>
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																	</xsl:attribute>
																</gmd:CI_RoleCode>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:citedResponsibleParty>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys">
												<gmd:presentationForm>
													<gmd:CI_PresentationFormCode>
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
														</xsl:attribute>
														<xsl:variable name="var608_result_vmf7_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf7_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(classcit/citeinfo/geoform))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var607_cond_result_exists" as="xs:string?" select="(if (fn:exists($var608_result_vmf7_inputtoresult)) then $var608_result_vmf7_inputtoresult else ())"/>
														<xsl:if test="fn:exists($var607_cond_result_exists)">
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI($var607_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var610_result_vmf8_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf8_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(classcit/citeinfo/geoform))))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:variable name="var609_cond_result_exists" as="xs:string?" select="(if (fn:exists($var610_result_vmf8_inputtoresult)) then $var610_result_vmf8_inputtoresult else ())"/>
														<xsl:if test="fn:exists($var609_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var609_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
													</gmd:CI_PresentationFormCode>
												</gmd:presentationForm>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys/classcit/citeinfo/serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
															</gco:CharacterString>
														</gmd:name>
														<gmd:issueIdentification>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
															</gco:CharacterString>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<xsl:for-each select="taxonsys/classsys/classcit/citeinfo/othercit">
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</xsl:for-each>
										</gmd:CI_Citation>
										<xsl:for-each select="taxonsys/classsys/classmod">
											<gmd:classmod>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:classmod>
										</xsl:for-each>
									</gmd:classSys>
									<xsl:for-each select="taxongen">
										<gmd:taxongen>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:taxongen>
									</xsl:for-each>
									<gmd:idref>
										<xsl:variable name="var619_cond_result_exists" as="xs:string?" select="(if (fn:exists(taxonsys/idref)) then () else 'unknown')"/>
										<xsl:if test="fn:exists($var619_cond_result_exists)">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string($var619_cond_result_exists))"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:for-each select="taxonsys/idref">
											<xsl:variable name="var620_idref" as="node()" select="."/>
											<gmd:RS_Identifier>
												<gmd:authority>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(citeinfo/title))"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:date>
															<gmd:CI_Date>
																<gmd:date>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:variable name="var623_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var628_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var627_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var628_map_result_distinctvalues)">
																					<xsl:variable name="var633_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var633_cond_result_endswith)">
																						<xsl:sequence select="$var633_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var627_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var627_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var623_cond_result_logicalor">
																		<gco:Date>
																			<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																		</gco:Date>
																	</xsl:for-each>
																	<xsl:variable name="var641_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var648_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var647_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var648_map_result_distinctvalues)">
																					<xsl:variable name="var653_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var653_cond_result_endswith)">
																						<xsl:sequence select="$var653_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var647_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var647_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var641_cond_result_logicalor">
																		<xsl:variable name="var642_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:for-each select="$var620_idref/citeinfo/pubtime">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))), 'un'))">
																				<gco:DateTime>
																					<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var642_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))) and ('false' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))))) and fn:boolean(fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))) then 'T' else '')), fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))))"/>
																				</gco:DateTime>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</gmd:date>
																<gmd:dateType>
																	<gmd:CI_DateTypeCode>
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																		</xsl:attribute>
																	</gmd:CI_DateTypeCode>
																</gmd:dateType>
															</gmd:CI_Date>
														</gmd:date>
														<xsl:for-each select="citeinfo/edition">
															<gmd:edition>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:edition>
														</xsl:for-each>
														<xsl:for-each select="citeinfo/origin">
															<gmd:citedResponsibleParty>
																<gmd:CI_ResponsibleParty>
																	<gmd:organisationName>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</gco:CharacterString>
																	</gmd:organisationName>
																	<gmd:contactInfo>
																		<gmd:CI_Contact>
																			<xsl:for-each select="$var620_idref/citeinfo/onlink">
																				<gmd:onlineResource>
																					<gmd:CI_OnlineResource>
																						<gmd:linkage>
																							<gmd:URL>
																								<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
																							</gmd:URL>
																						</gmd:linkage>
																					</gmd:CI_OnlineResource>
																				</gmd:onlineResource>
																			</xsl:for-each>
																		</gmd:CI_Contact>
																	</gmd:contactInfo>
																	<gmd:role>
																		<gmd:CI_RoleCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
																			</xsl:attribute>
																		</gmd:CI_RoleCode>
																	</gmd:role>
																</gmd:CI_ResponsibleParty>
															</gmd:citedResponsibleParty>
														</xsl:for-each>
														<gmd:presentationForm>
															<gmd:CI_PresentationFormCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																</xsl:attribute>
																<xsl:variable name="var667_result_vmf7_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf7_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="var666_cond_result_exists" as="xs:string?" select="(if (fn:exists($var667_result_vmf7_inputtoresult)) then $var667_result_vmf7_inputtoresult else ())"/>
																<xsl:if test="fn:exists($var666_cond_result_exists)">
																	<xsl:attribute name="codeListValue">
																		<xsl:sequence select="xs:string(xs:anyURI($var666_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:variable name="var669_result_vmf8_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf8_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="var668_cond_result_exists" as="xs:string?" select="(if (fn:exists($var669_result_vmf8_inputtoresult)) then $var669_result_vmf8_inputtoresult else ())"/>
																<xsl:if test="fn:exists($var668_cond_result_exists)">
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI($var668_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
															</gmd:CI_PresentationFormCode>
														</gmd:presentationForm>
														<xsl:for-each select="citeinfo/serinfo">
															<gmd:series>
																<gmd:CI_Series>
																	<gmd:name>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
																		</gco:CharacterString>
																	</gmd:name>
																	<gmd:issueIdentification>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
																		</gco:CharacterString>
																	</gmd:issueIdentification>
																</gmd:CI_Series>
															</gmd:series>
														</xsl:for-each>
														<xsl:for-each select="citeinfo/othercit">
															<gmd:otherCitationDetails>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:otherCitationDetails>
														</xsl:for-each>
													</gmd:CI_Citation>
												</gmd:authority>
											</gmd:RS_Identifier>
										</xsl:for-each>
									</gmd:idref>
									<xsl:for-each select="taxonsys/ider">
										<xsl:variable name="var674_ider" as="node()" select="."/>
										<gmd:obs>
											<gmd:CI_ResponsibleParty>
												<gmd:individualName>
													<xsl:variable name="var677_map_select_cntperp" as="xs:string?">
														<xsl:for-each select="cntinfo/cntperp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var676_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var677_map_select_cntperp)">
																<xsl:for-each select="cntinfo/cntperp/cntper">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="cntinfo/cntorgp/cntper">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var676_cond_result_exists)">
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space($var676_cond_result_exists)"/>
														</gco:CharacterString>
													</xsl:if>
												</gmd:individualName>
												<gmd:organisationName>
													<xsl:variable name="var686_map_select_cntperp" as="xs:string?">
														<xsl:for-each select="cntinfo/cntperp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var685_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var686_map_select_cntperp)">
																<xsl:for-each select="cntinfo/cntperp/cntorg">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="cntinfo/cntorgp/cntorg">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var685_cond_result_exists)">
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space($var685_cond_result_exists)"/>
														</gco:CharacterString>
													</xsl:if>
												</gmd:organisationName>
												<xsl:for-each select="cntinfo/cntpos">
													<gmd:positionName>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:CharacterString>
													</gmd:positionName>
												</xsl:for-each>
												<gmd:contactInfo>
													<gmd:CI_Contact>
														<gmd:phone>
															<gmd:CI_Telephone>
																<xsl:for-each select="cntinfo/cntvoice">
																	<gmd:voice>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:voice>
																</xsl:for-each>
																<xsl:for-each select="cntinfo/cntfax">
																	<gmd:facsimile>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:facsimile>
																</xsl:for-each>
															</gmd:CI_Telephone>
														</gmd:phone>
														<xsl:for-each select="cntinfo/cntaddr">
															<gmd:address>
																<gmd:CI_Address>
																	<xsl:for-each select="address">
																		<gmd:deliveryPoint>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:deliveryPoint>
																	</xsl:for-each>
																	<gmd:city>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																		</gco:CharacterString>
																	</gmd:city>
																	<gmd:administrativeArea>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																		</gco:CharacterString>
																	</gmd:administrativeArea>
																	<gmd:postalCode>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																		</gco:CharacterString>
																	</gmd:postalCode>
																	<xsl:for-each select="country">
																		<gmd:country>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:country>
																	</xsl:for-each>
																	<xsl:for-each select="$var674_ider/cntinfo/cntemail">
																		<gmd:electronicMailAddress>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:electronicMailAddress>
																	</xsl:for-each>
																</gmd:CI_Address>
															</gmd:address>
														</xsl:for-each>
														<xsl:for-each select="cntinfo/hours">
															<gmd:hoursOfService>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:hoursOfService>
														</xsl:for-each>
														<xsl:for-each select="cntinfo/cntinst">
															<gmd:contactInstructions>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:contactInstructions>
														</xsl:for-each>
													</gmd:CI_Contact>
												</gmd:contactInfo>
												<gmd:role>
													<gmd:CI_RoleCode>
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
														</xsl:attribute>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
														</xsl:attribute>
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
														</xsl:attribute>
													</gmd:CI_RoleCode>
												</gmd:role>
											</gmd:CI_ResponsibleParty>
										</gmd:obs>
									</xsl:for-each>
									<xsl:for-each select="taxonsys">
										<gmd:taxonpro>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(taxonpro))"/>
											</gco:CharacterString>
										</gmd:taxonpro>
									</xsl:for-each>
									<xsl:for-each select="taxonsys/taxoncom">
										<gmd:taxoncom>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:taxoncom>
									</xsl:for-each>
									<xsl:for-each select="taxonsys/vouchers">
										<xsl:variable name="var716_vouchers" as="node()" select="."/>
										<gmd:voucher>
											<gmd:MD_Vouchers>
												<gmd:specimen>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(xs:string(specimen)))"/>
													</gco:CharacterString>
												</gmd:specimen>
												<gmd:reposit>
													<gmd:CI_ResponsibleParty>
														<gmd:individualName>
															<xsl:variable name="var719_map_select_cntperp" as="xs:string?">
																<xsl:for-each select="reposit/cntinfo/cntperp/cntper">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var718_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var719_map_select_cntperp)">
																		<xsl:for-each select="reposit/cntinfo/cntperp/cntper">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="reposit/cntinfo/cntorgp/cntper">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var718_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space($var718_cond_result_exists)"/>
																</gco:CharacterString>
															</xsl:if>
														</gmd:individualName>
														<gmd:organisationName>
															<xsl:variable name="var728_map_select_cntperp" as="xs:string?">
																<xsl:for-each select="reposit/cntinfo/cntperp/cntorg">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var727_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var728_map_select_cntperp)">
																		<xsl:for-each select="reposit/cntinfo/cntperp/cntorg">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="reposit/cntinfo/cntorgp/cntorg">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var727_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space($var727_cond_result_exists)"/>
																</gco:CharacterString>
															</xsl:if>
														</gmd:organisationName>
														<xsl:for-each select="reposit/cntinfo/cntpos">
															<gmd:positionName>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:positionName>
														</xsl:for-each>
														<gmd:contactInfo>
															<gmd:CI_Contact>
																<gmd:phone>
																	<gmd:CI_Telephone>
																		<xsl:for-each select="reposit/cntinfo/cntvoice">
																			<gmd:voice>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:voice>
																		</xsl:for-each>
																		<xsl:for-each select="reposit/cntinfo/cntfax">
																			<gmd:facsimile>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:facsimile>
																		</xsl:for-each>
																	</gmd:CI_Telephone>
																</gmd:phone>
																<xsl:for-each select="reposit/cntinfo/cntaddr">
																	<gmd:address>
																		<gmd:CI_Address>
																			<xsl:for-each select="address">
																				<gmd:deliveryPoint>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																					</gco:CharacterString>
																				</gmd:deliveryPoint>
																			</xsl:for-each>
																			<gmd:city>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																				</gco:CharacterString>
																			</gmd:city>
																			<gmd:administrativeArea>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																				</gco:CharacterString>
																			</gmd:administrativeArea>
																			<gmd:postalCode>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																				</gco:CharacterString>
																			</gmd:postalCode>
																			<xsl:for-each select="country">
																				<gmd:country>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																					</gco:CharacterString>
																				</gmd:country>
																			</xsl:for-each>
																			<xsl:for-each select="$var716_vouchers/reposit/cntinfo/cntemail">
																				<gmd:electronicMailAddress>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																					</gco:CharacterString>
																				</gmd:electronicMailAddress>
																			</xsl:for-each>
																		</gmd:CI_Address>
																	</gmd:address>
																</xsl:for-each>
																<xsl:for-each select="reposit/cntinfo/hours">
																	<gmd:hoursOfService>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:hoursOfService>
																</xsl:for-each>
																<xsl:for-each select="reposit/cntinfo/cntinst">
																	<gmd:contactInstructions>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:contactInstructions>
																</xsl:for-each>
															</gmd:CI_Contact>
														</gmd:contactInfo>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('custodian'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																</xsl:attribute>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:reposit>
											</gmd:MD_Vouchers>
										</gmd:voucher>
									</xsl:for-each>
									<gmd:taxonCl>
										<gmd:MD_TaxonCl>
											<xsl:for-each select="taxoncl/common">
												<gmd:common>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:common>
											</xsl:for-each>
											<gmd:taxonrn>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxoncl/taxonrn)))"/>
												</gco:CharacterString>
											</gmd:taxonrn>
											<gmd:taxonrv>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(taxoncl/taxonrv))"/>
												</gco:CharacterString>
											</gmd:taxonrv>
											<xsl:for-each select="taxoncl/taxoncl">
												<gmd:taxonCl>
													<gmd:MD_TaxonCl>
														<xsl:for-each select="common">
															<gmd:common>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																</gco:CharacterString>
															</gmd:common>
														</xsl:for-each>
														<gmd:taxonrn>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
															</gco:CharacterString>
														</gmd:taxonrn>
														<gmd:taxonrv>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
															</gco:CharacterString>
														</gmd:taxonrv>
														<xsl:for-each select="taxoncl">
															<gmd:taxonCl>
																<gmd:MD_TaxonCl>
																	<xsl:for-each select="common">
																		<gmd:common>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:common>
																	</xsl:for-each>
																	<gmd:taxonrn>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																		</gco:CharacterString>
																	</gmd:taxonrn>
																	<gmd:taxonrv>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																		</gco:CharacterString>
																	</gmd:taxonrv>
																	<xsl:for-each select="taxoncl">
																		<gmd:taxonCl>
																			<gmd:MD_TaxonCl>
																				<xsl:for-each select="common">
																					<gmd:common>
																						<gco:CharacterString>
																							<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																						</gco:CharacterString>
																					</gmd:common>
																				</xsl:for-each>
																				<gmd:taxonrn>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																					</gco:CharacterString>
																				</gmd:taxonrn>
																				<gmd:taxonrv>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																					</gco:CharacterString>
																				</gmd:taxonrv>
																				<xsl:for-each select="taxoncl">
																					<gmd:taxonCl>
																						<gmd:MD_TaxonCl>
																							<xsl:for-each select="common">
																								<gmd:common>
																									<gco:CharacterString>
																										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																									</gco:CharacterString>
																								</gmd:common>
																							</xsl:for-each>
																							<gmd:taxonrn>
																								<gco:CharacterString>
																									<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																								</gco:CharacterString>
																							</gmd:taxonrn>
																							<gmd:taxonrv>
																								<gco:CharacterString>
																									<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																								</gco:CharacterString>
																							</gmd:taxonrv>
																							<xsl:for-each select="taxoncl">
																								<gmd:taxonCl>
																									<gmd:MD_TaxonCl>
																										<xsl:for-each select="common">
																											<gmd:common>
																												<gco:CharacterString>
																													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																												</gco:CharacterString>
																											</gmd:common>
																										</xsl:for-each>
																										<gmd:taxonrn>
																											<gco:CharacterString>
																												<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																											</gco:CharacterString>
																										</gmd:taxonrn>
																										<gmd:taxonrv>
																											<gco:CharacterString>
																												<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																											</gco:CharacterString>
																										</gmd:taxonrv>
																										<xsl:for-each select="taxoncl">
																											<gmd:taxonCl>
																												<gmd:MD_TaxonCl>
																													<xsl:for-each select="common">
																														<gmd:common>
																															<gco:CharacterString>
																																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																															</gco:CharacterString>
																														</gmd:common>
																													</xsl:for-each>
																													<gmd:taxonrn>
																														<gco:CharacterString>
																															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																														</gco:CharacterString>
																													</gmd:taxonrn>
																													<gmd:taxonrv>
																														<gco:CharacterString>
																															<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																														</gco:CharacterString>
																													</gmd:taxonrv>
																													<xsl:for-each select="taxoncl">
																														<gmd:taxonCl>
																															<gmd:MD_TaxonCl>
																																<xsl:for-each select="common">
																																	<gmd:common>
																																		<gco:CharacterString>
																																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																		</gco:CharacterString>
																																	</gmd:common>
																																</xsl:for-each>
																																<gmd:taxonrn>
																																	<gco:CharacterString>
																																		<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																	</gco:CharacterString>
																																</gmd:taxonrn>
																																<gmd:taxonrv>
																																	<gco:CharacterString>
																																		<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																	</gco:CharacterString>
																																</gmd:taxonrv>
																																<xsl:for-each select="taxoncl">
																																	<gmd:taxonCl>
																																		<gmd:MD_TaxonCl>
																																			<xsl:for-each select="common">
																																				<gmd:common>
																																					<gco:CharacterString>
																																						<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																					</gco:CharacterString>
																																				</gmd:common>
																																			</xsl:for-each>
																																			<gmd:taxonrn>
																																				<gco:CharacterString>
																																					<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																				</gco:CharacterString>
																																			</gmd:taxonrn>
																																			<gmd:taxonrv>
																																				<gco:CharacterString>
																																					<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																				</gco:CharacterString>
																																			</gmd:taxonrv>
																																			<xsl:for-each select="taxoncl">
																																				<gmd:taxonCl>
																																					<gmd:MD_TaxonCl>
																																						<xsl:for-each select="common">
																																							<gmd:common>
																																								<gco:CharacterString>
																																									<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																								</gco:CharacterString>
																																							</gmd:common>
																																						</xsl:for-each>
																																						<gmd:taxonrn>
																																							<gco:CharacterString>
																																								<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																							</gco:CharacterString>
																																						</gmd:taxonrn>
																																						<gmd:taxonrv>
																																							<gco:CharacterString>
																																								<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																							</gco:CharacterString>
																																						</gmd:taxonrv>
																																						<xsl:for-each select="taxoncl">
																																							<gmd:taxonCl>
																																								<gmd:MD_TaxonCl>
																																									<xsl:for-each select="common">
																																										<gmd:common>
																																											<gco:CharacterString>
																																												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																											</gco:CharacterString>
																																										</gmd:common>
																																									</xsl:for-each>
																																									<gmd:taxonrn>
																																										<gco:CharacterString>
																																											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																										</gco:CharacterString>
																																									</gmd:taxonrn>
																																									<gmd:taxonrv>
																																										<gco:CharacterString>
																																											<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																										</gco:CharacterString>
																																									</gmd:taxonrv>
																																									<xsl:for-each select="taxoncl">
																																										<gmd:taxonCl>
																																											<gmd:MD_TaxonCl>
																																												<xsl:for-each select="common">
																																													<gmd:common>
																																														<gco:CharacterString>
																																															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																														</gco:CharacterString>
																																													</gmd:common>
																																												</xsl:for-each>
																																												<gmd:taxonrn>
																																													<gco:CharacterString>
																																														<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																													</gco:CharacterString>
																																												</gmd:taxonrn>
																																												<gmd:taxonrv>
																																													<gco:CharacterString>
																																														<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																													</gco:CharacterString>
																																												</gmd:taxonrv>
																																												<xsl:for-each select="taxoncl">
																																													<gmd:taxonCl>
																																														<gmd:MD_TaxonCl>
																																															<xsl:for-each select="common">
																																																<gmd:common>
																																																	<gco:CharacterString>
																																																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																	</gco:CharacterString>
																																																</gmd:common>
																																															</xsl:for-each>
																																															<gmd:taxonrn>
																																																<gco:CharacterString>
																																																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																</gco:CharacterString>
																																															</gmd:taxonrn>
																																															<gmd:taxonrv>
																																																<gco:CharacterString>
																																																	<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																</gco:CharacterString>
																																															</gmd:taxonrv>
																																															<xsl:for-each select="taxoncl">
																																																<gmd:taxonCl>
																																																	<gmd:MD_TaxonCl>
																																																		<xsl:for-each select="common">
																																																			<gmd:common>
																																																				<gco:CharacterString>
																																																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																				</gco:CharacterString>
																																																			</gmd:common>
																																																		</xsl:for-each>
																																																		<gmd:taxonrn>
																																																			<gco:CharacterString>
																																																				<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																			</gco:CharacterString>
																																																		</gmd:taxonrn>
																																																		<gmd:taxonrv>
																																																			<xsl:attribute name="gco:nilReason">
																																																				<xsl:sequence select="xs:string(xs:string(fn:normalize-space(xs:string(taxonrv))))"/>
																																																			</xsl:attribute>
																																																		</gmd:taxonrv>
																																																		<xsl:for-each select="taxoncl">
																																																			<gmd:taxonCl>
																																																				<gmd:MD_TaxonCl>
																																																					<xsl:for-each select="common">
																																																						<gmd:common>
																																																							<gco:CharacterString>
																																																								<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																							</gco:CharacterString>
																																																						</gmd:common>
																																																					</xsl:for-each>
																																																					<gmd:taxonrn>
																																																						<gco:CharacterString>
																																																							<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																						</gco:CharacterString>
																																																					</gmd:taxonrn>
																																																					<gmd:taxonrv>
																																																						<gco:CharacterString>
																																																							<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																						</gco:CharacterString>
																																																					</gmd:taxonrv>
																																																					<xsl:for-each select="taxoncl">
																																																						<gmd:taxonCl>
																																																							<gmd:MD_TaxonCl>
																																																								<xsl:for-each select="common">
																																																									<gmd:common>
																																																										<gco:CharacterString>
																																																											<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																										</gco:CharacterString>
																																																									</gmd:common>
																																																								</xsl:for-each>
																																																								<gmd:taxonrn>
																																																									<gco:CharacterString>
																																																										<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																									</gco:CharacterString>
																																																								</gmd:taxonrn>
																																																								<gmd:taxonrv>
																																																									<gco:CharacterString>
																																																										<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																									</gco:CharacterString>
																																																								</gmd:taxonrv>
																																																								<xsl:for-each select="taxoncl">
																																																									<gmd:taxonCl>
																																																										<gmd:MD_TaxonCl>
																																																											<xsl:for-each select="common">
																																																												<gmd:common>
																																																													<gco:CharacterString>
																																																														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																													</gco:CharacterString>
																																																												</gmd:common>
																																																											</xsl:for-each>
																																																											<gmd:taxonrn>
																																																												<gco:CharacterString>
																																																													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																												</gco:CharacterString>
																																																											</gmd:taxonrn>
																																																											<gmd:taxonrv>
																																																												<gco:CharacterString>
																																																													<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																												</gco:CharacterString>
																																																											</gmd:taxonrv>
																																																											<xsl:for-each select="taxoncl">
																																																												<gmd:taxonCl>
																																																													<gmd:MD_TaxonCl>
																																																														<xsl:for-each select="common">
																																																															<gmd:common>
																																																																<gco:CharacterString>
																																																																	<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																																</gco:CharacterString>
																																																															</gmd:common>
																																																														</xsl:for-each>
																																																														<gmd:taxonrn>
																																																															<gco:CharacterString>
																																																																<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																															</gco:CharacterString>
																																																														</gmd:taxonrn>
																																																														<gmd:taxonrv>
																																																															<gco:CharacterString>
																																																																<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																															</gco:CharacterString>
																																																														</gmd:taxonrv>
																																																														<xsl:for-each select="taxoncl">
																																																															<gmd:taxonCl>
																																																																<gmd:MD_TaxonCl>
																																																																	<xsl:for-each select="common">
																																																																		<gmd:common>
																																																																			<gco:CharacterString>
																																																																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																																																																			</gco:CharacterString>
																																																																		</gmd:common>
																																																																	</xsl:for-each>
																																																																	<gmd:taxonrn>
																																																																		<gco:CharacterString>
																																																																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(taxonrn)))"/>
																																																																		</gco:CharacterString>
																																																																	</gmd:taxonrn>
																																																																	<gmd:taxonrv>
																																																																		<gco:CharacterString>
																																																																			<xsl:sequence select="fn:normalize-space(xs:string(taxonrv))"/>
																																																																		</gco:CharacterString>
																																																																	</gmd:taxonrv>
																																																																</gmd:MD_TaxonCl>
																																																															</gmd:taxonCl>
																																																														</xsl:for-each>
																																																													</gmd:MD_TaxonCl>
																																																												</gmd:taxonCl>
																																																											</xsl:for-each>
																																																										</gmd:MD_TaxonCl>
																																																									</gmd:taxonCl>
																																																								</xsl:for-each>
																																																							</gmd:MD_TaxonCl>
																																																						</gmd:taxonCl>
																																																					</xsl:for-each>
																																																				</gmd:MD_TaxonCl>
																																																			</gmd:taxonCl>
																																																		</xsl:for-each>
																																																	</gmd:MD_TaxonCl>
																																																</gmd:taxonCl>
																																															</xsl:for-each>
																																														</gmd:MD_TaxonCl>
																																													</gmd:taxonCl>
																																												</xsl:for-each>
																																											</gmd:MD_TaxonCl>
																																										</gmd:taxonCl>
																																									</xsl:for-each>
																																								</gmd:MD_TaxonCl>
																																							</gmd:taxonCl>
																																						</xsl:for-each>
																																					</gmd:MD_TaxonCl>
																																				</gmd:taxonCl>
																																			</xsl:for-each>
																																		</gmd:MD_TaxonCl>
																																	</gmd:taxonCl>
																																</xsl:for-each>
																															</gmd:MD_TaxonCl>
																														</gmd:taxonCl>
																													</xsl:for-each>
																												</gmd:MD_TaxonCl>
																											</gmd:taxonCl>
																										</xsl:for-each>
																									</gmd:MD_TaxonCl>
																								</gmd:taxonCl>
																							</xsl:for-each>
																						</gmd:MD_TaxonCl>
																					</gmd:taxonCl>
																				</xsl:for-each>
																			</gmd:MD_TaxonCl>
																		</gmd:taxonCl>
																	</xsl:for-each>
																</gmd:MD_TaxonCl>
															</gmd:taxonCl>
														</xsl:for-each>
													</gmd:MD_TaxonCl>
												</gmd:taxonCl>
											</xsl:for-each>
										</gmd:MD_TaxonCl>
									</gmd:taxonCl>
								</gmd:MD_TaxonSys>
							</gmd:taxonomy>
						</xsl:for-each>
						<xsl:for-each select="spdoinfo">
							<gmd:spatialRepresentationType>
								<xsl:for-each select="direct">
									<xsl:variable name="var832_result_vmf15_inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf15_inputtoresult">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:if test="fn:exists($var832_result_vmf15_inputtoresult)">
										<gmd:MD_SpatialRepresentationTypeCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI($var832_result_vmf15_inputtoresult))"/>
											</xsl:attribute>
											<xsl:variable name="var833_result_vmf16_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf16_inputtoresult">
													<xsl:with-param name="input" select="$var832_result_vmf15_inputtoresult"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var833_result_vmf16_inputtoresult)">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI($var833_result_vmf16_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
											<xsl:sequence select="$var832_result_vmf15_inputtoresult"/>
										</gmd:MD_SpatialRepresentationTypeCode>
									</xsl:if>
								</xsl:for-each>
							</gmd:spatialRepresentationType>
						</xsl:for-each>
						<gmd:language>
							<gco:CharacterString>
								<xsl:sequence select="'eng; USA'"/>
							</gco:CharacterString>
						</gmd:language>
						<xsl:for-each select="idinfo/keywords/theme">
							<xsl:variable name="var834_theme" as="node()" select="."/>
							<xsl:for-each select="themekey">
								<xsl:variable name="var839_cond_result_contains" as="xs:boolean?">
									<xsl:if test="fn:contains(xs:string(xs:string($var834_theme/themekt)), 'ISO 19115')">
										<xsl:if test="fn:exists((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ()))">
											<xsl:if test="not(fn:contains(fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())), '0'))">
												<xsl:if test="(((('0' != (if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())) and ('false' != (if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ()))) and fn:boolean((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ()))) and ((('0' != fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ()))) and ('false' != fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())))) and fn:boolean(fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())))))">
													<xsl:sequence select="fn:true()"/>
												</xsl:if>
											</xsl:if>
										</xsl:if>
									</xsl:if>
								</xsl:variable>
								<xsl:if test="fn:exists($var839_cond_result_contains)">
									<gmd:topicCategory>
										<xsl:if test="fn:contains(xs:string(xs:string($var834_theme/themekt)), 'ISO 19115')">
											<xsl:if test="fn:exists((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ()))">
												<xsl:if test="not(fn:contains(fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())), '0'))">
													<xsl:variable name="var840_result_vmf17_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf17_inputtoresult">
															<xsl:with-param name="input" select="fn:lower-case(fn:normalize-space((if (((('0' != xs:string($var834_theme/themekt)) and ('false' != xs:string($var834_theme/themekt))) and fn:boolean(xs:string($var834_theme/themekt)))) then xs:string(.) else ())))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var840_result_vmf17_inputtoresult)">
														<gmd:MD_TopicCategoryCode>
															<xsl:sequence select="$var840_result_vmf17_inputtoresult"/>
														</gmd:MD_TopicCategoryCode>
													</xsl:if>
												</xsl:if>
											</xsl:if>
										</xsl:if>
									</gmd:topicCategory>
								</xsl:if>
							</xsl:for-each>
						</xsl:for-each>
						<xsl:for-each select="idinfo/native">
							<xsl:variable name="var842_native" as="node()" select="."/>
							<gmd:environmentDescription>
								<xsl:variable name="var844_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var195_metadata/distinfo/techpreq)">
											<xsl:variable name="var849_map_select_distinfo" as="xs:string*">
												<xsl:for-each select="$var195_metadata/distinfo/techpreq">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var849_map_select_distinfo)">
												<xsl:sequence select="fn:string-join($var849_map_select_distinfo, ' ')"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var844_cond_result_exists">
									<gco:CharacterString>
										<xsl:variable name="var847_cond_result_exists" as="xs:string" select="(if (fn:exists($var195_metadata/distinfo/techpreq)) then ' Technical Prerequisites: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat('Native Dataset Environment: ', xs:string($var842_native)), $var847_cond_result_exists), .)))"/>
									</gco:CharacterString>
								</xsl:for-each>
							</gmd:environmentDescription>
						</xsl:for-each>
						<gmd:extent>
							<gmd:EX_Extent>
								<xsl:attribute name="id">
									<xsl:sequence select="xs:string(xs:ID('boundingExtent'))"/>
								</xsl:attribute>
								<gmd:geographicElement>
									<xsl:for-each select="idinfo/spdom/dsgpoly">
										<xsl:variable name="var852_dsgpoly" as="node()" select="."/>
										<gmd:EX_BoundingPolygon>
											<gmd:polygon>
												<gml:Polygon>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingPolygon'))"/>
													</xsl:attribute>
													<gml:interior>
														<gml:LinearRing>
															<gml:coordinates>
																<xsl:variable name="var857_map_select_grngpoin" as="xs:string*">
																	<xsl:for-each select="dsgpolyo/grngpoin">
																		<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var854_cond_result_exists" as="xs:string*">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var857_map_select_grngpoin)">
																			<xsl:for-each select="dsgpolyo/grngpoin">
																				<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="dsgpolyo/gring">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var854_cond_result_exists">
																	<xsl:attribute name="decimal">
																		<xsl:sequence select="fn:normalize-space(.)"/>
																	</xsl:attribute>
																</xsl:for-each>
															</gml:coordinates>
														</gml:LinearRing>
													</gml:interior>
												</gml:Polygon>
											</gmd:polygon>
										</gmd:EX_BoundingPolygon>
									</xsl:for-each>
									<xsl:for-each select="idinfo/spdom">
										<gmd:EX_GeographicBoundingBox>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingGeographicBoundingBox'))"/>
											</xsl:attribute>
											<gmd:westBoundLongitude>
												<gco:Decimal>
													<xsl:sequence select="xs:string(xs:decimal(bounding/westbc))"/>
												</gco:Decimal>
											</gmd:westBoundLongitude>
											<gmd:eastBoundLongitude>
												<gco:Decimal>
													<xsl:sequence select="xs:string(xs:decimal(bounding/eastbc))"/>
												</gco:Decimal>
											</gmd:eastBoundLongitude>
											<gmd:southBoundLatitude>
												<gco:Decimal>
													<xsl:sequence select="xs:string(xs:decimal(bounding/southbc))"/>
												</gco:Decimal>
											</gmd:southBoundLatitude>
											<gmd:northBoundLatitude>
												<gco:Decimal>
													<xsl:sequence select="xs:string(xs:decimal(bounding/northbc))"/>
												</gco:Decimal>
											</gmd:northBoundLatitude>
										</gmd:EX_GeographicBoundingBox>
									</xsl:for-each>
								</gmd:geographicElement>
								<xsl:for-each select="idinfo/timeperd/timeinfo/sngdate">
									<xsl:variable name="var867_sngdate" as="node()" select="."/>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<xsl:for-each select="caldate">
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
														</xsl:attribute>
													</xsl:if>
												</xsl:for-each>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimeInstantExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="fn:normalize-space(xs:string(xs:string($var195_metadata/idinfo/timeperd/current)))"/>
													</gml:description>
													<xsl:variable name="var985_map_select_caldate" as="xs:string*">
														<xsl:for-each select="caldate">
															<xsl:variable name="var1052_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																	<xsl:variable name="var1079_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1078_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var1079_map_result_distinctvalues)">
																			<xsl:variable name="var1084_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1084_cond_result_endswith)">
																				<xsl:sequence select="$var1084_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1078_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var1078_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var1052_cond_result_logicalor">
																<xsl:variable name="var1053_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var1055_map_select_time" as="xs:string?">
																	<xsl:for-each select="$var867_sngdate/time">
																		<xsl:variable name="var1076_result_vmf6_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf6_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var1075_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1076_result_vmf6_inputtoresult)) then (if (fn:contains($var1076_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var1075_cond_result_exists))">
																			<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var1055_map_select_time)">
																	<xsl:variable name="var1060_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1060_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1060_cond_result_endswith))), 'un'))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1053_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1060_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1060_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1060_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1060_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var876_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var985_map_select_caldate)">
																<xsl:for-each select="caldate">
																	<xsl:variable name="var990_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1017_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1016_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1017_map_result_distinctvalues)">
																					<xsl:variable name="var1022_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1022_cond_result_endswith)">
																						<xsl:sequence select="$var1022_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1016_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1016_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var990_cond_result_logicalor">
																		<xsl:variable name="var991_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var993_map_select_time" as="xs:string?">
																			<xsl:for-each select="$var867_sngdate/time">
																				<xsl:variable name="var1014_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1013_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1014_result_vmf6_inputtoresult)) then (if (fn:contains($var1014_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1013_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var993_map_select_time)">
																			<xsl:variable name="var998_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var998_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var998_cond_result_endswith))), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var991_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var998_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var998_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var998_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var998_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="caldate">
																	<xsl:variable name="var1032_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1037_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1036_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1037_map_result_distinctvalues)">
																					<xsl:variable name="var1042_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1042_cond_result_endswith)">
																						<xsl:sequence select="$var1042_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1036_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1036_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1032_cond_result_logicalor">
																		<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var871_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var876_cond_result_exists">
																<xsl:variable name="var878_map_select_caldate" as="xs:string*">
																	<xsl:for-each select="caldate">
																		<xsl:variable name="var944_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var971_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var970_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var971_map_result_distinctvalues)">
																						<xsl:variable name="var976_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var976_cond_result_endswith)">
																							<xsl:sequence select="$var976_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var970_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var970_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var944_cond_result_logicalor">
																			<xsl:variable name="var945_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var947_map_select_time" as="xs:string?">
																				<xsl:for-each select="$var867_sngdate/time">
																					<xsl:variable name="var968_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var967_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var968_result_vmf6_inputtoresult)) then (if (fn:contains($var968_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:if test="not(fn:exists($var967_cond_result_exists))">
																						<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:for-each select="fn:distinct-values($var947_map_select_time)">
																				<xsl:variable name="var952_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., ':')">
																							<xsl:if test="fn:ends-with(., ':')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var952_cond_result_endswith)">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var952_cond_result_endswith))), 'un'))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var945_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var952_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var952_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var952_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var952_cond_result_endswith)))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var878_map_select_caldate)">
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var882_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var909_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var908_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var909_map_result_distinctvalues)">
																							<xsl:variable name="var914_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var914_cond_result_endswith)">
																								<xsl:sequence select="$var914_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var908_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var908_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var882_cond_result_logicalor">
																				<xsl:variable name="var883_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var885_map_select_time" as="xs:string?">
																					<xsl:for-each select="$var867_sngdate/time">
																						<xsl:variable name="var906_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var905_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var906_result_vmf6_inputtoresult)) then (if (fn:contains($var906_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var905_cond_result_exists))">
																							<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var885_map_select_time)">
																					<xsl:variable name="var890_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var890_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var890_cond_result_endswith))), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var883_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var890_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var890_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var890_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var890_cond_result_endswith)))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var924_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var929_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var928_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var929_map_result_distinctvalues)">
																							<xsl:variable name="var934_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var934_cond_result_endswith)">
																								<xsl:sequence select="$var934_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var928_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var928_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var924_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="caldate">
																	<xsl:choose>
																		<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																			<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var871_cond_result_exists">
														<gml:timePosition>
															<xsl:for-each select="$var867_sngdate/caldate">
																<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:timePosition>
													</xsl:for-each>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/sngdate/geolage">
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID(xs:string(geolscal)))"/>
													</xsl:attribute>
													<gml:name>
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(xs:string(geolscal)))"/>
														</xsl:attribute>
													</gml:name>
													<gml:timePosition>
														<xsl:attribute name="calendarEraName">
															<xsl:sequence select="xs:string(geolest)"/>
														</xsl:attribute>
													</gml:timePosition>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/mdattim/sngdate">
									<xsl:variable name="var1093_sngdate" as="node()" select="."/>
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<xsl:for-each select="caldate">
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
														</xsl:attribute>
													</xsl:if>
												</xsl:for-each>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimeInstantExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="xs:string(xs:string($var195_metadata/idinfo/timeperd/current))"/>
													</gml:description>
													<xsl:variable name="var1213_map_select_caldate" as="xs:string*">
														<xsl:for-each select="caldate">
															<xsl:variable name="var1280_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																	<xsl:variable name="var1307_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1306_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var1307_map_result_distinctvalues)">
																			<xsl:variable name="var1312_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1312_cond_result_endswith)">
																				<xsl:sequence select="$var1312_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1306_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var1306_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var1280_cond_result_logicalor">
																<xsl:variable name="var1281_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var1283_map_select_time" as="xs:string?">
																	<xsl:for-each select="$var1093_sngdate/time">
																		<xsl:variable name="var1304_result_vmf6_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf6_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var1303_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1304_result_vmf6_inputtoresult)) then (if (fn:contains($var1304_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var1303_cond_result_exists))">
																			<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var1283_map_select_time)">
																	<xsl:variable name="var1288_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1288_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1288_cond_result_endswith))), 'un'))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1281_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1288_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1288_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1288_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1288_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1104_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1213_map_select_caldate)">
																<xsl:for-each select="caldate">
																	<xsl:variable name="var1218_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1245_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1244_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1245_map_result_distinctvalues)">
																					<xsl:variable name="var1250_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1250_cond_result_endswith)">
																						<xsl:sequence select="$var1250_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1244_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1244_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1218_cond_result_logicalor">
																		<xsl:variable name="var1219_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1221_map_select_time" as="xs:string?">
																			<xsl:for-each select="$var1093_sngdate/time">
																				<xsl:variable name="var1242_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1241_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1242_result_vmf6_inputtoresult)) then (if (fn:contains($var1242_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1241_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1221_map_select_time)">
																			<xsl:variable name="var1226_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1226_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1226_cond_result_endswith))), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1219_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1226_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1226_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1226_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1226_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="caldate">
																	<xsl:variable name="var1260_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1265_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1264_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1265_map_result_distinctvalues)">
																					<xsl:variable name="var1270_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1270_cond_result_endswith)">
																						<xsl:sequence select="$var1270_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1264_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1264_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1260_cond_result_logicalor">
																		<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var1097_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var1104_cond_result_exists">
																<xsl:variable name="var1106_map_select_caldate" as="xs:string*">
																	<xsl:for-each select="caldate">
																		<xsl:variable name="var1172_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var1199_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var1198_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var1199_map_result_distinctvalues)">
																						<xsl:variable name="var1204_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1204_cond_result_endswith)">
																							<xsl:sequence select="$var1204_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1198_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var1198_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var1172_cond_result_logicalor">
																			<xsl:variable name="var1173_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var1175_map_select_time" as="xs:string?">
																				<xsl:for-each select="$var1093_sngdate/time">
																					<xsl:variable name="var1196_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1195_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1196_result_vmf6_inputtoresult)) then (if (fn:contains($var1196_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:if test="not(fn:exists($var1195_cond_result_exists))">
																						<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:for-each select="fn:distinct-values($var1175_map_select_time)">
																				<xsl:variable name="var1180_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., ':')">
																							<xsl:if test="fn:ends-with(., ':')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1180_cond_result_endswith)">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1180_cond_result_endswith))), 'un'))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1173_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1180_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1180_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1180_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1180_cond_result_endswith)))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var1106_map_select_caldate)">
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1110_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1137_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1136_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1137_map_result_distinctvalues)">
																							<xsl:variable name="var1142_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1142_cond_result_endswith)">
																								<xsl:sequence select="$var1142_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1136_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1136_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1110_cond_result_logicalor">
																				<xsl:variable name="var1111_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1113_map_select_time" as="xs:string?">
																					<xsl:for-each select="$var1093_sngdate/time">
																						<xsl:variable name="var1134_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1133_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1134_result_vmf6_inputtoresult)) then (if (fn:contains($var1134_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1133_cond_result_exists))">
																							<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1113_map_select_time)">
																					<xsl:variable name="var1118_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1118_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1118_cond_result_endswith))), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1111_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1118_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1118_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1118_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1118_cond_result_endswith)))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1152_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1157_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1156_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1157_map_result_distinctvalues)">
																							<xsl:variable name="var1162_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1162_cond_result_endswith)">
																								<xsl:sequence select="$var1162_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1156_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1156_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1152_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="caldate">
																	<xsl:choose>
																		<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																			<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1097_cond_result_exists">
														<gml:timePosition>
															<xsl:variable name="var1101_map_select_caldate" as="xs:string?">
																<xsl:for-each select="$var1093_sngdate/caldate">
																	<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																		<xsl:sequence select="'now'"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1100_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1101_map_select_caldate)) then $var1101_map_select_caldate else 'unknown')"/>
															<xsl:if test="fn:exists($var1100_cond_result_exists)">
																<xsl:attribute name="indeterminatePosition">
																	<xsl:sequence select="$var1100_cond_result_exists"/>
																</xsl:attribute>
															</xsl:if>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:timePosition>
													</xsl:for-each>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/rngdates">
									<xsl:variable name="var1319_rngdates" as="node()" select="."/>
									<gmd:temporalElement>
										<xsl:for-each select="begdate">
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
												</xsl:attribute>
											</xsl:if>
										</xsl:for-each>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<gml:TimePeriod>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID('boundingTimePeriodExtent'))"/>
													</xsl:attribute>
													<gml:description>
														<xsl:sequence select="fn:normalize-space(xs:string(xs:string($var195_metadata/idinfo/timeperd/current)))"/>
													</gml:description>
													<xsl:variable name="var1437_map_select_begdate" as="xs:string*">
														<xsl:for-each select="begdate">
															<xsl:variable name="var1504_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																	<xsl:variable name="var1531_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1530_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var1531_map_result_distinctvalues)">
																			<xsl:variable name="var1536_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1536_cond_result_endswith)">
																				<xsl:sequence select="$var1536_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1530_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var1530_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var1504_cond_result_logicalor">
																<xsl:variable name="var1505_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var1507_map_select_begtime" as="xs:string?">
																	<xsl:for-each select="$var1319_rngdates/begtime">
																		<xsl:variable name="var1528_result_vmf6_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf6_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var1527_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1528_result_vmf6_inputtoresult)) then (if (fn:contains($var1528_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var1527_cond_result_exists))">
																			<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var1507_map_select_begtime)">
																	<xsl:variable name="var1512_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1512_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1512_cond_result_endswith))), 'un'))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1505_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1512_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1512_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1512_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1512_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1328_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1437_map_select_begdate)">
																<xsl:for-each select="begdate">
																	<xsl:variable name="var1442_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1469_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1468_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1469_map_result_distinctvalues)">
																					<xsl:variable name="var1474_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1474_cond_result_endswith)">
																						<xsl:sequence select="$var1474_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1468_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1468_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1442_cond_result_logicalor">
																		<xsl:variable name="var1443_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1445_map_select_begtime" as="xs:string?">
																			<xsl:for-each select="$var1319_rngdates/begtime">
																				<xsl:variable name="var1466_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1465_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1466_result_vmf6_inputtoresult)) then (if (fn:contains($var1466_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1465_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1445_map_select_begtime)">
																			<xsl:variable name="var1450_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1450_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1450_cond_result_endswith))), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1443_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1450_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1450_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1450_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1450_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="begdate">
																	<xsl:variable name="var1484_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1489_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1488_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1489_map_result_distinctvalues)">
																					<xsl:variable name="var1494_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1494_cond_result_endswith)">
																						<xsl:sequence select="$var1494_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1488_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1488_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1484_cond_result_logicalor">
																		<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var1323_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var1328_cond_result_exists">
																<xsl:variable name="var1330_map_select_begdate" as="xs:string*">
																	<xsl:for-each select="begdate">
																		<xsl:variable name="var1396_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var1423_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var1422_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var1423_map_result_distinctvalues)">
																						<xsl:variable name="var1428_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1428_cond_result_endswith)">
																							<xsl:sequence select="$var1428_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1422_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var1422_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var1396_cond_result_logicalor">
																			<xsl:variable name="var1397_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var1399_map_select_begtime" as="xs:string?">
																				<xsl:for-each select="$var1319_rngdates/begtime">
																					<xsl:variable name="var1420_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1419_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1420_result_vmf6_inputtoresult)) then (if (fn:contains($var1420_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:if test="not(fn:exists($var1419_cond_result_exists))">
																						<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:for-each select="fn:distinct-values($var1399_map_select_begtime)">
																				<xsl:variable name="var1404_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., ':')">
																							<xsl:if test="fn:ends-with(., ':')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1404_cond_result_endswith)">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1404_cond_result_endswith))), 'un'))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1397_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1404_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1404_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1404_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1404_cond_result_endswith)))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var1330_map_select_begdate)">
																		<xsl:for-each select="begdate">
																			<xsl:variable name="var1334_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1361_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1360_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1361_map_result_distinctvalues)">
																							<xsl:variable name="var1366_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1366_cond_result_endswith)">
																								<xsl:sequence select="$var1366_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1360_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1360_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1334_cond_result_logicalor">
																				<xsl:variable name="var1335_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1337_map_select_begtime" as="xs:string?">
																					<xsl:for-each select="$var1319_rngdates/begtime">
																						<xsl:variable name="var1358_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1357_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1358_result_vmf6_inputtoresult)) then (if (fn:contains($var1358_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1357_cond_result_exists))">
																							<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1337_map_select_begtime)">
																					<xsl:variable name="var1342_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1342_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1342_cond_result_endswith))), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1335_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1342_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1342_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1342_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1342_cond_result_endswith)))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="begdate">
																			<xsl:variable name="var1376_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1381_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1380_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1381_map_result_distinctvalues)">
																							<xsl:variable name="var1386_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1386_cond_result_endswith)">
																								<xsl:sequence select="$var1386_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1380_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1380_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1376_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="begdate">
																	<xsl:choose>
																		<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																			<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1323_cond_result_exists">
														<gml:beginPosition>
															<xsl:for-each select="$var1319_rngdates/begdate">
																<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:beginPosition>
													</xsl:for-each>
													<xsl:variable name="var1657_map_select_enddate" as="xs:string*">
														<xsl:for-each select="enddate">
															<xsl:variable name="var1724_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																	<xsl:variable name="var1751_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1750_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var1751_map_result_distinctvalues)">
																			<xsl:variable name="var1756_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1756_cond_result_endswith)">
																				<xsl:sequence select="$var1756_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1750_map_result_distinctvalues)">
																		<xsl:sequence select="fn:string-join($var1750_map_result_distinctvalues, ' ')"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var1724_cond_result_logicalor">
																<xsl:variable name="var1725_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var1727_map_select_endtime" as="xs:string?">
																	<xsl:for-each select="$var1319_rngdates/endtime">
																		<xsl:variable name="var1748_result_vmf6_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf6_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var1747_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1748_result_vmf6_inputtoresult)) then (if (fn:contains($var1748_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var1747_cond_result_exists))">
																			<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var1727_map_select_endtime)">
																	<xsl:variable name="var1732_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var1732_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1732_cond_result_endswith))), 'un'))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1725_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1732_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1732_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1732_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1732_cond_result_endswith)))))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1548_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1657_map_select_enddate)">
																<xsl:for-each select="enddate">
																	<xsl:variable name="var1662_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1689_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1688_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1689_map_result_distinctvalues)">
																					<xsl:variable name="var1694_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1694_cond_result_endswith)">
																						<xsl:sequence select="$var1694_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1688_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1688_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1662_cond_result_logicalor">
																		<xsl:variable name="var1663_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1665_map_select_endtime" as="xs:string?">
																			<xsl:for-each select="$var1319_rngdates/endtime">
																				<xsl:variable name="var1686_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1685_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1686_result_vmf6_inputtoresult)) then (if (fn:contains($var1686_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1685_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1665_map_select_endtime)">
																			<xsl:variable name="var1670_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1670_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1670_cond_result_endswith))), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1663_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1670_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1670_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1670_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1670_cond_result_endswith)))))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="enddate">
																	<xsl:variable name="var1704_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																			<xsl:variable name="var1709_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1708_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1709_map_result_distinctvalues)">
																					<xsl:variable name="var1714_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1714_cond_result_endswith)">
																						<xsl:sequence select="$var1714_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1708_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var1708_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1704_cond_result_logicalor">
																		<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var1543_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var1548_cond_result_exists">
																<xsl:variable name="var1550_map_select_enddate" as="xs:string*">
																	<xsl:for-each select="enddate">
																		<xsl:variable name="var1616_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var1643_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var1642_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var1643_map_result_distinctvalues)">
																						<xsl:variable name="var1648_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1648_cond_result_endswith)">
																							<xsl:sequence select="$var1648_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1642_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var1642_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var1616_cond_result_logicalor">
																			<xsl:variable name="var1617_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var1619_map_select_endtime" as="xs:string?">
																				<xsl:for-each select="$var1319_rngdates/endtime">
																					<xsl:variable name="var1640_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:variable name="var1639_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1640_result_vmf6_inputtoresult)) then (if (fn:contains($var1640_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																					<xsl:if test="not(fn:exists($var1639_cond_result_exists))">
																						<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:for-each select="fn:distinct-values($var1619_map_select_endtime)">
																				<xsl:variable name="var1624_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., ':')">
																							<xsl:if test="fn:ends-with(., ':')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1624_cond_result_endswith)">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1624_cond_result_endswith))), 'un'))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1617_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1624_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1624_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1624_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1624_cond_result_endswith)))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var1550_map_select_enddate)">
																		<xsl:for-each select="enddate">
																			<xsl:variable name="var1554_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1581_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1580_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1581_map_result_distinctvalues)">
																							<xsl:variable name="var1586_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1586_cond_result_endswith)">
																								<xsl:sequence select="$var1586_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1580_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1580_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1554_cond_result_logicalor">
																				<xsl:variable name="var1555_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1557_map_select_endtime" as="xs:string?">
																					<xsl:for-each select="$var1319_rngdates/endtime">
																						<xsl:variable name="var1578_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1577_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1578_result_vmf6_inputtoresult)) then (if (fn:contains($var1578_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1577_cond_result_exists))">
																							<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1557_map_select_endtime)">
																					<xsl:variable name="var1562_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1562_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var1562_cond_result_endswith))), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1555_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var1562_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var1562_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var1562_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var1562_cond_result_endswith)))))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="enddate">
																			<xsl:variable name="var1596_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var1601_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1600_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1601_map_result_distinctvalues)">
																							<xsl:variable name="var1606_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1606_cond_result_endswith)">
																								<xsl:sequence select="$var1606_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1600_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var1600_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1596_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="enddate">
																	<xsl:choose>
																		<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																			<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1543_cond_result_exists">
														<gml:endPosition>
															<xsl:for-each select="$var1319_rngdates/enddate">
																<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:sequence select="xs:string(xs:string(.))"/>
														</gml:endPosition>
													</xsl:for-each>
												</gml:TimePeriod>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/mdattim/sngdate/geolage">
									<gmd:temporalElement>
										<gmd:EX_TemporalExtent>
											<xsl:attribute name="id">
												<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
											</xsl:attribute>
											<gmd:extent>
												<gml:TimeInstant>
													<xsl:attribute name="gml:id">
														<xsl:sequence select="xs:string(xs:ID(xs:string(geolscal)))"/>
													</xsl:attribute>
													<xsl:attribute name="frame">
														<xsl:sequence select="xs:string(xs:anyURI(xs:string(geolscal)))"/>
													</xsl:attribute>
													<gml:name>
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(xs:string(geolscal)))"/>
														</xsl:attribute>
														<xsl:sequence select="xs:string(xs:string(geolscal))"/>
													</gml:name>
													<gml:timePosition>
														<xsl:attribute name="calendarEraName">
															<xsl:sequence select="xs:string(geolest)"/>
														</xsl:attribute>
														<xsl:sequence select="xs:string(xs:string(xs:string(geolest)))"/>
													</gml:timePosition>
												</gml:TimeInstant>
											</gmd:extent>
										</gmd:EX_TemporalExtent>
									</gmd:temporalElement>
								</xsl:for-each>
								<xsl:for-each select="idinfo/timeperd/timeinfo/rngdates">
									<xsl:variable name="var1765_rngdates" as="node()" select="."/>
									<xsl:for-each select="beggeol">
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id">
													<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
												</xsl:attribute>
												<gmd:extent>
													<gml:TimePeriod>
														<xsl:attribute name="gml:id">
															<xsl:sequence select="xs:string(xs:ID('boundingTimePeriodExtent'))"/>
														</xsl:attribute>
														<gml:begin>
															<gml:TimeInstant>
																<xsl:attribute name="gml:id">
																	<xsl:sequence select="xs:string(xs:ID(fn:normalize-space(xs:string(xs:string(geolage/geolscal)))))"/>
																</xsl:attribute>
																<gml:name>
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(xs:string(geolage/geolscal)))))"/>
																	</xsl:attribute>
																	<xsl:sequence select="xs:string(xs:string(geolage/geolscal))"/>
																</gml:name>
																<gml:timePosition>
																	<xsl:attribute name="calendarEraName">
																		<xsl:sequence select="fn:normalize-space(xs:string(geolage/geolest))"/>
																	</xsl:attribute>
																	<xsl:sequence select="xs:string(xs:string(xs:string(geolage/geolest)))"/>
																</gml:timePosition>
															</gml:TimeInstant>
														</gml:begin>
														<xsl:for-each select="$var1765_rngdates/endgeol">
															<gml:end>
																<gml:TimeInstant>
																	<gml:name>
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(xs:string(geolage/geolscal)))))"/>
																		</xsl:attribute>
																		<xsl:sequence select="xs:string(xs:string(geolage/geolscal))"/>
																	</gml:name>
																	<gml:timePosition>
																		<xsl:attribute name="calendarEraName">
																			<xsl:sequence select="fn:normalize-space(xs:string(geolage/geolest))"/>
																		</xsl:attribute>
																		<xsl:sequence select="xs:string(xs:string(xs:string(geolage/geolest)))"/>
																	</gml:timePosition>
																</gml:TimeInstant>
															</gml:end>
														</xsl:for-each>
													</gml:TimePeriod>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
								</xsl:for-each>
							</gmd:EX_Extent>
						</gmd:extent>
						<xsl:for-each select="idinfo/descript/supplinf">
							<gmd:supplementalInformation>
								<gco:CharacterString>
									<xsl:sequence select="xs:string(.)"/>
								</gco:CharacterString>
							</gmd:supplementalInformation>
						</xsl:for-each>
					</gmd:MD_DataIdentification>
				</gmd:identificationInfo>
			</xsl:for-each>
			<gmd:contentInfo>
				<gmd:MD_FeatureCatalogueDescription>
					<gmd:includedWithDataset>
						<gco:Boolean>
							<xsl:variable name="var1773_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
							<xsl:sequence select="xs:string(fn:boolean($var1773_cond_result_exists))"/>
						</gco:Boolean>
					</gmd:includedWithDataset>
					<xsl:for-each select="$var1_instance/metadata/eainfo/detailed">
						<gmd:featureTypes>
							<gco:LocalName>
								<xsl:attribute name="codeSpace">
									<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(enttyp/enttypl))))"/>
								</xsl:attribute>
							</gco:LocalName>
						</gmd:featureTypes>
					</xsl:for-each>
					<gmd:featureCatalogueCitation>
						<xsl:variable name="var1776_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
						<xsl:if test="fn:exists((if ((xs:string($var1776_cond_result_exists) = 'false')) then () else 'unknown'))">
							<xsl:attribute name="gco:nilReason">
								<xsl:sequence select="xs:string(xs:string((if ((xs:string($var1776_cond_result_exists) = 'false')) then () else 'unknown')))"/>
							</xsl:attribute>
						</xsl:if>
						<xsl:variable name="var1777_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eaover)) then 'Entity and Attribute Overview: ' else ())"/>
						<xsl:if test="fn:exists($var1777_cond_result_exists)">
							<xsl:variable name="var1778_cond_result_exists" as="xs:string?">
								<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eaover)">
									<xsl:variable name="var1790_map_select_metadata" as="xs:string*">
										<xsl:for-each select="$var1_instance/metadata/eainfo/overview">
											<xsl:sequence select="xs:string(eaover)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var1790_map_select_metadata)">
										<xsl:sequence select="fn:string-join($var1790_map_select_metadata, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var1778_cond_result_exists">
								<xsl:variable name="var1779_cur_cond_result_exists" as="xs:string" select="."/>
								<xsl:variable name="var1781_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)) then '   Entity and Attribute Detail Citation: ' else ())"/>
								<xsl:if test="fn:exists($var1781_cond_result_exists)">
									<xsl:variable name="var1782_cond_result_exists" as="xs:string?">
										<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)">
											<xsl:variable name="var1786_map_select_metadata" as="xs:string*">
												<xsl:for-each select="$var1_instance/metadata/eainfo/overview/eadetcit">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var1786_map_select_metadata)">
												<xsl:sequence select="fn:string-join($var1786_map_select_metadata, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var1782_cond_result_exists">
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:sequence select="'Entity and Attribute Information'"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string('unknown'))"/>
												</xsl:attribute>
											</gmd:date>
											<gmd:otherCitationDetails>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat($var1777_cond_result_exists, $var1779_cur_cond_result_exists), $var1781_cond_result_exists), .))"/>
												</gco:CharacterString>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</xsl:for-each>
								</xsl:if>
							</xsl:for-each>
						</xsl:if>
					</gmd:featureCatalogueCitation>
				</gmd:MD_FeatureCatalogueDescription>
				<xsl:for-each select="$var1_instance/metadata/dataqual/cloud">
					<gmd:MD_ImageDescription>
						<gmd:cloudCoverPercentage>
							<xsl:if test="fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown')">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(fn:lower-case(xs:string(xs:string(.)))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:if test="not(fn:contains(fn:lower-case(xs:string(xs:string(.))), 'unknown'))">
								<gco:Real>
									<xsl:sequence select="xs:string(xs:double(xs:string(.)))"/>
								</gco:Real>
							</xsl:if>
						</gmd:cloudCoverPercentage>
					</gmd:MD_ImageDescription>
				</xsl:for-each>
			</gmd:contentInfo>
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform">
						<xsl:variable name="var1795_digform" as="node()" select="."/>
						<gmd:distributionFormat>
							<gmd:MD_Format>
								<gmd:name>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(xs:string(digtinfo/formname)))"/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:version>
									<xsl:variable name="var1797_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="$var1795_digform/digtinfo/formvern">
												<xsl:for-each select="digtinfo/formvern">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="'unknown'"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var1797_cond_result_exists)">
										<xsl:if test="fn:exists((if (($var1797_cond_result_exists = 'unknown')) then 'unknown' else ()))">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string((if (($var1797_cond_result_exists = 'unknown')) then 'unknown' else ())))"/>
											</xsl:attribute>
										</xsl:if>
									</xsl:if>
									<xsl:for-each select="digtinfo/formvern">
										<xsl:variable name="var1804_cond_result_equal" as="xs:string?">
											<xsl:if test="not((fn:lower-case(xs:string(.)) = 'unknown'))">
												<xsl:variable name="var1808_map_select_formverd" as="xs:string?">
													<xsl:for-each select="$var1795_digform/digtinfo/formverd">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var1807_cond_result_exists" as="xs:string?">
													<xsl:if test="fn:exists($var1808_map_select_formverd)">
														<xsl:for-each select="$var1795_digform/digtinfo/formverd">
															<xsl:sequence select="fn:string(.)"/>
														</xsl:for-each>
													</xsl:if>
												</xsl:variable>
												<xsl:if test="fn:exists($var1807_cond_result_exists)">
													<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(xs:string(.), $var1807_cond_result_exists)))"/>
												</xsl:if>
											</xsl:if>
										</xsl:variable>
										<xsl:if test="fn:exists($var1804_cond_result_equal)">
											<gco:CharacterString>
												<xsl:sequence select="$var1804_cond_result_equal"/>
											</gco:CharacterString>
										</xsl:if>
									</xsl:for-each>
								</gmd:version>
								<xsl:for-each select="digtinfo/formspec">
									<gmd:specification>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
										</gco:CharacterString>
									</gmd:specification>
								</xsl:for-each>
								<xsl:for-each select="digtinfo/filedec">
									<gmd:fileDecompressionTechnique>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
										</gco:CharacterString>
									</gmd:fileDecompressionTechnique>
								</xsl:for-each>
							</gmd:MD_Format>
						</gmd:distributionFormat>
					</xsl:for-each>
					<xsl:for-each select="$var1_instance/metadata/distinfo">
						<xsl:variable name="var1818_distinfo" as="node()" select="."/>
						<gmd:distributor>
							<gmd:MD_Distributor>
								<gmd:distributorContact>
									<gmd:CI_ResponsibleParty>
										<xsl:variable name="var1821_map_select_cntperp" as="xs:string?">
											<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var1820_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var1821_map_select_cntperp)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntper">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var1820_cond_result_exists)">
											<gmd:individualName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var1820_cond_result_exists)"/>
												</gco:CharacterString>
											</gmd:individualName>
										</xsl:if>
										<xsl:variable name="var1830_map_select_cntperp" as="xs:string?">
											<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var1829_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var1830_map_select_cntperp)">
													<xsl:for-each select="distrib/cntinfo/cntperp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="distrib/cntinfo/cntorgp/cntorg">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:if test="fn:exists($var1829_cond_result_exists)">
											<gmd:organisationName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space($var1829_cond_result_exists)"/>
												</gco:CharacterString>
											</gmd:organisationName>
										</xsl:if>
										<xsl:for-each select="distrib/cntinfo/cntpos">
											<gmd:positionName>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:positionName>
										</xsl:for-each>
										<gmd:contactInfo>
											<gmd:CI_Contact>
												<gmd:phone>
													<gmd:CI_Telephone>
														<xsl:for-each-group select="distrib/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var1842_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:voice>
																<gco:CharacterString>
																	<xsl:sequence select="$var1842_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:voice>
														</xsl:for-each-group>
														<xsl:for-each-group select="distrib/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
															<xsl:variable name="var1846_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:facsimile>
																<gco:CharacterString>
																	<xsl:sequence select="$var1846_cur_result_groupby"/>
																</gco:CharacterString>
															</gmd:facsimile>
														</xsl:for-each-group>
													</gmd:CI_Telephone>
												</gmd:phone>
												<xsl:for-each select="distrib/cntinfo/cntaddr">
													<gmd:address>
														<gmd:CI_Address>
															<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var1852_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:deliveryPoint>
																	<gco:CharacterString>
																		<xsl:sequence select="$var1852_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:deliveryPoint>
															</xsl:for-each-group>
															<gmd:city>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
																</gco:CharacterString>
															</gmd:city>
															<gmd:administrativeArea>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
																</gco:CharacterString>
															</gmd:administrativeArea>
															<gmd:postalCode>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
																</gco:CharacterString>
															</gmd:postalCode>
															<xsl:for-each select="country">
																<gmd:country>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:country>
															</xsl:for-each>
															<xsl:for-each-group select="$var1818_distinfo/distrib/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var1858_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:electronicMailAddress>
																	<gco:CharacterString>
																		<xsl:sequence select="$var1858_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:electronicMailAddress>
															</xsl:for-each-group>
														</gmd:CI_Address>
													</gmd:address>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/hours">
													<gmd:hoursOfService>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(fn:normalize-space(xs:string(.)))"/>
														</gco:CharacterString>
													</gmd:hoursOfService>
												</xsl:for-each>
												<xsl:for-each select="distrib/cntinfo/cntinst">
													<gmd:contactInstructions>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(fn:normalize-space(xs:string(.)))"/>
														</gco:CharacterString>
													</gmd:contactInstructions>
												</xsl:for-each>
											</gmd:CI_Contact>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('distributor'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
												</xsl:attribute>
												<xsl:sequence select="'distributor'"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:distributorContact>
								<xsl:for-each select="stdorder">
									<xsl:variable name="var1864_stdorder" as="node()" select="."/>
									<gmd:distributionOrderProcess>
										<gmd:MD_StandardOrderProcess>
											<gmd:fees>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(fees))"/>
												</gco:CharacterString>
											</gmd:fees>
											<xsl:for-each select="$var1818_distinfo/availabl">
												<xsl:variable name="var1866_availabl" as="node()" select="."/>
												<gmd:plannedAvailableDateTime>
													<xsl:variable name="var2094_map_select_sngdate" as="xs:string?">
														<xsl:for-each select="timeinfo/sngdate">
															<xsl:variable name="var2206_sngdate" as="node()" select="."/>
															<xsl:for-each select="caldate">
																<xsl:variable name="var2211_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																		<xsl:variable name="var2249_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2248_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var2249_map_result_distinctvalues)">
																				<xsl:variable name="var2254_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2254_cond_result_endswith)">
																					<xsl:sequence select="$var2254_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2248_map_result_distinctvalues)">
																			<xsl:sequence select="fn:string-join($var2248_map_result_distinctvalues, ' ')"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var2211_cond_result_logicalor">
																	<xsl:variable name="var2212_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var2214_cond_result_exists" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1866_availabl/timeinfo/sngdate/time)">
																				<xsl:variable name="var2220_map_select_time" as="xs:string?">
																					<xsl:for-each select="$var2206_sngdate/time">
																						<xsl:variable name="var2233_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var2232_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2233_result_vmf6_inputtoresult)) then (if (fn:contains($var2233_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var2232_cond_result_exists))">
																							<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2219_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2220_map_select_time)">
																						<xsl:variable name="var2225_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2225_cond_result_endswith)">
																							<xsl:sequence select="fn:string($var2225_cond_result_endswith)"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2219_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2219_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:variable name="var2246_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var2245_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2246_result_vmf6_inputtoresult)) then (if (fn:contains($var2246_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:variable name="var2235_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2245_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																				<xsl:variable name="var2234_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2235_cond_result_exists)">
																						<xsl:variable name="var2240_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2240_cond_result_endswith)">
																							<xsl:sequence select="fn:string($var2240_cond_result_endswith)"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2234_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2234_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2214_cond_result_exists">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																			<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2212_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1871_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var2094_map_select_sngdate)">
																<xsl:for-each select="timeinfo/sngdate">
																	<xsl:variable name="var2096_sngdate" as="node()" select="."/>
																	<xsl:for-each select="caldate">
																		<xsl:variable name="var2101_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var2139_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2138_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2139_map_result_distinctvalues)">
																						<xsl:variable name="var2144_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2144_cond_result_endswith)">
																							<xsl:sequence select="$var2144_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2138_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2138_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2101_cond_result_logicalor">
																			<xsl:variable name="var2102_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var2104_cond_result_exists" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var1866_availabl/timeinfo/sngdate/time)">
																						<xsl:variable name="var2110_map_select_time" as="xs:string?">
																							<xsl:for-each select="$var2096_sngdate/time">
																								<xsl:variable name="var2123_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var2122_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2123_result_vmf6_inputtoresult)) then (if (fn:contains($var2123_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var2122_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2109_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2110_map_select_time)">
																								<xsl:variable name="var2115_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2115_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2115_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2109_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2109_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2136_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var2135_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2136_result_vmf6_inputtoresult)) then (if (fn:contains($var2136_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:variable name="var2125_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2135_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																						<xsl:variable name="var2124_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2125_cond_result_exists)">
																								<xsl:variable name="var2130_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2130_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2130_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2124_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2124_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var2104_cond_result_exists">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2102_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="timeinfo/mdattim/sngdate">
																	<xsl:variable name="var2151_sngdate" as="node()" select="."/>
																	<xsl:for-each select="caldate">
																		<xsl:variable name="var2156_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var2194_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2193_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2194_map_result_distinctvalues)">
																						<xsl:variable name="var2199_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2199_cond_result_endswith)">
																							<xsl:sequence select="$var2199_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2193_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2193_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2156_cond_result_logicalor">
																			<xsl:variable name="var2157_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var2159_cond_result_exists" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var1866_availabl/timeinfo/mdattim/sngdate/time)">
																						<xsl:variable name="var2165_map_select_time" as="xs:string?">
																							<xsl:for-each select="$var2151_sngdate/time">
																								<xsl:variable name="var2178_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var2177_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2178_result_vmf6_inputtoresult)) then (if (fn:contains($var2178_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var2177_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2164_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2165_map_select_time)">
																								<xsl:variable name="var2170_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2170_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2170_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2164_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2164_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2191_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var2190_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2191_result_vmf6_inputtoresult)) then (if (fn:contains($var2191_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:variable name="var2180_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2190_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																						<xsl:variable name="var2179_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2180_cond_result_exists)">
																								<xsl:variable name="var2185_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2185_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2185_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2179_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2179_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var2159_cond_result_exists">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2157_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="var1868_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="$var1871_cond_result_exists">
																<xsl:variable name="var1873_map_select_sngdate" as="xs:string?">
																	<xsl:for-each select="timeinfo/sngdate">
																		<xsl:variable name="var1984_sngdate" as="node()" select="."/>
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1989_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																					<xsl:variable name="var2027_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2026_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2027_map_result_distinctvalues)">
																							<xsl:variable name="var2032_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2032_cond_result_endswith)">
																								<xsl:sequence select="$var2032_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2026_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2026_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1989_cond_result_logicalor">
																				<xsl:variable name="var1990_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1992_cond_result_exists" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var1866_availabl/timeinfo/sngdate/time)">
																							<xsl:variable name="var1998_map_select_time" as="xs:string?">
																								<xsl:for-each select="$var1984_sngdate/time">
																									<xsl:variable name="var2011_result_vmf6_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf6_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var2010_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2011_result_vmf6_inputtoresult)) then (if (fn:contains($var2011_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var2010_cond_result_exists))">
																										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1997_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1998_map_select_time)">
																									<xsl:variable name="var2003_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2003_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var2003_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1997_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var1997_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:variable name="var2024_result_vmf6_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf6_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var2023_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2024_result_vmf6_inputtoresult)) then (if (fn:contains($var2024_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:variable name="var2013_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2023_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																							<xsl:variable name="var2012_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var2013_cond_result_exists)">
																									<xsl:variable name="var2018_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2018_cond_result_endswith)">
																										<xsl:sequence select="fn:string($var2018_cond_result_endswith)"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2012_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var2012_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var1992_cond_result_exists">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1990_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="fn:exists($var1873_map_select_sngdate)">
																		<xsl:for-each select="timeinfo/sngdate">
																			<xsl:variable name="var1874_sngdate" as="node()" select="."/>
																			<xsl:for-each select="caldate">
																				<xsl:variable name="var1879_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																						<xsl:variable name="var1917_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1916_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1917_map_result_distinctvalues)">
																								<xsl:variable name="var1922_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1922_cond_result_endswith)">
																									<xsl:sequence select="$var1922_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1916_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var1916_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var1879_cond_result_logicalor">
																					<xsl:variable name="var1880_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1882_cond_result_exists" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var1866_availabl/timeinfo/sngdate/time)">
																								<xsl:variable name="var1888_map_select_time" as="xs:string?">
																									<xsl:for-each select="$var1874_sngdate/time">
																										<xsl:variable name="var1901_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var1900_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1901_result_vmf6_inputtoresult)) then (if (fn:contains($var1901_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var1900_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var1887_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1888_map_select_time)">
																										<xsl:variable name="var1893_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1893_cond_result_endswith)">
																											<xsl:sequence select="fn:string($var1893_cond_result_endswith)"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1887_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1887_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:variable name="var1914_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1913_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1914_result_vmf6_inputtoresult)) then (if (fn:contains($var1914_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:variable name="var1903_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1913_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																								<xsl:variable name="var1902_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1903_cond_result_exists)">
																										<xsl:variable name="var1908_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1908_cond_result_endswith)">
																											<xsl:sequence select="fn:string($var1908_cond_result_endswith)"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1902_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1902_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var1882_cond_result_exists">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1880_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="timeinfo/mdattim/sngdate">
																			<xsl:variable name="var1929_sngdate" as="node()" select="."/>
																			<xsl:for-each select="caldate">
																				<xsl:variable name="var1934_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																						<xsl:variable name="var1972_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1971_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1972_map_result_distinctvalues)">
																								<xsl:variable name="var1977_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1977_cond_result_endswith)">
																									<xsl:sequence select="$var1977_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1971_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var1971_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var1934_cond_result_logicalor">
																					<xsl:variable name="var1935_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1937_cond_result_exists" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var1866_availabl/timeinfo/mdattim/sngdate/time)">
																								<xsl:variable name="var1943_map_select_time" as="xs:string?">
																									<xsl:for-each select="$var1929_sngdate/time">
																										<xsl:variable name="var1956_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var1955_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1956_result_vmf6_inputtoresult)) then (if (fn:contains($var1956_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var1955_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var1942_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1943_map_select_time)">
																										<xsl:variable name="var1948_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1948_cond_result_endswith)">
																											<xsl:sequence select="fn:string($var1948_cond_result_endswith)"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1942_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1942_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:variable name="var1969_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1968_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1969_result_vmf6_inputtoresult)) then (if (fn:contains($var1969_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:variable name="var1958_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1968_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																								<xsl:variable name="var1957_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var1958_cond_result_exists)">
																										<xsl:variable name="var1963_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var1963_cond_result_endswith)">
																											<xsl:sequence select="fn:string($var1963_cond_result_endswith)"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1957_map_result_distinctvalues)">
																									<xsl:sequence select="fn:string-join($var1957_map_result_distinctvalues, ' ')"/>
																								</xsl:if>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var1937_cond_result_exists">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																							<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1935_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="timeinfo/rngdates">
																	<xsl:variable name="var2039_rngdates" as="node()" select="."/>
																	<xsl:for-each select="begdate">
																		<xsl:variable name="var2044_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																				<xsl:variable name="var2082_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2081_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2082_map_result_distinctvalues)">
																						<xsl:variable name="var2087_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2087_cond_result_endswith)">
																							<xsl:sequence select="$var2087_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2081_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2081_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2044_cond_result_logicalor">
																			<xsl:variable name="var2045_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:variable name="var2047_cond_result_exists" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var1866_availabl/timeinfo/rngdates/begtime)">
																						<xsl:variable name="var2053_map_select_begtime" as="xs:string?">
																							<xsl:for-each select="$var2039_rngdates/begtime">
																								<xsl:variable name="var2066_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var2065_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2066_result_vmf6_inputtoresult)) then (if (fn:contains($var2066_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var2065_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2052_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2053_map_select_begtime)">
																								<xsl:variable name="var2058_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2058_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2058_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2052_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2052_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:variable name="var2079_result_vmf6_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf6_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string('000000')))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var2078_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2079_result_vmf6_inputtoresult)) then (if (fn:contains($var2079_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:variable name="var2068_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2078_cond_result_exists)) then () else fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string('000000')), xs:double('5'), xs:double(xs:decimal(2))))))"/>
																						<xsl:variable name="var2067_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2068_cond_result_exists)">
																								<xsl:variable name="var2073_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2073_cond_result_endswith)">
																									<xsl:sequence select="fn:string($var2073_cond_result_endswith)"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2067_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2067_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var2047_cond_result_exists">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																					<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2045_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1868_cond_result_exists">
														<gco:DateTime>
															<xsl:sequence select="xs:string(xs:dateTime(.))"/>
														</gco:DateTime>
													</xsl:for-each>
												</gmd:plannedAvailableDateTime>
											</xsl:for-each>
											<xsl:for-each select="ordering">
												<xsl:variable name="var2261_ordering" as="node()" select="."/>
												<gmd:orderingInstructions>
													<xsl:variable name="var2263_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var1864_stdorder/digform/digtopt/onlinopt/accinstr)">
																<xsl:variable name="var2278_map_select_digform" as="xs:string*">
																	<xsl:for-each select="$var1864_stdorder/digform/digtopt/onlinopt/accinstr">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var2278_map_select_digform)">
																	<xsl:sequence select="fn:string-join($var2278_map_select_digform, ' ')"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="' '"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var2263_cond_result_exists">
														<xsl:variable name="var2266_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="$var1864_stdorder/nondig">
																	<xsl:for-each select="$var1864_stdorder/nondig">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="' '"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:if test="fn:exists($var2266_cond_result_exists)">
															<xsl:variable name="var2267_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="$var1818_distinfo/custom">
																		<xsl:for-each select="$var1818_distinfo/custom">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var2267_cond_result_exists)">
																<gco:CharacterString>
																	<xsl:variable name="var2268_cond_result_exists" as="xs:string" select="(if (fn:exists($var1864_stdorder/digform/digtopt/onlinopt/accinstr)) then 'Access Instructions: ' else ' ')"/>
																	<xsl:variable name="var2269_cond_result_exists" as="xs:string" select="(if (fn:exists($var1864_stdorder/nondig)) then 'Non-Digital Form: ' else ' ')"/>
																	<xsl:variable name="var2270_cond_result_exists" as="xs:string" select="(if (fn:exists($var1818_distinfo/custom)) then ' Custom Order Process: ' else ' ')"/>
																	<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat($var2268_cond_result_exists, .), $var2269_cond_result_exists), ' '), $var2266_cond_result_exists), ' '), 'Ordering Instructions: '), ' '), xs:string($var2261_ordering)), $var2270_cond_result_exists), $var2267_cond_result_exists)))"/>
																</gco:CharacterString>
															</xsl:if>
														</xsl:if>
													</xsl:for-each>
												</gmd:orderingInstructions>
											</xsl:for-each>
											<xsl:for-each select="turnarnd">
												<gmd:turnaround>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:turnaround>
											</xsl:for-each>
										</gmd:MD_StandardOrderProcess>
									</gmd:distributionOrderProcess>
								</xsl:for-each>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					<gmd:transferOptions>
						<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/transize">
								<gmd:transferSize>
									<gco:Real>
										<xsl:sequence select="xs:string(xs:double(.))"/>
									</gco:Real>
								</gmd:transferSize>
							</xsl:for-each>
							<xsl:variable name="var2285_map_select_metadata" as="xs:string*">
								<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:for-each select="fn:distinct-values($var2285_map_select_metadata)">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<gmd:URL>
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
											</gmd:URL>
										</gmd:linkage>
										<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/onlinopt/oncomp">
											<gmd:description>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:description>
										</xsl:for-each>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/idinfo/citation/citeinfo/onlink">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<xsl:for-each select="fn:distinct-values(xs:string(.))">
												<gmd:URL>
													<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
												</gmd:URL>
											</xsl:for-each>
										</gmd:linkage>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
						</gmd:MD_DigitalTransferOptions>
					</gmd:transferOptions>
					<xsl:for-each-group select="$var1_instance/metadata/distinfo/stdorder/digform/digtopt/offoptn" group-by="xs:string(xs:string(offmedia))">
						<xsl:variable name="var2297_cur_result_groupby" as="item()+" select="current-group()"/>
						<gmd:transferOptions>
							<gmd:MD_DigitalTransferOptions>
								<gmd:offLine>
									<gmd:MD_Medium>
										<gmd:name>
											<xsl:variable name="var2337_map_result_groupitems" as="xs:string+">
												<xsl:for-each select="$var2297_cur_result_groupby">
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2336_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var2337_map_result_groupitems)">
													<xsl:variable name="var2340_result_vmf18_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf18_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(.)"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var2340_result_vmf18_inputtoresult)">
														<xsl:sequence select="$var2340_result_vmf18_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2327_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2336_map_result_distinctvalues)) then fn:string-join($var2336_map_result_distinctvalues, ' ') else ())"/>
											<xsl:variable name="var2300_cond_result_exists" as="xs:string?">
												<xsl:if test="$var2327_cond_result_exists">
													<xsl:variable name="var2330_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var2297_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2329_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var2330_map_result_groupitems)">
															<xsl:variable name="var2333_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var2333_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var2333_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var2329_map_result_distinctvalues)">
														<xsl:sequence select="fn:string-join($var2329_map_result_distinctvalues, ' ')"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var2300_cond_result_exists)">
												<gmd:MD_MediumNameCode>
													<xsl:variable name="var2304_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var2297_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2303_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var2304_map_result_groupitems)">
															<xsl:variable name="var2307_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var2307_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var2307_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2302_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2303_map_result_distinctvalues)) then fn:string-join($var2303_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var2301_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2302_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode' else ())"/>
													<xsl:if test="fn:exists($var2301_cond_result_exists)">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI($var2301_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI($var2300_cond_result_exists))"/>
													</xsl:attribute>
													<xsl:variable name="var2321_map_result_groupitems" as="xs:string+">
														<xsl:for-each select="$var2297_cur_result_groupby">
															<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2320_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var2321_map_result_groupitems)">
															<xsl:variable name="var2324_result_vmf18_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf18_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(.)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var2324_result_vmf18_inputtoresult)">
																<xsl:sequence select="$var2324_result_vmf18_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2311_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2320_map_result_distinctvalues)) then fn:string-join($var2320_map_result_distinctvalues, ' ') else ())"/>
													<xsl:variable name="var2310_cond_result_exists" as="xs:string?">
														<xsl:if test="$var2311_cond_result_exists">
															<xsl:variable name="var2314_map_result_groupitems" as="xs:string+">
																<xsl:for-each select="$var2297_cur_result_groupby">
																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(offmedia)))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var2313_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var2314_map_result_groupitems)">
																	<xsl:variable name="var2317_result_vmf19_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf19_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(.)"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2317_result_vmf19_inputtoresult)">
																		<xsl:sequence select="$var2317_result_vmf19_inputtoresult"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var2313_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var2313_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var2310_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI($var2310_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var2300_cond_result_exists"/>
												</gmd:MD_MediumNameCode>
											</xsl:if>
										</gmd:name>
										<xsl:for-each select="$var2297_cur_result_groupby/reccap/recden">
											<gmd:density>
												<gco:Real>
													<xsl:sequence select="xs:string(xs:double(.))"/>
												</gco:Real>
											</gmd:density>
										</xsl:for-each>
										<xsl:for-each select="$var2297_cur_result_groupby/reccap">
											<gmd:densityUnits>
												<gco:CharacterString>
													<xsl:sequence select="xs:string(recdenu)"/>
												</gco:CharacterString>
											</gmd:densityUnits>
										</xsl:for-each>
										<gmd:mediumFormat>
											<xsl:variable name="var2357_map_result_groupitems" as="xs:string*">
												<xsl:for-each select="$var2297_cur_result_groupby/recfmt">
													<xsl:variable name="var2360_result_vmf20_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf20_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var2360_result_vmf20_inputtoresult)">
														<xsl:sequence select="$var2360_result_vmf20_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2347_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2357_map_result_groupitems)) then fn:string-join($var2357_map_result_groupitems, ' ') else ())"/>
											<xsl:for-each select="$var2347_cond_result_exists">
												<gmd:MD_MediumFormatCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(.))"/>
													</xsl:attribute>
													<xsl:variable name="var2353_map_result_groupitems" as="xs:string*">
														<xsl:for-each select="$var2297_cur_result_groupby/recfmt">
															<xsl:variable name="var2356_result_vmf21_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf21_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var2356_result_vmf21_inputtoresult)">
																<xsl:sequence select="$var2356_result_vmf21_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var2350_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2353_map_result_groupitems)) then fn:string-join($var2353_map_result_groupitems, ' ') else ())"/>
													<xsl:for-each select="$var2350_cond_result_exists">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(.))"/>
														</xsl:attribute>
													</xsl:for-each>
													<xsl:sequence select="."/>
												</gmd:MD_MediumFormatCode>
											</xsl:for-each>
										</gmd:mediumFormat>
										<xsl:variable name="var2361_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
										<xsl:if test="fn:exists($var2361_cond_result_exists)">
											<xsl:for-each select="$var1_instance/metadata/distinfo/stdorder/digform/digtinfo/formcont">
												<xsl:variable name="var2362_formcont" as="node()" select="."/>
												<xsl:variable name="var2364_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2297_cur_result_groupby/compat)) then ' Compatibility Information: ' else ())"/>
												<xsl:if test="fn:exists($var2364_cond_result_exists)">
													<xsl:for-each select="$var2297_cur_result_groupby/compat">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:sequence select="fn:concat(fn:concat(fn:concat($var2361_cond_result_exists, fn:normalize-space(xs:string($var2362_formcont))), $var2364_cond_result_exists), xs:string(.))"/>
															</gco:CharacterString>
														</gmd:mediumNote>
													</xsl:for-each>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</gmd:MD_Medium>
								</gmd:offLine>
							</gmd:MD_DigitalTransferOptions>
						</gmd:transferOptions>
					</xsl:for-each-group>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var2367_metadata" as="node()" select="."/>
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string('unknown'))"/>
								</xsl:attribute>
							</gmd:scope>
							<xsl:for-each select="posacc/horizpa">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:sequence select="'Horizontal Positional Accuracy'"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="qhorizpa">
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(horizpae))"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(horizpar))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:attribute name="gml:id">
															<xsl:sequence select="xs:string(xs:ID('meters'))"/>
														</xsl:attribute>
														<gml:identifier>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('meters'))"/>
															</xsl:attribute>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:attribute name="xlink:href">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/>
															</xsl:attribute>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="qhorizpa">
														<gco:Record>
															<xsl:sequence select="fn:normalize-space(xs:string(xs:double(horizpav)))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="posacc/vertacc">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:sequence select="'Vertical Positional Accuracy'"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="qvertpa">
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(vertacce))"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(vertaccr))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:attribute name="gml:id">
															<xsl:sequence select="xs:string(xs:ID('meters'))"/>
														</xsl:attribute>
														<gml:identifier>
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI('meters'))"/>
															</xsl:attribute>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:attribute name="xlink:href">
																<xsl:sequence select="xs:string(xs:anyURI('http://www.bipm.org/en/si/'))"/>
															</xsl:attribute>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="qvertpa">
														<gco:Record>
															<xsl:sequence select="fn:normalize-space(xs:string(xs:double(vertaccv)))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<gmd:report>
								<gmd:DQ_CompletenessCommission>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(complete))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_CompletenessCommission>
							</gmd:report>
							<gmd:report>
								<gmd:DQ_CompletenessOmission>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(complete))"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<xsl:variable name="var2383_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var2367_metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
										<xsl:if test="fn:exists((if ((xs:string($var2383_cond_result_exists) = 'false')) then () else 'unknown'))">
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string((if ((xs:string($var2383_cond_result_exists) = 'false')) then () else 'unknown')))"/>
											</xsl:attribute>
										</xsl:if>
									</gmd:result>
								</gmd:DQ_CompletenessOmission>
							</gmd:report>
							<gmd:report>
								<gmd:DQ_ConceptualConsistency>
									<gmd:measureDescription>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(xs:string(logic)))"/>
										</gco:CharacterString>
									</gmd:measureDescription>
									<gmd:result>
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string('unknown'))"/>
										</xsl:attribute>
									</gmd:result>
								</gmd:DQ_ConceptualConsistency>
							</gmd:report>
							<xsl:for-each select="attracc">
								<xsl:variable name="var2384_attracc" as="node()" select="."/>
								<xsl:for-each select="qattracc">
									<gmd:report>
										<gmd:DQ_QuantitativeAttributeAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:sequence select="'Quantitative Attribute Accuracy Assessment'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(attracce))"/>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<xsl:for-each select="$var2384_attracc/attraccr">
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:value>
														<xsl:for-each select="attraccv">
															<gco:Record>
																<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
															</gco:Record>
														</xsl:for-each>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_QuantitativeAttributeAccuracy>
									</gmd:report>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="$var2367_metadata/idinfo/timeperd/timeinfo/sngdate/geolage">
								<xsl:variable name="var2392_geolage" as="node()" select="."/>
								<xsl:for-each select="geolun">
									<gmd:report>
										<gmd:DQ_TemporalValidity>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:sequence select="'Geologic Uncertainty'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<xsl:for-each select="$var2392_geolage/geolcit">
												<xsl:variable name="var2396_geolcit" as="node()" select="."/>
												<gmd:measureIdentification>
													<gmd:MD_Identifier>
														<gmd:authority>
															<gmd:CI_Citation>
																<gmd:title>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(citeinfo/title))"/>
																	</gco:CharacterString>
																</gmd:title>
																<gmd:date>
																	<gmd:CI_Date>
																		<gmd:date>
																			<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
																				<xsl:attribute name="gco:nilReason">
																					<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
																				</xsl:attribute>
																			</xsl:if>
																			<xsl:variable name="var2399_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																					<xsl:variable name="var2404_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2403_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2404_map_result_distinctvalues)">
																							<xsl:variable name="var2409_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2409_cond_result_endswith)">
																								<xsl:sequence select="$var2409_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2403_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2403_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var2399_cond_result_logicalor">
																				<gco:Date>
																					<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																				</gco:Date>
																			</xsl:for-each>
																			<xsl:variable name="var2417_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																					<xsl:variable name="var2424_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2423_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2424_map_result_distinctvalues)">
																							<xsl:variable name="var2429_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2429_cond_result_endswith)">
																								<xsl:sequence select="$var2429_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2423_map_result_distinctvalues)">
																						<xsl:sequence select="fn:string-join($var2423_map_result_distinctvalues, ' ')"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var2417_cond_result_logicalor">
																				<xsl:variable name="var2418_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:for-each select="$var2396_geolcit/citeinfo/pubtime">
																					<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))), 'un'))">
																						<gco:DateTime>
																							<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2418_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))) and ('false' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))))) and fn:boolean(fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))) then 'T' else '')), fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))))"/>
																						</gco:DateTime>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</gmd:date>
																		<gmd:dateType>
																			<gmd:CI_DateTypeCode>
																				<xsl:attribute name="codeList">
																					<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																				</xsl:attribute>
																				<xsl:attribute name="codeListValue">
																					<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																				</xsl:attribute>
																				<xsl:attribute name="codeSpace">
																					<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																				</xsl:attribute>
																			</gmd:CI_DateTypeCode>
																		</gmd:dateType>
																	</gmd:CI_Date>
																</gmd:date>
																<xsl:for-each select="citeinfo/edition">
																	<gmd:edition>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:edition>
																</xsl:for-each>
																<gmd:citedResponsibleParty>
																	<gmd:CI_ResponsibleParty>
																		<xsl:for-each select="citeinfo/origin">
																			<gmd:organisationName>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																				</gco:CharacterString>
																			</gmd:organisationName>
																		</xsl:for-each>
																		<gmd:contactInfo>
																			<gmd:CI_Contact>
																				<xsl:for-each select="citeinfo/onlink">
																					<gmd:onlineResource>
																						<gmd:CI_OnlineResource>
																							<gmd:linkage>
																								<gmd:URL>
																									<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
																								</gmd:URL>
																							</gmd:linkage>
																						</gmd:CI_OnlineResource>
																					</gmd:onlineResource>
																				</xsl:for-each>
																			</gmd:CI_Contact>
																		</gmd:contactInfo>
																		<gmd:role>
																			<gmd:CI_RoleCode>
																				<xsl:attribute name="codeList">
																					<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																				</xsl:attribute>
																				<xsl:attribute name="codeListValue">
																					<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																				</xsl:attribute>
																				<xsl:attribute name="codeSpace">
																					<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																				</xsl:attribute>
																			</gmd:CI_RoleCode>
																		</gmd:role>
																	</gmd:CI_ResponsibleParty>
																</gmd:citedResponsibleParty>
																<gmd:presentationForm>
																	<gmd:CI_PresentationFormCode>
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																		</xsl:attribute>
																		<xsl:variable name="var2443_result_vmf7_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf7_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var2442_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2443_result_vmf7_inputtoresult)) then $var2443_result_vmf7_inputtoresult else ())"/>
																		<xsl:if test="fn:exists($var2442_cond_result_exists)">
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI($var2442_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:variable name="var2445_result_vmf8_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf8_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var2444_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2445_result_vmf8_inputtoresult)) then $var2445_result_vmf8_inputtoresult else ())"/>
																		<xsl:if test="fn:exists($var2444_cond_result_exists)">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI($var2444_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																	</gmd:CI_PresentationFormCode>
																</gmd:presentationForm>
																<xsl:for-each select="citeinfo/serinfo">
																	<gmd:series>
																		<gmd:CI_Series>
																			<gmd:name>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
																				</gco:CharacterString>
																			</gmd:name>
																			<gmd:issueIdentification>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
																				</gco:CharacterString>
																			</gmd:issueIdentification>
																		</gmd:CI_Series>
																	</gmd:series>
																</xsl:for-each>
																<xsl:for-each select="citeinfo/othercit">
																	<gmd:otherCitationDetails>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:otherCitationDetails>
																</xsl:for-each>
															</gmd:CI_Citation>
														</gmd:authority>
													</gmd:MD_Identifier>
												</gmd:measureIdentification>
											</xsl:for-each>
											<gmd:evaluationMethodDescription>
												<xsl:for-each select="$var2392_geolage/geolexpl">
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:value>
														<gco:Record>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_TemporalValidity>
									</gmd:report>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:variable name="var2452_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2367_metadata/idinfo/timeperd/timeinfo/mdattim/sngdate/geolage/geolun)) then 'Geologic Uncertainty' else ())"/>
							<xsl:if test="fn:exists($var2452_cond_result_exists)">
								<gmd:report>
									<gmd:DQ_TemporalValidity>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:sequence select="$var2452_cond_result_exists"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<xsl:for-each select="$var2367_metadata/idinfo/timeperd/timeinfo/mdattim/sngdate/geolage/geolcit">
											<xsl:variable name="var2453_geolcit" as="node()" select="."/>
											<gmd:measureIdentification>
												<gmd:MD_Identifier>
													<gmd:authority>
														<gmd:CI_Citation>
															<gmd:title>
																<gco:CharacterString>
																	<xsl:sequence select="fn:normalize-space(xs:string(citeinfo/title))"/>
																</gco:CharacterString>
															</gmd:title>
															<gmd:date>
																<gmd:CI_Date>
																	<gmd:date>
																		<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
																			<xsl:attribute name="gco:nilReason">
																				<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:variable name="var2456_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																				<xsl:variable name="var2461_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2460_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2461_map_result_distinctvalues)">
																						<xsl:variable name="var2466_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2466_cond_result_endswith)">
																							<xsl:sequence select="$var2466_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2460_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2460_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2456_cond_result_logicalor">
																			<gco:Date>
																				<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																			</gco:Date>
																		</xsl:for-each>
																		<xsl:variable name="var2474_cond_result_logicalor" as="xs:string?">
																			<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																				<xsl:variable name="var2481_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., '-')">
																								<xsl:if test="fn:ends-with(., '-')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2480_map_result_distinctvalues" as="xs:string*">
																					<xsl:for-each select="fn:distinct-values($var2481_map_result_distinctvalues)">
																						<xsl:variable name="var2486_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																											<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2486_cond_result_endswith)">
																							<xsl:sequence select="$var2486_cond_result_endswith"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2480_map_result_distinctvalues)">
																					<xsl:sequence select="fn:string-join($var2480_map_result_distinctvalues, ' ')"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2474_cond_result_logicalor">
																			<xsl:variable name="var2475_cur_cond_result_logicalor" as="xs:string" select="."/>
																			<xsl:for-each select="$var2453_geolcit/citeinfo/pubtime">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))), 'un'))">
																					<gco:DateTime>
																						<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2475_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))) and ('false' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))))) and fn:boolean(fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))) then 'T' else '')), fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))))"/>
																					</gco:DateTime>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:for-each>
																	</gmd:date>
																	<gmd:dateType>
																		<gmd:CI_DateTypeCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																			</xsl:attribute>
																		</gmd:CI_DateTypeCode>
																	</gmd:dateType>
																</gmd:CI_Date>
															</gmd:date>
															<xsl:for-each select="citeinfo/edition">
																<gmd:edition>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:edition>
															</xsl:for-each>
															<gmd:citedResponsibleParty>
																<gmd:CI_ResponsibleParty>
																	<xsl:for-each select="citeinfo/origin">
																		<gmd:organisationName>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																			</gco:CharacterString>
																		</gmd:organisationName>
																	</xsl:for-each>
																	<gmd:contactInfo>
																		<gmd:CI_Contact>
																			<xsl:for-each select="citeinfo/onlink">
																				<gmd:onlineResource>
																					<gmd:CI_OnlineResource>
																						<gmd:linkage>
																							<gmd:URL>
																								<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
																							</gmd:URL>
																						</gmd:linkage>
																					</gmd:CI_OnlineResource>
																				</gmd:onlineResource>
																			</xsl:for-each>
																		</gmd:CI_Contact>
																	</gmd:contactInfo>
																	<gmd:role>
																		<gmd:CI_RoleCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																			</xsl:attribute>
																		</gmd:CI_RoleCode>
																	</gmd:role>
																</gmd:CI_ResponsibleParty>
															</gmd:citedResponsibleParty>
															<gmd:presentationForm>
																<gmd:CI_PresentationFormCode>
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																	</xsl:attribute>
																	<xsl:variable name="var2500_result_vmf7_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf7_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var2499_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2500_result_vmf7_inputtoresult)) then $var2500_result_vmf7_inputtoresult else ())"/>
																	<xsl:if test="fn:exists($var2499_cond_result_exists)">
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI($var2499_cond_result_exists))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:variable name="var2502_result_vmf8_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf8_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var2501_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2502_result_vmf8_inputtoresult)) then $var2502_result_vmf8_inputtoresult else ())"/>
																	<xsl:if test="fn:exists($var2501_cond_result_exists)">
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI($var2501_cond_result_exists))"/>
																		</xsl:attribute>
																	</xsl:if>
																</gmd:CI_PresentationFormCode>
															</gmd:presentationForm>
															<xsl:for-each select="citeinfo/serinfo">
																<gmd:series>
																	<gmd:CI_Series>
																		<gmd:name>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
																			</gco:CharacterString>
																		</gmd:name>
																		<gmd:issueIdentification>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
																			</gco:CharacterString>
																		</gmd:issueIdentification>
																	</gmd:CI_Series>
																</gmd:series>
															</xsl:for-each>
															<xsl:for-each select="citeinfo/othercit">
																<gmd:otherCitationDetails>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:otherCitationDetails>
															</xsl:for-each>
														</gmd:CI_Citation>
													</gmd:authority>
												</gmd:MD_Identifier>
											</gmd:measureIdentification>
										</xsl:for-each>
										<xsl:for-each select="$var2367_metadata/idinfo/timeperd/timeinfo/mdattim/sngdate/geolage/geolexpl">
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
										</xsl:for-each>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:value>
													<xsl:for-each select="$var2367_metadata/idinfo/timeperd/timeinfo/mdattim/sngdate/geolage/geolun">
														<gco:Record>
															<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_TemporalValidity>
								</gmd:report>
							</xsl:if>
							<xsl:for-each select="$var2367_metadata/idinfo/timeperd/timeinfo/rngdates">
								<xsl:variable name="var2511_rngdates" as="node()" select="."/>
								<xsl:for-each select="beggeol">
									<xsl:variable name="var2513_beggeol" as="node()" select="."/>
									<gmd:report>
										<xsl:variable name="var2737_map_select_geolun" as="xs:string?">
											<xsl:for-each select="geolage/geolun">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var2736_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var2737_map_select_geolun)">
													<xsl:for-each select="geolage/geolun">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolun">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:variable name="var2515_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2736_cond_result_exists)) then 'Geologic Uncertainty' else ())"/>
										<xsl:if test="fn:exists($var2515_cond_result_exists)">
											<gmd:DQ_TemporalValidity>
												<gmd:nameOfMeasure>
													<gco:CharacterString>
														<xsl:sequence select="$var2515_cond_result_exists"/>
													</gco:CharacterString>
												</gmd:nameOfMeasure>
												<gmd:measureIdentification>
													<gmd:MD_Identifier>
														<gmd:authority>
															<xsl:variable name="var2710_map_select_geolcit" as="xs:string*">
																<xsl:for-each select="geolage/geolcit/citeinfo/title">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var2516_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var2710_map_select_geolcit)">
																		<xsl:for-each select="geolage/geolcit/citeinfo/title">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/title">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var2516_cond_result_exists">
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(.)"/>
																		</gco:CharacterString>
																	</gmd:title>
																	<gmd:date>
																		<gmd:CI_Date>
																			<gmd:date>
																				<xsl:variable name="var2522_map_select_geolcit" as="xs:string*">
																					<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																						<xsl:sequence select="xs:string(xs:string(.))"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2519_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2522_map_select_geolcit)">
																							<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var2519_cond_result_exists">
																					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
																						<xsl:attribute name="gco:nilReason">
																							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
																						</xsl:attribute>
																					</xsl:if>
																				</xsl:for-each>
																				<xsl:variable name="var2551_map_select_geolcit" as="xs:string*">
																					<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																						<xsl:sequence select="xs:string(xs:string(.))"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2530_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2551_map_select_geolcit)">
																							<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var2530_cond_result_exists">
																					<xsl:variable name="var2534_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var2539_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var2538_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var2539_map_result_distinctvalues)">
																									<xsl:variable name="var2544_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2544_cond_result_endswith)">
																										<xsl:sequence select="$var2544_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2538_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var2538_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var2534_cond_result_logicalor">
																						<gco:Date>
																							<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																						</gco:Date>
																					</xsl:for-each>
																				</xsl:for-each>
																				<xsl:variable name="var2591_map_select_geolcit" as="xs:string*">
																					<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																						<xsl:sequence select="xs:string(xs:string(.))"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2559_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2591_map_select_geolcit)">
																							<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var2559_cond_result_exists">
																					<xsl:variable name="var2563_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var2579_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var2578_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var2579_map_result_distinctvalues)">
																									<xsl:variable name="var2584_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2584_cond_result_endswith)">
																										<xsl:sequence select="$var2584_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2578_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var2578_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var2563_cond_result_logicalor">
																						<xsl:variable name="var2564_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var2569_map_select_geolcit" as="xs:string*">
																							<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubtime">
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2566_cond_result_exists" as="xs:string*">
																							<xsl:choose>
																								<xsl:when test="fn:exists($var2569_map_select_geolcit)">
																									<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubtime">
																										<xsl:sequence select="xs:string(xs:string(.))"/>
																									</xsl:for-each>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubtime">
																										<xsl:sequence select="xs:string(xs:string(.))"/>
																									</xsl:for-each>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:for-each select="$var2566_cond_result_exists">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(.)), 'un'))">
																								<gco:DateTime>
																									<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2564_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(.))) and ('false' != fn:normalize-space(fn:lower-case(.)))) and fn:boolean(fn:normalize-space(fn:lower-case(.))))) then 'T' else '')), fn:normalize-space(fn:lower-case(.))))))"/>
																								</gco:DateTime>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</gmd:date>
																			<gmd:dateType>
																				<gmd:CI_DateTypeCode>
																					<xsl:variable name="var2601_map_select_geolcit" as="xs:string*">
																						<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2600_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var2601_map_select_geolcit)">
																								<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var2599_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2600_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																					<xsl:if test="fn:exists($var2599_cond_result_exists)">
																						<xsl:attribute name="codeList">
																							<xsl:sequence select="xs:string(xs:anyURI($var2599_cond_result_exists))"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:variable name="var2611_map_select_geolcit" as="xs:string*">
																						<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2610_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var2611_map_select_geolcit)">
																								<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var2609_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2610_cond_result_exists)) then 'publication' else ())"/>
																					<xsl:if test="fn:exists($var2609_cond_result_exists)">
																						<xsl:attribute name="codeListValue">
																							<xsl:sequence select="xs:string(xs:anyURI($var2609_cond_result_exists))"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:variable name="var2621_map_select_geolcit" as="xs:string*">
																						<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2620_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var2621_map_select_geolcit)">
																								<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/pubdate">
																									<xsl:sequence select="xs:string(xs:string(.))"/>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var2619_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2620_cond_result_exists)) then '002' else ())"/>
																					<xsl:if test="fn:exists($var2619_cond_result_exists)">
																						<xsl:attribute name="codeSpace">
																							<xsl:sequence select="xs:string(xs:anyURI($var2619_cond_result_exists))"/>
																						</xsl:attribute>
																					</xsl:if>
																				</gmd:CI_DateTypeCode>
																			</gmd:dateType>
																		</gmd:CI_Date>
																	</gmd:date>
																	<xsl:variable name="var2632_map_select_geolcit" as="xs:string*">
																		<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/edition">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2629_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var2632_map_select_geolcit)">
																				<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/edition">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/edition">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2629_cond_result_exists">
																		<gmd:edition>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(.)"/>
																			</gco:CharacterString>
																		</gmd:edition>
																	</xsl:for-each>
																	<gmd:citedResponsibleParty>
																		<gmd:CI_ResponsibleParty>
																			<xsl:variable name="var2643_map_select_geolcit" as="xs:string*">
																				<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/origin">
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2640_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var2643_map_select_geolcit)">
																						<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/origin">
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/origin">
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var2640_cond_result_exists">
																				<gmd:organisationName>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(.)"/>
																					</gco:CharacterString>
																				</gmd:organisationName>
																			</xsl:for-each>
																			<gmd:contactInfo>
																				<gmd:CI_Contact>
																					<xsl:variable name="var2654_map_select_geolcit" as="xs:string*">
																						<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/onlink">
																							<xsl:sequence select="xs:string(.)"/>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2651_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var2654_map_select_geolcit)">
																								<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/onlink">
																									<xsl:sequence select="xs:string(.)"/>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/onlink">
																									<xsl:sequence select="xs:string(.)"/>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var2651_cond_result_exists">
																						<gmd:onlineResource>
																							<gmd:CI_OnlineResource>
																								<gmd:linkage>
																									<gmd:URL>
																										<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
																									</gmd:URL>
																								</gmd:linkage>
																							</gmd:CI_OnlineResource>
																						</gmd:onlineResource>
																					</xsl:for-each>
																				</gmd:CI_Contact>
																			</gmd:contactInfo>
																			<gmd:role>
																				<gmd:CI_RoleCode>
																					<xsl:attribute name="codeList">
																						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeListValue">
																						<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																					</xsl:attribute>
																				</gmd:CI_RoleCode>
																			</gmd:role>
																		</gmd:CI_ResponsibleParty>
																	</gmd:citedResponsibleParty>
																	<xsl:variable name="var2669_map_select_geolcit" as="xs:string*">
																		<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/geoform">
																			<xsl:sequence select="xs:string(xs:string(.))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2662_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var2669_map_select_geolcit)">
																				<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/geoform">
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/geoform">
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2662_cond_result_exists">
																		<gmd:presentationForm>
																			<gmd:CI_PresentationFormCode>
																				<xsl:attribute name="codeList">
																					<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																				</xsl:attribute>
																				<xsl:variable name="var2666_result_vmf7_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf7_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var2665_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2666_result_vmf7_inputtoresult)) then $var2666_result_vmf7_inputtoresult else ())"/>
																				<xsl:if test="fn:exists($var2665_cond_result_exists)">
																					<xsl:attribute name="codeListValue">
																						<xsl:sequence select="xs:string(xs:anyURI($var2665_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:variable name="var2668_result_vmf8_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf8_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var2667_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2668_result_vmf8_inputtoresult)) then $var2668_result_vmf8_inputtoresult else ())"/>
																				<xsl:if test="fn:exists($var2667_cond_result_exists)">
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI($var2667_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																			</gmd:CI_PresentationFormCode>
																		</gmd:presentationForm>
																	</xsl:for-each>
																	<xsl:variable name="var2691_map_select_geolcit" as="xs:string*">
																		<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/serinfo/sername">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2677_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var2691_map_select_geolcit)">
																				<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/serinfo/sername">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/serinfo/sername">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2677_cond_result_exists">
																		<gmd:series>
																			<gmd:CI_Series>
																				<gmd:name>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(.)"/>
																					</gco:CharacterString>
																				</gmd:name>
																				<xsl:variable name="var2683_map_select_geolcit" as="xs:string*">
																					<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/serinfo/issue">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2680_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2683_map_select_geolcit)">
																							<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/serinfo/issue">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/serinfo/issue">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var2680_cond_result_exists">
																					<gmd:issueIdentification>
																						<gco:CharacterString>
																							<xsl:sequence select="fn:normalize-space(.)"/>
																						</gco:CharacterString>
																					</gmd:issueIdentification>
																				</xsl:for-each>
																			</gmd:CI_Series>
																		</gmd:series>
																	</xsl:for-each>
																	<xsl:variable name="var2702_map_select_geolcit" as="xs:string*">
																		<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/othercit">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2699_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var2702_map_select_geolcit)">
																				<xsl:for-each select="$var2513_beggeol/geolage/geolcit/citeinfo/othercit">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolcit/citeinfo/othercit">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2699_cond_result_exists">
																		<gmd:otherCitationDetails>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(.)"/>
																			</gco:CharacterString>
																		</gmd:otherCitationDetails>
																	</xsl:for-each>
																</gmd:CI_Citation>
															</xsl:for-each>
														</gmd:authority>
													</gmd:MD_Identifier>
												</gmd:measureIdentification>
												<xsl:variable name="var2719_map_select_geolexpl" as="xs:string?">
													<xsl:for-each select="geolage/geolexpl">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var2718_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="fn:exists($var2719_map_select_geolexpl)">
															<xsl:for-each select="geolage/geolexpl">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolexpl">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:if test="fn:exists($var2718_cond_result_exists)">
													<gmd:evaluationMethodDescription>
														<gco:CharacterString>
															<xsl:sequence select="$var2718_cond_result_exists"/>
														</gco:CharacterString>
													</gmd:evaluationMethodDescription>
												</xsl:if>
												<gmd:result>
													<gmd:DQ_QuantitativeResult>
														<gmd:value>
															<xsl:variable name="var2728_map_select_geolun" as="xs:string?">
																<xsl:for-each select="geolage/geolun">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var2727_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var2728_map_select_geolun)">
																		<xsl:for-each select="geolage/geolun">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="$var2511_rngdates/endgeol/geolage/geolun">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var2727_cond_result_exists)">
																<gco:Record>
																	<xsl:sequence select="$var2727_cond_result_exists"/>
																</gco:Record>
															</xsl:if>
														</gmd:value>
													</gmd:DQ_QuantitativeResult>
												</gmd:result>
											</gmd:DQ_TemporalValidity>
										</xsl:if>
									</gmd:report>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="attracc">
								<gmd:report>
									<gmd:DQ_NonQuantitativeAttributeAccuracy>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(attraccr)"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string('inapplicable'))"/>
											</xsl:attribute>
										</gmd:result>
									</gmd:DQ_NonQuantitativeAttributeAccuracy>
								</gmd:report>
							</xsl:for-each>
							<gmd:lineage>
								<gmd:LI_Lineage>
									<xsl:for-each select="lineage/procstep">
										<xsl:variable name="var2747_procstep" as="node()" select="."/>
										<gmd:processStep>
											<gmd:LI_ProcessStep>
												<gmd:description>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(procdesc))"/>
													</gco:CharacterString>
												</gmd:description>
												<gmd:dateTime>
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(procdate)))))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:variable name="var2750_cond_result_logicalor" as="xs:string?">
														<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'present')))">
															<xsl:variable name="var2777_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(procdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(procdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																	<xsl:choose>
																		<xsl:when test="fn:ends-with(., '-')">
																			<xsl:if test="fn:ends-with(., '-')">
																				<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																					<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="."/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var2776_map_result_distinctvalues" as="xs:string*">
																<xsl:for-each select="fn:distinct-values($var2777_map_result_distinctvalues)">
																	<xsl:variable name="var2782_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																				<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																						<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2782_cond_result_endswith)">
																		<xsl:sequence select="$var2782_cond_result_endswith"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var2776_map_result_distinctvalues)">
																<xsl:sequence select="fn:string-join($var2776_map_result_distinctvalues, ' ')"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:for-each select="$var2750_cond_result_logicalor">
														<xsl:variable name="var2751_cur_cond_result_logicalor" as="xs:string" select="."/>
														<xsl:variable name="var2753_map_select_proctime" as="xs:string?">
															<xsl:for-each select="$var2747_procstep/proctime">
																<xsl:variable name="var2774_result_vmf6_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf6_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:variable name="var2773_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2774_result_vmf6_inputtoresult)) then (if (fn:contains($var2774_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																<xsl:if test="not(fn:exists($var2773_cond_result_exists))">
																	<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:variable>
														<xsl:for-each select="fn:distinct-values($var2753_map_select_proctime)">
															<xsl:variable name="var2758_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(., ':')">
																		<xsl:if test="fn:ends-with(., ':')">
																			<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var2758_cond_result_endswith)">
																<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2758_cond_result_endswith))), 'un'))">
																	<gco:DateTime>
																		<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2751_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2758_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2758_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2758_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var2758_cond_result_endswith))))))))"/>
																	</gco:DateTime>
																</xsl:if>
															</xsl:if>
														</xsl:for-each>
													</xsl:for-each>
												</gmd:dateTime>
												<xsl:for-each select="proccont">
													<xsl:variable name="var2789_proccont" as="node()" select="."/>
													<gmd:processor>
														<gmd:CI_ResponsibleParty>
															<gmd:individualName>
																<xsl:variable name="var2792_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntper">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var2791_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var2792_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var2791_cond_result_exists)">
																	<gco:CharacterString>
																		<xsl:sequence select="$var2791_cond_result_exists"/>
																	</gco:CharacterString>
																</xsl:if>
															</gmd:individualName>
															<gmd:organisationName>
																<xsl:variable name="var2801_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntorg">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var2800_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var2801_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:if test="fn:exists($var2800_cond_result_exists)">
																	<gco:CharacterString>
																		<xsl:sequence select="$var2800_cond_result_exists"/>
																	</gco:CharacterString>
																</xsl:if>
															</gmd:organisationName>
															<gmd:positionName>
																<xsl:for-each select="cntinfo/cntpos">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:positionName>
															<gmd:contactInfo>
																<gmd:CI_Contact>
																	<gmd:phone>
																		<gmd:CI_Telephone>
																			<xsl:for-each-group select="cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
																				<xsl:variable name="var2813_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																				<gmd:voice>
																					<gco:CharacterString>
																						<xsl:sequence select="$var2813_cur_result_groupby"/>
																					</gco:CharacterString>
																				</gmd:voice>
																			</xsl:for-each-group>
																			<xsl:for-each-group select="cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
																				<xsl:variable name="var2817_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																				<gmd:facsimile>
																					<gco:CharacterString>
																						<xsl:sequence select="$var2817_cur_result_groupby"/>
																					</gco:CharacterString>
																				</gmd:facsimile>
																			</xsl:for-each-group>
																		</gmd:CI_Telephone>
																	</gmd:phone>
																	<xsl:for-each select="cntinfo/cntaddr">
																		<gmd:address>
																			<gmd:CI_Address>
																				<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																					<xsl:variable name="var2823_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																					<gmd:deliveryPoint>
																						<gco:CharacterString>
																							<xsl:sequence select="$var2823_cur_result_groupby"/>
																						</gco:CharacterString>
																					</gmd:deliveryPoint>
																				</xsl:for-each-group>
																				<gmd:city>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(city)"/>
																					</gco:CharacterString>
																				</gmd:city>
																				<gmd:administrativeArea>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(state)"/>
																					</gco:CharacterString>
																				</gmd:administrativeArea>
																				<gmd:postalCode>
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(postal)"/>
																					</gco:CharacterString>
																				</gmd:postalCode>
																				<gmd:country>
																					<xsl:for-each select="country">
																						<gco:CharacterString>
																							<xsl:sequence select="xs:string(.)"/>
																						</gco:CharacterString>
																					</xsl:for-each>
																				</gmd:country>
																				<xsl:for-each-group select="$var2789_proccont/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																					<xsl:variable name="var2829_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																					<gmd:electronicMailAddress>
																						<gco:CharacterString>
																							<xsl:sequence select="$var2829_cur_result_groupby"/>
																						</gco:CharacterString>
																					</gmd:electronicMailAddress>
																				</xsl:for-each-group>
																			</gmd:CI_Address>
																		</gmd:address>
																	</xsl:for-each>
																	<gmd:hoursOfService>
																		<xsl:for-each select="cntinfo/hours">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:hoursOfService>
																	<gmd:contactInstructions>
																		<xsl:for-each select="cntinfo/cntinst">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:contactInstructions>
																</gmd:CI_Contact>
															</gmd:contactInfo>
															<gmd:role>
																<xsl:variable name="var2857_map_select_cntperp" as="xs:string?">
																	<xsl:for-each select="cntinfo/cntperp/cntorg">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var2856_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var2857_map_select_cntperp)">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:for-each select="cntinfo/cntorgp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:variable name="var2835_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2856_cond_result_exists)) then 'processor' else ())"/>
																<xsl:if test="fn:exists($var2835_cond_result_exists)">
																	<gmd:CI_RoleCode>
																		<xsl:variable name="var2838_map_select_cntperp" as="xs:string?">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2837_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var2838_map_select_cntperp)">
																					<xsl:for-each select="cntinfo/cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntinfo/cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:variable name="var2836_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2837_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode' else ())"/>
																		<xsl:if test="fn:exists($var2836_cond_result_exists)">
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI($var2836_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI($var2835_cond_result_exists))"/>
																		</xsl:attribute>
																		<xsl:variable name="var2848_map_select_cntperp" as="xs:string?">
																			<xsl:for-each select="cntinfo/cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2847_cond_result_exists" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var2848_map_select_cntperp)">
																					<xsl:for-each select="cntinfo/cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntinfo/cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:variable name="var2846_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2847_cond_result_exists)) then '009' else ())"/>
																		<xsl:if test="fn:exists($var2846_cond_result_exists)">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI($var2846_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var2835_cond_result_exists"/>
																	</gmd:CI_RoleCode>
																</xsl:if>
															</gmd:role>
														</gmd:CI_ResponsibleParty>
													</gmd:processor>
												</xsl:for-each>
												<xsl:for-each-group select="." group-by="grp:key1a877320(.)">
													<xsl:variable name="var2868_cur_result_groupby" as="item()+" select="current-group()"/>
													<xsl:variable name="var2869_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
													<gmd:source>
														<gmd:LI_Source>
															<gmd:sourceCitation>
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString>
																			<xsl:sequence select="$var2869_cur_result_groupby"/>
																		</gco:CharacterString>
																	</gmd:title>
																	<xsl:for-each select="$var2868_cur_result_groupby/srcprod">
																		<gmd:alternateTitle>
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(xs:token(.))"/>
																			</gco:CharacterString>
																		</gmd:alternateTitle>
																	</xsl:for-each>
																	<gmd:date>
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string('unknown'))"/>
																		</xsl:attribute>
																	</gmd:date>
																</gmd:CI_Citation>
															</gmd:sourceCitation>
														</gmd:LI_Source>
													</gmd:source>
												</xsl:for-each-group>
											</gmd:LI_ProcessStep>
										</gmd:processStep>
									</xsl:for-each>
									<xsl:for-each select="lineage/method">
										<gmd:processStep>
											<gmd:LI_ProcessStep>
												<gmd:description>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(methdesc))"/>
													</gco:CharacterString>
												</gmd:description>
												<gmd:rationale>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(xs:string(methtype)))"/>
													</gco:CharacterString>
												</gmd:rationale>
												<xsl:for-each select="methcite">
													<xsl:variable name="var2875_methcite" as="node()" select="."/>
													<gmd:source>
														<gmd:LI_Source>
															<gmd:sourceCitation>
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(citeinfo/title))"/>
																		</gco:CharacterString>
																	</gmd:title>
																	<gmd:date>
																		<gmd:CI_Date>
																			<gmd:date>
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate)))))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:variable name="var2878_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																						<xsl:variable name="var2883_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2882_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2883_map_result_distinctvalues)">
																								<xsl:variable name="var2888_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2888_cond_result_endswith)">
																									<xsl:sequence select="$var2888_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2882_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2882_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var2878_cond_result_logicalor">
																					<gco:Date>
																						<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																					</gco:Date>
																				</xsl:for-each>
																				<xsl:variable name="var2896_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present')))">
																						<xsl:variable name="var2903_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2902_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var2903_map_result_distinctvalues)">
																								<xsl:variable name="var2908_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2908_cond_result_endswith)">
																									<xsl:sequence select="$var2908_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2902_map_result_distinctvalues)">
																							<xsl:sequence select="fn:string-join($var2902_map_result_distinctvalues, ' ')"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var2896_cond_result_logicalor">
																					<xsl:variable name="var2897_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:for-each select="$var2875_methcite/citeinfo/pubtime">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))), 'un'))">
																							<gco:DateTime>
																								<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2897_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))) and ('false' != fn:normalize-space(fn:lower-case(xs:string(xs:string(.)))))) and fn:boolean(fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))) then 'T' else '')), fn:normalize-space(fn:lower-case(xs:string(xs:string(.))))))))"/>
																							</gco:DateTime>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</gmd:date>
																			<gmd:dateType>
																				<gmd:CI_DateTypeCode>
																					<xsl:attribute name="codeList">
																						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeListValue">
																						<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																					</xsl:attribute>
																				</gmd:CI_DateTypeCode>
																			</gmd:dateType>
																		</gmd:CI_Date>
																	</gmd:date>
																	<xsl:for-each select="citeinfo/edition">
																		<gmd:edition>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:edition>
																	</xsl:for-each>
																	<gmd:citedResponsibleParty>
																		<gmd:CI_ResponsibleParty>
																			<xsl:for-each select="citeinfo/origin">
																				<gmd:organisationName>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																					</gco:CharacterString>
																				</gmd:organisationName>
																			</xsl:for-each>
																			<gmd:contactInfo>
																				<gmd:CI_Contact>
																					<xsl:for-each select="citeinfo/onlink">
																						<gmd:onlineResource>
																							<gmd:CI_OnlineResource>
																								<gmd:linkage>
																									<gmd:URL>
																										<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
																									</gmd:URL>
																								</gmd:linkage>
																							</gmd:CI_OnlineResource>
																						</gmd:onlineResource>
																					</xsl:for-each>
																				</gmd:CI_Contact>
																			</gmd:contactInfo>
																			<gmd:role>
																				<gmd:CI_RoleCode>
																					<xsl:attribute name="codeList">
																						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeListValue">
																						<xsl:sequence select="xs:string(xs:anyURI('author'))"/>
																					</xsl:attribute>
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI('011'))"/>
																					</xsl:attribute>
																				</gmd:CI_RoleCode>
																			</gmd:role>
																		</gmd:CI_ResponsibleParty>
																	</gmd:citedResponsibleParty>
																	<gmd:presentationForm>
																		<gmd:CI_PresentationFormCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																			</xsl:attribute>
																			<xsl:variable name="var2922_result_vmf7_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf7_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var2921_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2922_result_vmf7_inputtoresult)) then $var2922_result_vmf7_inputtoresult else ())"/>
																			<xsl:if test="fn:exists($var2921_cond_result_exists)">
																				<xsl:attribute name="codeListValue">
																					<xsl:sequence select="xs:string(xs:anyURI($var2921_cond_result_exists))"/>
																				</xsl:attribute>
																			</xsl:if>
																			<xsl:variable name="var2924_result_vmf8_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf8_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(citeinfo/geoform))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var2923_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2924_result_vmf8_inputtoresult)) then $var2924_result_vmf8_inputtoresult else ())"/>
																			<xsl:if test="fn:exists($var2923_cond_result_exists)">
																				<xsl:attribute name="codeSpace">
																					<xsl:sequence select="xs:string(xs:anyURI($var2923_cond_result_exists))"/>
																				</xsl:attribute>
																			</xsl:if>
																		</gmd:CI_PresentationFormCode>
																	</gmd:presentationForm>
																	<xsl:for-each select="citeinfo/serinfo">
																		<gmd:series>
																			<gmd:CI_Series>
																				<gmd:name>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
																					</gco:CharacterString>
																				</gmd:name>
																				<gmd:issueIdentification>
																					<gco:CharacterString>
																						<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
																					</gco:CharacterString>
																				</gmd:issueIdentification>
																			</gmd:CI_Series>
																		</gmd:series>
																	</xsl:for-each>
																	<xsl:for-each select="citeinfo/othercit">
																		<gmd:otherCitationDetails>
																			<gco:CharacterString>
																				<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																			</gco:CharacterString>
																		</gmd:otherCitationDetails>
																	</xsl:for-each>
																</gmd:CI_Citation>
															</gmd:sourceCitation>
														</gmd:LI_Source>
													</gmd:source>
												</xsl:for-each>
											</gmd:LI_ProcessStep>
										</gmd:processStep>
									</xsl:for-each>
									<xsl:for-each select="lineage/srcinfo">
										<xsl:variable name="var2929_srcinfo" as="node()" select="."/>
										<gmd:source>
											<gmd:LI_Source>
												<gmd:description>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat('Source Contribution: ', xs:string(srccontr)), xs:string(xs:string(typesrc))))"/>
													</gco:CharacterString>
												</gmd:description>
												<gmd:scaleDenominator>
													<gmd:MD_RepresentativeFraction>
														<gmd:denominator>
															<xsl:for-each select="srcscale">
																<xsl:if test="(fn:lower-case(fn:string(.)) = 'unknown')">
																	<xsl:attribute name="gco:nilReason">
																		<xsl:sequence select="xs:string(xs:string(fn:string(.)))"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:for-each select="srcscale">
																<xsl:if test="not((fn:lower-case(fn:string(.)) = 'unknown'))">
																	<gco:Integer>
																		<xsl:sequence select="xs:string(xs:integer(.))"/>
																	</gco:Integer>
																</xsl:if>
															</xsl:for-each>
														</gmd:denominator>
													</gmd:MD_RepresentativeFraction>
												</gmd:scaleDenominator>
												<gmd:sourceCitation>
													<gmd:CI_Citation>
														<gmd:title>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(srccite/citeinfo/title))"/>
															</gco:CharacterString>
														</gmd:title>
														<gmd:alternateTitle>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(xs:token(srccitea))"/>
															</gco:CharacterString>
														</gmd:alternateTitle>
														<gmd:date>
															<gmd:CI_Date>
																<gmd:date>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate)))))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:variable name="var2936_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var2941_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2940_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var2941_map_result_distinctvalues)">
																					<xsl:variable name="var2946_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2946_cond_result_endswith)">
																						<xsl:sequence select="$var2946_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2940_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var2940_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var2936_cond_result_logicalor">
																		<gco:Date>
																			<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																		</gco:Date>
																	</xsl:for-each>
																	<xsl:variable name="var2954_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present')))">
																			<xsl:variable name="var2981_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(srccite/citeinfo/pubdate))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var2980_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var2981_map_result_distinctvalues)">
																					<xsl:variable name="var2986_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2986_cond_result_endswith)">
																						<xsl:sequence select="$var2986_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2980_map_result_distinctvalues)">
																				<xsl:sequence select="fn:string-join($var2980_map_result_distinctvalues, ' ')"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var2954_cond_result_logicalor">
																		<xsl:variable name="var2955_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var2957_map_select_pubtime" as="xs:string?">
																			<xsl:for-each select="$var2929_srcinfo/srccite/citeinfo/pubtime">
																				<xsl:variable name="var2978_result_vmf6_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf6_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var2977_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2978_result_vmf6_inputtoresult)) then (if (fn:contains($var2978_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var2977_cond_result_exists))">
																					<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var2957_map_select_pubtime)">
																			<xsl:variable name="var2962_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2962_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var2962_cond_result_endswith))), 'un'))">
																					<gco:DateTime>
																						<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2955_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var2962_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var2962_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var2962_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var2962_cond_result_endswith)))))))"/>
																					</gco:DateTime>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</gmd:date>
																<gmd:dateType>
																	<gmd:CI_DateTypeCode>
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI('publication'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
																		</xsl:attribute>
																		<xsl:sequence select="'publication'"/>
																	</gmd:CI_DateTypeCode>
																</gmd:dateType>
															</gmd:CI_Date>
														</gmd:date>
														<gmd:edition>
															<xsl:for-each select="srccite/citeinfo/edition">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:edition>
														<xsl:for-each-group select="srccite/citeinfo" group-by="grp:key1a49e9d0(.)">
															<xsl:variable name="var2999_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
															<gmd:citedResponsibleParty>
																<gmd:CI_ResponsibleParty>
																	<gmd:organisationName>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space($var2999_cur_result_groupby)"/>
																		</gco:CharacterString>
																	</gmd:organisationName>
																	<gmd:role>
																		<gmd:CI_RoleCode>
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeListValue">
																				<xsl:sequence select="xs:string(xs:anyURI('resourceProvider'))"/>
																			</xsl:attribute>
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI('001'))"/>
																			</xsl:attribute>
																			<xsl:sequence select="'resourceProvider'"/>
																		</gmd:CI_RoleCode>
																	</gmd:role>
																</gmd:CI_ResponsibleParty>
															</gmd:citedResponsibleParty>
														</xsl:for-each-group>
														<gmd:presentationForm>
															<xsl:variable name="var3004_result_vmf7_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf7_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(srccite/citeinfo/geoform))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:variable name="var3001_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3004_result_vmf7_inputtoresult)) then $var3004_result_vmf7_inputtoresult else ())"/>
															<xsl:if test="fn:exists($var3001_cond_result_exists)">
																<gmd:CI_PresentationFormCode>
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode'))"/>
																	</xsl:attribute>
																	<xsl:attribute name="codeListValue">
																		<xsl:sequence select="xs:string(xs:anyURI($var3001_cond_result_exists))"/>
																	</xsl:attribute>
																	<xsl:variable name="var3003_result_vmf8_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf8_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(srccite/citeinfo/geoform))))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:variable name="var3002_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3003_result_vmf8_inputtoresult)) then $var3003_result_vmf8_inputtoresult else ())"/>
																	<xsl:if test="fn:exists($var3002_cond_result_exists)">
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI($var3002_cond_result_exists))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<xsl:sequence select="$var3001_cond_result_exists"/>
																</gmd:CI_PresentationFormCode>
															</xsl:if>
														</gmd:presentationForm>
														<xsl:for-each select="srccite/citeinfo/serinfo">
															<gmd:series>
																<gmd:CI_Series>
																	<gmd:name>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(sername))"/>
																		</gco:CharacterString>
																	</gmd:name>
																	<gmd:issueIdentification>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(issue))"/>
																		</gco:CharacterString>
																	</gmd:issueIdentification>
																</gmd:CI_Series>
															</gmd:series>
														</xsl:for-each>
														<gmd:otherCitationDetails>
															<xsl:for-each select="srccite/citeinfo/othercit">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:otherCitationDetails>
													</gmd:CI_Citation>
												</gmd:sourceCitation>
												<gmd:sourceExtent>
													<gmd:EX_Extent>
														<xsl:for-each select="srctime/timeinfo/sngdate">
															<xsl:variable name="var3009_sngdate" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:for-each select="caldate">
																			<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
																				<xsl:attribute name="gco:nilReason">
																					<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
																				</xsl:attribute>
																			</xsl:if>
																		</xsl:for-each>
																		<gml:TimeInstant>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="fn:normalize-space(xs:string(xs:string($var2929_srcinfo/srctime/srccurr)))"/>
																			</gml:description>
																			<xsl:variable name="var3127_map_select_caldate" as="xs:string*">
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var3194_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var3221_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var3220_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var3221_map_result_distinctvalues)">
																									<xsl:variable name="var3226_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3226_cond_result_endswith)">
																										<xsl:sequence select="$var3226_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3220_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var3220_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var3194_cond_result_logicalor">
																						<xsl:variable name="var3195_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var3197_map_select_time" as="xs:string?">
																							<xsl:for-each select="$var3009_sngdate/time">
																								<xsl:variable name="var3218_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var3217_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3218_result_vmf6_inputtoresult)) then (if (fn:contains($var3218_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var3217_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var3197_map_select_time)">
																							<xsl:variable name="var3202_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3202_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3202_cond_result_endswith))), 'un'))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3195_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3202_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3202_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3202_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3202_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var3018_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var3127_map_select_caldate)">
																						<xsl:for-each select="caldate">
																							<xsl:variable name="var3132_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3159_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3158_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3159_map_result_distinctvalues)">
																											<xsl:variable name="var3164_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3164_cond_result_endswith)">
																												<xsl:sequence select="$var3164_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3158_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3158_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3132_cond_result_logicalor">
																								<xsl:variable name="var3133_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3135_map_select_time" as="xs:string?">
																									<xsl:for-each select="$var3009_sngdate/time">
																										<xsl:variable name="var3156_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3155_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3156_result_vmf6_inputtoresult)) then (if (fn:contains($var3156_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3155_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3135_map_select_time)">
																									<xsl:variable name="var3140_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3140_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3140_cond_result_endswith))), 'un'))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3133_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3140_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3140_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3140_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3140_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="caldate">
																							<xsl:variable name="var3174_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3179_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3178_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3179_map_result_distinctvalues)">
																											<xsl:variable name="var3184_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3184_cond_result_endswith)">
																												<xsl:sequence select="$var3184_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3178_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3178_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3174_cond_result_logicalor">
																								<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var3013_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="$var3018_cond_result_exists">
																						<xsl:variable name="var3020_map_select_caldate" as="xs:string*">
																							<xsl:for-each select="caldate">
																								<xsl:variable name="var3086_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																										<xsl:variable name="var3113_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var3112_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var3113_map_result_distinctvalues)">
																												<xsl:variable name="var3118_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3118_cond_result_endswith)">
																													<xsl:sequence select="$var3118_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3112_map_result_distinctvalues)">
																											<xsl:sequence select="fn:string-join($var3112_map_result_distinctvalues, ' ')"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var3086_cond_result_logicalor">
																									<xsl:variable name="var3087_cur_cond_result_logicalor" as="xs:string" select="."/>
																									<xsl:variable name="var3089_map_select_time" as="xs:string?">
																										<xsl:for-each select="$var3009_sngdate/time">
																											<xsl:variable name="var3110_result_vmf6_inputtoresult" as="xs:string?">
																												<xsl:call-template name="vmf:vmf6_inputtoresult">
																													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																												</xsl:call-template>
																											</xsl:variable>
																											<xsl:variable name="var3109_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3110_result_vmf6_inputtoresult)) then (if (fn:contains($var3110_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																											<xsl:if test="not(fn:exists($var3109_cond_result_exists))">
																												<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:for-each select="fn:distinct-values($var3089_map_select_time)">
																										<xsl:variable name="var3094_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3094_cond_result_endswith)">
																											<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3094_cond_result_endswith))), 'un'))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3087_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3094_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3094_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3094_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3094_cond_result_endswith)))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3020_map_select_caldate)">
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var3024_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3051_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3050_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3051_map_result_distinctvalues)">
																													<xsl:variable name="var3056_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3056_cond_result_endswith)">
																														<xsl:sequence select="$var3056_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3050_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3050_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3024_cond_result_logicalor">
																										<xsl:variable name="var3025_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3027_map_select_time" as="xs:string?">
																											<xsl:for-each select="$var3009_sngdate/time">
																												<xsl:variable name="var3048_result_vmf6_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf6_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3047_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3048_result_vmf6_inputtoresult)) then (if (fn:contains($var3048_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3047_cond_result_exists))">
																													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3027_map_select_time)">
																											<xsl:variable name="var3032_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3032_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3032_cond_result_endswith))), 'un'))">
																													<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3025_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3032_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3032_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3032_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3032_cond_result_endswith)))))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var3066_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3071_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3070_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3071_map_result_distinctvalues)">
																													<xsl:variable name="var3076_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3076_cond_result_endswith)">
																														<xsl:sequence select="$var3076_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3070_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3070_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3066_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="caldate">
																							<xsl:choose>
																								<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																									<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="''"/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var3013_cond_result_exists">
																				<gml:timePosition>
																					<xsl:for-each select="$var3009_sngdate/caldate">
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																							</xsl:attribute>
																						</xsl:if>
																					</xsl:for-each>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:timePosition>
																			</xsl:for-each>
																		</gml:TimeInstant>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
														<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
															<xsl:variable name="var3233_sngdate" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:for-each select="caldate">
																			<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
																				<xsl:attribute name="gco:nilReason">
																					<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
																				</xsl:attribute>
																			</xsl:if>
																		</xsl:for-each>
																		<gml:TimeInstant>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="xs:string(xs:string($var2929_srcinfo/srctime/srccurr))"/>
																			</gml:description>
																			<xsl:variable name="var3353_map_select_caldate" as="xs:string*">
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var3420_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var3447_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var3446_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var3447_map_result_distinctvalues)">
																									<xsl:variable name="var3452_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3452_cond_result_endswith)">
																										<xsl:sequence select="$var3452_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3446_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var3446_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var3420_cond_result_logicalor">
																						<xsl:variable name="var3421_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var3423_map_select_time" as="xs:string?">
																							<xsl:for-each select="$var3233_sngdate/time">
																								<xsl:variable name="var3444_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var3443_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3444_result_vmf6_inputtoresult)) then (if (fn:contains($var3444_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var3443_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var3423_map_select_time)">
																							<xsl:variable name="var3428_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3428_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3428_cond_result_endswith))), 'un'))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3421_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3428_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3428_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3428_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3428_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var3244_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var3353_map_select_caldate)">
																						<xsl:for-each select="caldate">
																							<xsl:variable name="var3358_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3385_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3384_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3385_map_result_distinctvalues)">
																											<xsl:variable name="var3390_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3390_cond_result_endswith)">
																												<xsl:sequence select="$var3390_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3384_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3384_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3358_cond_result_logicalor">
																								<xsl:variable name="var3359_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3361_map_select_time" as="xs:string?">
																									<xsl:for-each select="$var3233_sngdate/time">
																										<xsl:variable name="var3382_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3381_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3382_result_vmf6_inputtoresult)) then (if (fn:contains($var3382_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3381_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3361_map_select_time)">
																									<xsl:variable name="var3366_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3366_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3366_cond_result_endswith))), 'un'))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3359_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3366_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3366_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3366_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3366_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="caldate">
																							<xsl:variable name="var3400_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3405_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3404_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3405_map_result_distinctvalues)">
																											<xsl:variable name="var3410_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3410_cond_result_endswith)">
																												<xsl:sequence select="$var3410_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3404_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3404_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3400_cond_result_logicalor">
																								<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var3237_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="$var3244_cond_result_exists">
																						<xsl:variable name="var3246_map_select_caldate" as="xs:string*">
																							<xsl:for-each select="caldate">
																								<xsl:variable name="var3312_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																										<xsl:variable name="var3339_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var3338_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var3339_map_result_distinctvalues)">
																												<xsl:variable name="var3344_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3344_cond_result_endswith)">
																													<xsl:sequence select="$var3344_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3338_map_result_distinctvalues)">
																											<xsl:sequence select="fn:string-join($var3338_map_result_distinctvalues, ' ')"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var3312_cond_result_logicalor">
																									<xsl:variable name="var3313_cur_cond_result_logicalor" as="xs:string" select="."/>
																									<xsl:variable name="var3315_map_select_time" as="xs:string?">
																										<xsl:for-each select="$var3233_sngdate/time">
																											<xsl:variable name="var3336_result_vmf6_inputtoresult" as="xs:string?">
																												<xsl:call-template name="vmf:vmf6_inputtoresult">
																													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																												</xsl:call-template>
																											</xsl:variable>
																											<xsl:variable name="var3335_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3336_result_vmf6_inputtoresult)) then (if (fn:contains($var3336_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																											<xsl:if test="not(fn:exists($var3335_cond_result_exists))">
																												<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:for-each select="fn:distinct-values($var3315_map_select_time)">
																										<xsl:variable name="var3320_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3320_cond_result_endswith)">
																											<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3320_cond_result_endswith))), 'un'))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3313_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3320_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3320_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3320_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3320_cond_result_endswith)))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3246_map_select_caldate)">
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var3250_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3277_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3276_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3277_map_result_distinctvalues)">
																													<xsl:variable name="var3282_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3282_cond_result_endswith)">
																														<xsl:sequence select="$var3282_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3276_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3276_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3250_cond_result_logicalor">
																										<xsl:variable name="var3251_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3253_map_select_time" as="xs:string?">
																											<xsl:for-each select="$var3233_sngdate/time">
																												<xsl:variable name="var3274_result_vmf6_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf6_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3273_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3274_result_vmf6_inputtoresult)) then (if (fn:contains($var3274_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3273_cond_result_exists))">
																													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3253_map_select_time)">
																											<xsl:variable name="var3258_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3258_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3258_cond_result_endswith))), 'un'))">
																													<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3251_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3258_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3258_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3258_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3258_cond_result_endswith)))))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var3292_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3297_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3296_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3297_map_result_distinctvalues)">
																													<xsl:variable name="var3302_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3302_cond_result_endswith)">
																														<xsl:sequence select="$var3302_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3296_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3296_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3292_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="caldate">
																							<xsl:choose>
																								<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																									<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="''"/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var3237_cond_result_exists">
																				<gml:timePosition>
																					<xsl:variable name="var3241_map_select_caldate" as="xs:string?">
																						<xsl:for-each select="$var3233_sngdate/caldate">
																							<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																								<xsl:sequence select="'now'"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var3240_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3241_map_select_caldate)) then $var3241_map_select_caldate else 'unknown')"/>
																					<xsl:if test="fn:exists($var3240_cond_result_exists)">
																						<xsl:attribute name="indeterminatePosition">
																							<xsl:sequence select="$var3240_cond_result_exists"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:timePosition>
																			</xsl:for-each>
																		</gml:TimeInstant>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
														<xsl:for-each select="srctime/timeinfo/rngdates">
															<xsl:variable name="var3459_rngdates" as="node()" select="."/>
															<gmd:temporalElement>
																<gmd:EX_TemporalExtent>
																	<gmd:extent>
																		<xsl:for-each select="begdate">
																			<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
																				<xsl:attribute name="gco:nilReason">
																					<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
																				</xsl:attribute>
																			</xsl:if>
																		</xsl:for-each>
																		<gml:TimePeriod>
																			<xsl:attribute name="gml:id">
																				<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																			</xsl:attribute>
																			<gml:description>
																				<xsl:sequence select="xs:string(xs:string($var2929_srcinfo/srctime/srccurr))"/>
																			</gml:description>
																			<xsl:variable name="var3577_map_select_begdate" as="xs:string*">
																				<xsl:for-each select="begdate">
																					<xsl:variable name="var3644_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var3671_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var3670_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var3671_map_result_distinctvalues)">
																									<xsl:variable name="var3676_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3676_cond_result_endswith)">
																										<xsl:sequence select="$var3676_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3670_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var3670_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var3644_cond_result_logicalor">
																						<xsl:variable name="var3645_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var3647_map_select_begtime" as="xs:string?">
																							<xsl:for-each select="$var3459_rngdates/begtime">
																								<xsl:variable name="var3668_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var3667_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3668_result_vmf6_inputtoresult)) then (if (fn:contains($var3668_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var3667_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var3647_map_select_begtime)">
																							<xsl:variable name="var3652_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3652_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3652_cond_result_endswith))), 'un'))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3645_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3652_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3652_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3652_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3652_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var3468_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var3577_map_select_begdate)">
																						<xsl:for-each select="begdate">
																							<xsl:variable name="var3582_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3609_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3608_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3609_map_result_distinctvalues)">
																											<xsl:variable name="var3614_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3614_cond_result_endswith)">
																												<xsl:sequence select="$var3614_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3608_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3608_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3582_cond_result_logicalor">
																								<xsl:variable name="var3583_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3585_map_select_begtime" as="xs:string?">
																									<xsl:for-each select="$var3459_rngdates/begtime">
																										<xsl:variable name="var3606_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3605_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3606_result_vmf6_inputtoresult)) then (if (fn:contains($var3606_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3605_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3585_map_select_begtime)">
																									<xsl:variable name="var3590_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3590_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3590_cond_result_endswith))), 'un'))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3583_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3590_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3590_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3590_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3590_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="begdate">
																							<xsl:variable name="var3624_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3629_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3628_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3629_map_result_distinctvalues)">
																											<xsl:variable name="var3634_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3634_cond_result_endswith)">
																												<xsl:sequence select="$var3634_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3628_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3628_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3624_cond_result_logicalor">
																								<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var3463_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="$var3468_cond_result_exists">
																						<xsl:variable name="var3470_map_select_begdate" as="xs:string*">
																							<xsl:for-each select="begdate">
																								<xsl:variable name="var3536_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																										<xsl:variable name="var3563_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var3562_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var3563_map_result_distinctvalues)">
																												<xsl:variable name="var3568_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3568_cond_result_endswith)">
																													<xsl:sequence select="$var3568_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3562_map_result_distinctvalues)">
																											<xsl:sequence select="fn:string-join($var3562_map_result_distinctvalues, ' ')"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var3536_cond_result_logicalor">
																									<xsl:variable name="var3537_cur_cond_result_logicalor" as="xs:string" select="."/>
																									<xsl:variable name="var3539_map_select_begtime" as="xs:string?">
																										<xsl:for-each select="$var3459_rngdates/begtime">
																											<xsl:variable name="var3560_result_vmf6_inputtoresult" as="xs:string?">
																												<xsl:call-template name="vmf:vmf6_inputtoresult">
																													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																												</xsl:call-template>
																											</xsl:variable>
																											<xsl:variable name="var3559_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3560_result_vmf6_inputtoresult)) then (if (fn:contains($var3560_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																											<xsl:if test="not(fn:exists($var3559_cond_result_exists))">
																												<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:for-each select="fn:distinct-values($var3539_map_select_begtime)">
																										<xsl:variable name="var3544_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3544_cond_result_endswith)">
																											<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3544_cond_result_endswith))), 'un'))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3537_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3544_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3544_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3544_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3544_cond_result_endswith)))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3470_map_select_begdate)">
																								<xsl:for-each select="begdate">
																									<xsl:variable name="var3474_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3501_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3500_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3501_map_result_distinctvalues)">
																													<xsl:variable name="var3506_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3506_cond_result_endswith)">
																														<xsl:sequence select="$var3506_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3500_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3500_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3474_cond_result_logicalor">
																										<xsl:variable name="var3475_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3477_map_select_begtime" as="xs:string?">
																											<xsl:for-each select="$var3459_rngdates/begtime">
																												<xsl:variable name="var3498_result_vmf6_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf6_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3497_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3498_result_vmf6_inputtoresult)) then (if (fn:contains($var3498_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3497_cond_result_exists))">
																													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3477_map_select_begtime)">
																											<xsl:variable name="var3482_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3482_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3482_cond_result_endswith))), 'un'))">
																													<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3475_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3482_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3482_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3482_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3482_cond_result_endswith)))))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="begdate">
																									<xsl:variable name="var3516_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3521_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3520_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3521_map_result_distinctvalues)">
																													<xsl:variable name="var3526_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3526_cond_result_endswith)">
																														<xsl:sequence select="$var3526_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3520_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3520_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3516_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="begdate">
																							<xsl:choose>
																								<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																									<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="''"/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var3463_cond_result_exists">
																				<gml:beginPosition>
																					<xsl:for-each select="$var3459_rngdates/begdate">
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																							</xsl:attribute>
																						</xsl:if>
																					</xsl:for-each>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:beginPosition>
																			</xsl:for-each>
																			<xsl:variable name="var3797_map_select_enddate" as="xs:string*">
																				<xsl:for-each select="enddate">
																					<xsl:variable name="var3864_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																							<xsl:variable name="var3891_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var3890_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var3891_map_result_distinctvalues)">
																									<xsl:variable name="var3896_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3896_cond_result_endswith)">
																										<xsl:sequence select="$var3896_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3890_map_result_distinctvalues)">
																								<xsl:sequence select="fn:string-join($var3890_map_result_distinctvalues, ' ')"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var3864_cond_result_logicalor">
																						<xsl:variable name="var3865_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var3867_map_select_endtime" as="xs:string?">
																							<xsl:for-each select="$var3459_rngdates/endtime">
																								<xsl:variable name="var3888_result_vmf6_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf6_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var3887_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3888_result_vmf6_inputtoresult)) then (if (fn:contains($var3888_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var3887_cond_result_exists))">
																									<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var3867_map_select_endtime)">
																							<xsl:variable name="var3872_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var3872_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3872_cond_result_endswith))), 'un'))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3865_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3872_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3872_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3872_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3872_cond_result_endswith)))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var3688_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="fn:exists($var3797_map_select_enddate)">
																						<xsl:for-each select="enddate">
																							<xsl:variable name="var3802_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3829_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3828_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3829_map_result_distinctvalues)">
																											<xsl:variable name="var3834_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3834_cond_result_endswith)">
																												<xsl:sequence select="$var3834_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3828_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3828_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3802_cond_result_logicalor">
																								<xsl:variable name="var3803_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3805_map_select_endtime" as="xs:string?">
																									<xsl:for-each select="$var3459_rngdates/endtime">
																										<xsl:variable name="var3826_result_vmf6_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf6_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3825_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3826_result_vmf6_inputtoresult)) then (if (fn:contains($var3826_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3825_cond_result_exists))">
																											<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3805_map_select_endtime)">
																									<xsl:variable name="var3810_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3810_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3810_cond_result_endswith))), 'un'))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3803_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3810_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3810_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3810_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3810_cond_result_endswith)))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="enddate">
																							<xsl:variable name="var3844_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																									<xsl:variable name="var3849_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3848_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3849_map_result_distinctvalues)">
																											<xsl:variable name="var3854_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3854_cond_result_endswith)">
																												<xsl:sequence select="$var3854_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3848_map_result_distinctvalues)">
																										<xsl:sequence select="fn:string-join($var3848_map_result_distinctvalues, ' ')"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3844_cond_result_logicalor">
																								<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:variable name="var3683_cond_result_exists" as="xs:string*">
																				<xsl:choose>
																					<xsl:when test="$var3688_cond_result_exists">
																						<xsl:variable name="var3690_map_select_enddate" as="xs:string*">
																							<xsl:for-each select="enddate">
																								<xsl:variable name="var3756_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																										<xsl:variable name="var3783_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var3782_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var3783_map_result_distinctvalues)">
																												<xsl:variable name="var3788_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3788_cond_result_endswith)">
																													<xsl:sequence select="$var3788_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3782_map_result_distinctvalues)">
																											<xsl:sequence select="fn:string-join($var3782_map_result_distinctvalues, ' ')"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var3756_cond_result_logicalor">
																									<xsl:variable name="var3757_cur_cond_result_logicalor" as="xs:string" select="."/>
																									<xsl:variable name="var3759_map_select_endtime" as="xs:string?">
																										<xsl:for-each select="$var3459_rngdates/endtime">
																											<xsl:variable name="var3780_result_vmf6_inputtoresult" as="xs:string?">
																												<xsl:call-template name="vmf:vmf6_inputtoresult">
																													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																												</xsl:call-template>
																											</xsl:variable>
																											<xsl:variable name="var3779_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3780_result_vmf6_inputtoresult)) then (if (fn:contains($var3780_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																											<xsl:if test="not(fn:exists($var3779_cond_result_exists))">
																												<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:for-each select="fn:distinct-values($var3759_map_select_endtime)">
																										<xsl:variable name="var3764_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var3764_cond_result_endswith)">
																											<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3764_cond_result_endswith))), 'un'))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3757_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3764_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3764_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3764_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3764_cond_result_endswith)))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3690_map_select_enddate)">
																								<xsl:for-each select="enddate">
																									<xsl:variable name="var3694_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3721_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3720_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3721_map_result_distinctvalues)">
																													<xsl:variable name="var3726_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3726_cond_result_endswith)">
																														<xsl:sequence select="$var3726_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3720_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3720_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3694_cond_result_logicalor">
																										<xsl:variable name="var3695_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3697_map_select_endtime" as="xs:string?">
																											<xsl:for-each select="$var3459_rngdates/endtime">
																												<xsl:variable name="var3718_result_vmf6_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf6_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3717_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3718_result_vmf6_inputtoresult)) then (if (fn:contains($var3718_result_vmf6_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3717_cond_result_exists))">
																													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:normalize-space(fn:string(.)), xs:double('5'), xs:double(xs:decimal(2)))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3697_map_select_endtime)">
																											<xsl:variable name="var3702_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3702_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:lower-case(fn:string($var3702_cond_result_endswith))), 'un'))">
																													<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3695_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:lower-case(fn:string($var3702_cond_result_endswith)))) and ('false' != fn:normalize-space(fn:lower-case(fn:string($var3702_cond_result_endswith))))) and fn:boolean(fn:normalize-space(fn:lower-case(fn:string($var3702_cond_result_endswith)))))) then 'T' else '')), fn:normalize-space(fn:lower-case(fn:string($var3702_cond_result_endswith)))))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="enddate">
																									<xsl:variable name="var3736_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
																											<xsl:variable name="var3741_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3740_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3741_map_result_distinctvalues)">
																													<xsl:variable name="var3746_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3746_cond_result_endswith)">
																														<xsl:sequence select="$var3746_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3740_map_result_distinctvalues)">
																												<xsl:sequence select="fn:string-join($var3740_map_result_distinctvalues, ' ')"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3736_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:for-each select="enddate">
																							<xsl:choose>
																								<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')">
																									<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="''"/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:for-each select="$var3683_cond_result_exists">
																				<gml:endPosition>
																					<xsl:for-each select="$var3459_rngdates/enddate">
																						<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ()))">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')) then 'now' else ())"/>
																							</xsl:attribute>
																						</xsl:if>
																					</xsl:for-each>
																					<xsl:sequence select="xs:string(xs:string(.))"/>
																				</gml:endPosition>
																			</xsl:for-each>
																		</gml:TimePeriod>
																	</gmd:extent>
																</gmd:EX_TemporalExtent>
															</gmd:temporalElement>
														</xsl:for-each>
													</gmd:EX_Extent>
												</gmd:sourceExtent>
											</gmd:LI_Source>
										</gmd:source>
									</xsl:for-each>
								</gmd:LI_Lineage>
							</gmd:lineage>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var3903_metadata" as="node()" select="."/>
				<xsl:for-each select="metainfo/metac">
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var3903_metadata/metainfo/metuc">
										<xsl:attribute name="codeList">
											<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var3903_metadata/metainfo/metuc">
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var3903_metadata/metainfo/metuc">
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var3907_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="$var3903_metadata/metainfo/metuc">
											<xsl:for-each select="$var3903_metadata/metainfo/metuc">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var3907_cond_result_exists)">
									<gco:CharacterString>
										<xsl:variable name="var3908_cond_result_exists" as="xs:string" select="(if (fn:exists($var3903_metadata/metainfo/metuc)) then ' Metadata Use Constraints: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Metadata Access Constraints: ', xs:string(.)), $var3908_cond_result_exists), $var3907_cond_result_exists))"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/metainfo/metsi">
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<gmd:classification>
							<gmd:MD_ClassificationCode>
								<xsl:variable name="var3915_result_vmf13_inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf13_inputtoresult">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(metsc))))"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="var3914_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3915_result_vmf13_inputtoresult)) then $var3915_result_vmf13_inputtoresult else ())"/>
								<xsl:if test="fn:exists($var3914_cond_result_exists)">
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI($var3914_cond_result_exists))"/>
									</xsl:attribute>
								</xsl:if>
								<xsl:attribute name="codeListValue">
									<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"/>
								</xsl:attribute>
								<xsl:variable name="var3917_result_vmf14_inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf14_inputtoresult">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(metsc))))"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="var3916_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3917_result_vmf14_inputtoresult)) then $var3917_result_vmf14_inputtoresult else ())"/>
								<xsl:if test="fn:exists($var3916_cond_result_exists)">
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI($var3916_cond_result_exists))"/>
									</xsl:attribute>
								</xsl:if>
							</gmd:MD_ClassificationCode>
						</gmd:classification>
						<gmd:classificationSystem>
							<gco:CharacterString>
								<xsl:sequence select="xs:string(metscs)"/>
							</gco:CharacterString>
						</gmd:classificationSystem>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string('unknown'))"/>
						</xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished'))">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(xs:string(.))))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:variable name="var3921_cond_result_logicalor" as="xs:string?">
								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present')))">
									<xsl:variable name="var3926_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
											<xsl:choose>
												<xsl:when test="fn:ends-with(., '-')">
													<xsl:if test="fn:ends-with(., '-')">
														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
														</xsl:if>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="."/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var3925_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values($var3926_map_result_distinctvalues)">
											<xsl:variable name="var3931_cond_result_endswith" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
															</xsl:if>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="."/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:if test="fn:exists($var3931_cond_result_endswith)">
												<xsl:sequence select="$var3931_cond_result_endswith"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var3925_map_result_distinctvalues)">
										<xsl:sequence select="fn:string-join($var3925_map_result_distinctvalues, ' ')"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var3921_cond_result_logicalor">
								<gco:Date>
									<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
								</gco:Date>
							</xsl:for-each>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var1_instance/metadata">
							<xsl:variable name="var3942_map_select_metadata" as="xs:string?">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metrd">
									<xsl:variable name="var3946_cond_result_logicalor" as="xs:string?">
										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
											<xsl:variable name="var3951_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
													<xsl:choose>
														<xsl:when test="fn:ends-with(., '-')">
															<xsl:if test="fn:ends-with(., '-')">
																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																</xsl:if>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="."/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var3950_map_result_distinctvalues" as="xs:string*">
												<xsl:for-each select="fn:distinct-values($var3951_map_result_distinctvalues)">
													<xsl:variable name="var3956_cond_result_endswith" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="fn:exists($var3956_cond_result_endswith)">
														<xsl:sequence select="$var3956_cond_result_endswith"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var3950_map_result_distinctvalues)">
												<xsl:sequence select="fn:string-join($var3950_map_result_distinctvalues, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var3946_cond_result_logicalor">
										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var3940_cond_result_exists" as="xs:string?" select="(if (fn:exists($var3942_map_select_metadata)) then $var3942_map_select_metadata else ' ')"/>
							<xsl:if test="fn:exists($var3940_cond_result_exists)">
								<gco:CharacterString>
									<xsl:variable name="var3941_cond_result_exists" as="xs:string" select="(if (fn:exists($var1_instance/metadata/metainfo/metrd)) then ' Metadata Review Date: ' else ' ')"/>
									<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('This metadata was automatically generated from the ', xs:string(xs:string(metainfo/metstdn))), 'standard version '), xs:string(metainfo/metstdv)), ' using the January 2013 version of the FGDC Bio to ISO 19115-2 Bio transform.'), $var3941_cond_result_exists), $var3940_cond_result_exists)))"/>
								</gco:CharacterString>
							</xsl:if>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:individualName>
								<xsl:variable name="var3964_map_select_metadata" as="xs:string?">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var3963_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var3964_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var3963_cond_result_exists)">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space($var3963_cond_result_exists)"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:individualName>
							<gmd:organisationName>
								<xsl:variable name="var3973_map_select_metadata" as="xs:string?">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var3972_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var3973_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var3972_cond_result_exists)">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space($var3972_cond_result_exists)"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:organisationName>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
								<gmd:positionName>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:positionName>
							</xsl:for-each>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:phone>
										<gmd:CI_Telephone>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var3985_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:voice>
													<gco:CharacterString>
														<xsl:sequence select="$var3985_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:voice>
											</xsl:for-each-group>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var3989_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:facsimile>
													<gco:CharacterString>
														<xsl:sequence select="$var3989_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:facsimile>
											</xsl:for-each-group>
										</gmd:CI_Telephone>
									</gmd:phone>
									<xsl:for-each select="$var1_instance/metadata">
										<xsl:variable name="var3991_metadata" as="node()" select="."/>
										<xsl:for-each select="metainfo/metc/cntinfo/cntaddr">
											<gmd:address>
												<gmd:CI_Address>
													<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var3997_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:deliveryPoint>
															<gco:CharacterString>
																<xsl:sequence select="$var3997_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:deliveryPoint>
													</xsl:for-each-group>
													<gmd:city>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(city))"/>
														</gco:CharacterString>
													</gmd:city>
													<gmd:administrativeArea>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(state))"/>
														</gco:CharacterString>
													</gmd:administrativeArea>
													<gmd:postalCode>
														<gco:CharacterString>
															<xsl:sequence select="fn:normalize-space(xs:string(postal))"/>
														</gco:CharacterString>
													</gmd:postalCode>
													<xsl:for-each select="country">
														<gmd:country>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:country>
													</xsl:for-each>
													<xsl:for-each-group select="$var3991_metadata/metainfo/metc/cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var4003_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:electronicMailAddress>
															<gco:CharacterString>
																<xsl:sequence select="$var4003_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:electronicMailAddress>
													</xsl:for-each-group>
												</gmd:CI_Address>
											</gmd:address>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
										<gmd:hoursOfService>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:hoursOfService>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
										<gmd:contactInstructions>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:contactInstructions>
									</xsl:for-each>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('custodian'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
									</xsl:attribute>
									<xsl:sequence select="'custodian'"/>
								</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmi:MI_Metadata>
	</xsl:template>
</xsl:stylesheet>
